<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Linear models</title>

<script src="site_libs/header-attrs-2.21/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/clipboard-2.0.6/clipboard.min.js"></script>
<link href="site_libs/xaringanExtra-clipboard-0.2.6/xaringanExtra-clipboard.css" rel="stylesheet" />
<script src="site_libs/xaringanExtra-clipboard-0.2.6/xaringanExtra-clipboard.js"></script>
<script>window.xaringanExtraClipboard(null, {"button":"Copy Code","success":"Copied!","error":"Press Ctrl+C to Copy"})</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; } /* Alert */
code span.an { color: #008000; } /* Annotation */
code span.at { } /* Attribute */
code span.bu { } /* BuiltIn */
code span.cf { color: #0000ff; } /* ControlFlow */
code span.ch { color: #008080; } /* Char */
code span.cn { color: #585cf6; } /* Constant */
code span.co { color: #4c886b; } /* Comment */
code span.cv { color: #008000; } /* CommentVar */
code span.do { color: #008000; } /* Documentation */
code span.dv { color: #0000cd; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #0000cd; } /* Float */
code span.im { } /* Import */
code span.in { color: #008000; } /* Information */
code span.kw { color: #0000ff; } /* Keyword */
code span.op { color: #687687; } /* Operator */
code span.ot { color: #ff4000; } /* Other */
code span.pp { color: #ff4000; } /* Preprocessor */
code span.sc { color: #008080; } /* SpecialChar */
code span.ss { color: #008080; } /* SpecialString */
code span.st { color: #036a07; } /* String */
code span.va { } /* Variable */
code span.vs { color: #008080; } /* VerbatimString */
code span.wa { color: #008000; font-weight: bold; } /* Warning */

.sourceCode .row {
  width: 100%;
}
.sourceCode {
  overflow-x: auto;
}
.code-folding-btn {
  margin-right: -30px;
}
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<link rel="stylesheet" href="styles.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">OCEAN_5098</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="environment.html">Environment</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Manipulation
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="basics.html">Basics</a>
    </li>
    <li>
      <a href="dplyr.html">dplyr</a>
    </li>
    <li>
      <a href="tidyr.html">tidyr</a>
    </li>
  </ul>
</li>
<li>
  <a href="types.html">Types &amp; structures</a>
</li>
<li>
  <a href="graphs.html">Graphics</a>
</li>
<li>
  <a href="maps.html">Mapping</a>
</li>
<li>
  <a href="functions.html">Loop &amp; functions</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Statistics
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="stat_1.html">Initiation</a>
    </li>
    <li>
      <a href="stat_2.html">Linear models</a>
    </li>
    <li>
      <a href="stat_3.html">Multivariates</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Linear models</h1>

</div>


<a href="data:text/x-markdown;base64,LS0tDQp0aXRsZTogIkxpbmVhciBtb2RlbHMiDQotLS0NCg0KYGBge3IgZXZhbCA9IFRSVUUsICBtZXNzYWdlPUYsIGluY2x1ZGU9Riwgd2FybmluZz1GLCBwdXJsPUYsIHJlc3VsdHM9ImhpZGUifQ0Ka25pdHI6OnB1cmwoJ3N0YXRfMi5SbWQnLCBkb2N1bWVudGF0aW9uID0gRikNCmBgYA0KDQpgYGB7ciBlY2hvPUZBTFNFfQ0KeGFyaW5nYW5FeHRyYTo6dXNlX2NsaXBib2FyZCgpDQpgYGANCg0KYGBge3IgZWNobz1GQUxTRSwgcHVybD1GfQ0KeGZ1bjo6ZW1iZWRfZmlsZSgnc3RhdF8yLlJtZCcpDQpgYGANCg0KYGBge3IgZWNobz1GQUxTRSwgcHVybD1GfQ0KeGZ1bjo6ZW1iZWRfZmlsZSgnc3RhdF8yLlInKQ0KYGBgDQoNCmBgYHtyIGVjaG89RkFMU0UsIHB1cmw9Rn0NCnhmdW46OmVtYmVkX2ZpbGUoJ2RhdGEvUGxhbnRfaGVpZ2h0LmNzdicpDQpgYGANCg0KYGBge3IgZWNobz1GQUxTRSwgcHVybD1GfQ0KeGZ1bjo6ZW1iZWRfZmlsZSgnZGF0YS9zZXNzaWxlLmNzdicpDQpgYGANCg0KYGBge3IgZWNobz1GQUxTRSwgcHVybD1GfQ0KeGZ1bjo6ZW1iZWRfZmlsZSgnZGF0YS90dXJ0bGVzLmNzdicpDQpgYGANCg0KYGBge3IgZWNobz1GQUxTRSwgcHVybD1GfQ0KeGZ1bjo6ZW1iZWRfZmlsZSgnZGF0YS9taW5rLmNzdicpDQpgYGANCg0KYGBge3IgZWNobz1GQUxTRSwgcHVybD1GfQ0KeGZ1bjo6ZW1iZWRfZmlsZSgnZGF0YS9jcmFicy5jc3YnKQ0KYGBgDQoNCmBgYHtyIGVjaG89RkFMU0UsIHB1cmw9Rn0NCnhmdW46OmVtYmVkX2ZpbGUoJ2RhdGEvZXN0dWFyaWVzLmNzdicpDQpgYGANCg0KLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCg0KYGBge3IsIG1lc3NhZ2U9Riwgd2FybmluZz1GfQ0KbGlicmFyeShndmxtYSkNCmxpYnJhcnkoSG1pc2MpDQpsaWJyYXJ5KGNvcnJwbG90KQ0KbGlicmFyeShtdmFidW5kKQ0KbGlicmFyeShnZ3Bsb3QyKQ0KbGlicmFyeSAobG1lNCkNCmxpYnJhcnkobWdjdikNCmBgYA0KDQoNClByZXZpb3VzbHksIHdlIHNhdyB0aGF0IGNvcnJlbGF0aW9ucyBsb29rIGF0IHRoZSBhc3NvY2lhdGlvbiBiZXR3ZWVuIHR3byB2YXJpYWJsZXMuIFRoZSBtZWFzdXJlIG9mIHRoaXMgYXNzb2NpYXRpb24gaXMgY2FsbGVkIHRoZSBQZWFyc29uIGNvZWZmaWNpZW50IChwYXJhbWV0cmljKS4gSXQgaXMgdGhlIGNvdmFyaWFuY2Ugb2YgdGhlIHR3byB2YXJpYWJsZXMgZGl2aWRlZCBieSB0aGUgcHJvZHVjdCBvZiB0aGVpciBzdGFuZGFyZCBkZXZpYXRpb24uIEl0IGlzIHNjYWxlZCBiZXR3ZWVuIDEgKGZvciBhIHBlcmZlY3QgcG9zaXRpdmUgY29ycmVsYXRpb24pIHRvIC0xIChmb3IgYSBwZXJmZWN0IG5lZ2F0aXZlIGNvcnJlbGF0aW9uKSwgMCB3b3VsZCBiZSBjb21wbGV0ZSByYW5kb21uZXNzLiBVc2luZyBwYXJhbWV0cmljIGFzc3VtcHRpb24gdGhpcyBjb2VmZmljaWVudCBkaXZpZGVkIGJ5IGl0cyBzdGFuZGFyZCBlcnJvciBnaXZlcyBhIHZhbHVlIHRoYXQgZm9sbG93IGEgdC1kaXN0cmlidXRpb24uIFNxdWFyZWQsIHdlIG9idGFpbiB0aGUgYW1vdW50IG9mIHZhcmlhdGlvbiBpbiAkeSQgZXhwbGFpbmVkIGJ5ICR4JC4gSG93ZXZlciBzdWNoIHJlc3VsdHMgZG8gbm90IGFsbG93IGFueSBleHBsYW5hdGlvbiBvZiB0aGUgZWZmZWN0IG9mICR4JCBvbiAkeSQsIGluZGVlZCAkeCQgY291bGQgYWN0IG9uICR5JCBpbiB2YXJpb3VzIHdheSB0aGF0IGFyZSBub3QgYWx3YXlzIGRpcmVjdCwgYWxsIHdlIGNhbiBzYXkgZnJvbSB0aGUgY29ycmVsYXRpb24gaXMgdGhhdCB0aGVzZSB0d28gdmFyaWFibGVzIGFyZSBsaW5rZWQgc29tZWhvdywgdG8gcmVhbGx5IGV4cGxhaW4gYW5kIG1lYXN1cmUgZWZmZWN0cyBvZiAkeCQgb24gJHkkIHdlIG5lZWQgdG8gdXNlIHJlZ3Jlc3Npb24gbWV0aG9kLiBUaGF0J3MgdGhlIHJlYXNvbiB3aHlgbG1gIGlzIHVzZWQgaW4gYGFibGluZSgpYCBvciBgZ2VvbV9zbW9vdGhgIGluIG9yZGVyIHRvIHJlcHJlc2VudCBjb3JyZWxhdGlvbi4gDQoNCiMgTGluZWFyIHJlZ3Jlc3Npb24NCg0KIyMgT25lIHByZWRpY3RvciANCg0KUmVncmVzc2lvbiBpcyBzb21laG93IGRpZmZlcmVudCBmcm9tIGNvcnJlbGF0aW9uIGJlY2F1c2UgaXQgdHJ5IHRvIHB1dCB2YXJpYWJsZXMgaW50byBlcXVhdGlvbiBhbmQgdGh1cyBleHBsYWluIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIHRoZW0uDQpJbiAqKk1vZGVsIEkgcmVncmVzc2lvbioqIChpbmRlZWQgd2UgaGF2ZSBNb2RlbCBJSSB3aGVuIHR3byB2YXJpYWJsZXMgaW4gdGhlIHJlZ3Jlc3Npb24gZXF1YXRpb24gYXJlIHJhbmRvbSAsIGkuZS4gbm8gY29udHJvbGxlZCBieSB0aGUgcmVzZWFyY2hlciksIGl0IGlzIHVzZWQgdG8gcHJlZGljdCBhIHF1YW50aXRhdGl2ZSBvdXRjb21lIG9mIGEgZGVwZW5kZW50IHZhcmlhYmxlICR5JCBvbiB0aGUgYmFzaXMgb2Ygb25lIHNpbmdsZSBpbmRlcGVuZGVudCBwcmVkaWN0b3IgdmFyaWFibGUgJHgkLiBUaGUgZ29hbCBpcyB0byBidWlsZCBhIG1hdGhlbWF0aWNhbCBtb2RlbCAob3IgZm9ybXVsYSkgdGhhdCBkZWZpbmVzICR5JCBhcyBhIGZ1bmN0aW9uIG9mIHRoZSAkeCQgdmFyaWFibGUsIGFuZCB0aGF0J3Mgd2h5IGxpbmVhciByZWdyZXNzaW9uIGFyZSBhbHNvIGNhbGxlZCBsaW5lYXIgbW9kZWxsaW5nIChwcmV2aW91c2x5IGFkZGVkIHRvIG91ciBzY2F0dGVyIHBsb3QgdXNpbmcgYGFibGluZWAgb3IgYGdlb21fc21vb3RoYC4NCg0KTm90ZSB0aGF0IHRoZSBgbGluZWFyYCBpbiBsaW5lYXIgbW9kZWwgZG9lcyBub3QgaW1wbHkgYSBzdHJhaWdodC1saW5lIHJlbGF0aW9uc2hpcCBidXQgcmF0aGVyIHRoYXQgdGhlIHJlc3BvbnNlIGlzIGEgbGluZWFyIChhZGRpdGl2ZSkgY29tYmluYXRpb24gb2YgdGhlIGVmZmVjdHMgb2YgdGhlIGV4cGxhbmF0b3J5IHZhcmlhYmxlcy4gSG93ZXZlciwgYmVjYXVzZSB3ZSB0ZW5kIHRvIHN0YXJ0IGJ5IGZpdHRpbmcgdGhlIHNpbXBsZXN0IHJlbGF0aW9uc2hpcCwgbWFueSBsaW5lYXIgbW9kZWxzIGFyZSByZXByZXNlbnRlZCBieSBzdHJhaWdodCBsaW5lcy4NCg0KDQpPbmNlLCB3ZSBidWlsdCBhIHN0YXRpc3RpY2FsbHkgc2lnbmlmaWNhbnQgbW9kZWwsIGl04oCZcyBwb3NzaWJsZSB0byB1c2UgaXQgZm9yIHByZWRpY3RpbmcgZnV0dXJlIG91dGNvbWUgb24gdGhlIGJhc2lzIG9mIG5ldyAkeCQgdmFsdWVzLg0KDQojIyMgRm9ybXVsYSBhbmQgYmFzaWNzDQoNClRoZSBmb3JtdWxhIG9mIGxpbmVhciByZWdyZXNzaW9uIGNhbiBiZSB3cml0dGVuIGFzIGZvbGxvd3M6ICQkIHkgPSBcYmV0YV8wICsgXGJldGFfMSp4ICsgXGVwc2lsb24gJCQNCg0Kd2hlcmU6DQoNCisgJFxiZXRhXzAkIGFuZCAkXGJldGFfMSQgYXJlIGtub3duIGFzIHRoZSByZWdyZXNzaW9uIF9fYmV0YSBjb2VmZmljaWVudHNfXyBvciBfX3BhcmFtZXRlcnNfXzoNCg0KICArICRcYmV0YV8wJCBpcyB0aGUgX19pbnRlcmNlcHRfXyBvZiB0aGUgcmVncmVzc2lvbiBsaW5lOyB0aGF0IGlzIHRoZSBwcmVkaWN0ZWQgdmFsdWUgd2hlbiBfeCA9IDBfLg0KICArICRcYmV0YTEkIGlzIHRoZSBfX3Nsb3BlX18gb2YgdGhlIHJlZ3Jlc3Npb24gbGluZS4NCiAgDQorICRcZXBzaWxvbiQgaXMgdGhlIF9fZXJyb3IgdGVybV9fIChhbHNvIGtub3duIGFzIHRoZSBfX3Jlc2lkdWFsIGVycm9yc19fKS5UaGUgZXJyb3IgdGVybSBpcyBkcmF3biBmcm9tIGEgc3RhdGlzdGljYWwgZGlzdHJpYnV0aW9uIHRoYXQgY2FwdHVyZXMgdGhlIHJhbmRvbSB2YXJpYWJpbGl0eSBpbiB0aGUgcmVzcG9uc2UuIEluIHN0YW5kYXJkIGxpbmVhciByZWdyZXNzaW9uIHRoaXMgaXMgYXNzdW1lZCB0byBiZSBhIG5vcm1hbCAoR2F1c3NpYW4pIGRpc3RyaWJ1dGlvbi4NCg0KVGhlIGZpZ3VyZSBiZWxvdyBpbGx1c3RyYXRlcyB0aGUgbGluZWFyIHJlZ3Jlc3Npb24gbW9kZWwsIHdoZXJlOg0KDQorIHRoZSBiZXN0LWZpdCByZWdyZXNzaW9uIGxpbmUgaXMgaW4gYmx1ZQ0KKyB0aGUgaW50ZXJjZXB0ICgkXGJldGFfMCQpIGFuZCB0aGUgc2xvcGUgKCRcYmV0YV8xJCkgYXJlIHNob3duIGluIGdyZWVuDQorIHRoZSBlcnJvciB0ZXJtcyAoJFxlcHNpbG9uJCkgYXJlIHJlcHJlc2VudGVkIGJ5IHZlcnRpY2FsIHJlZCBsaW5lcw0KDQpgYGB7ciwgZWNobz1GQUxTRSwgZmlnLmFsaWduPSdjZW50ZXInLCBvdXQud2lkdGggPSAnNTAlJ30NCmtuaXRyOjppbmNsdWRlX2dyYXBoaWNzKCJpbGx1c3RyYXRpb25zL2xpbmVhci1yZWdyZXNzaW9uLnBuZyIpDQpgYGANCg0KRnJvbSB0aGUgZmlndXJlIGFib3ZlLCBpdCBjYW4gYmUgc2VlbiB0aGF0IG5vdCBhbGwgdGhlIGRhdGEgcG9pbnRzIGZhbGwgZXhhY3RseSBvbiB0aGUgZml0dGVkIHJlZ3Jlc3Npb24gbGluZS4gU29tZSBvZiB0aGUgcG9pbnRzIGFyZSBhYm92ZSB0aGUgYmx1ZSBjdXJ2ZSBhbmQgc29tZSBhcmUgYmVsb3cgaXQ7IG92ZXJhbGwsIHRoZSByZXNpZHVhbCBlcnJvcnMgKCRcZXBzaWxvbiQpIGhhdmUgYXBwcm94aW1hdGVseSBtZWFuIHplcm8uDQoNCioqVEVSTUlOT0xPR1kgQUxFUlQqKg0KDQpUaGUgc3VtIG9mIHRoZSBzcXVhcmVzIG9mIHRoZSByZXNpZHVhbCBlcnJvcnMgYXJlIGNhbGxlZCB0aGUgX19SZXNpZHVhbCBTdW0gb2YgU3F1YXJlc19fIG9yIF9fUlNTX18uDQoNClRoZSBhdmVyYWdlIHZhcmlhdGlvbiBvZiBwb2ludHMgYXJvdW5kIHRoZSBmaXR0ZWQgcmVncmVzc2lvbiBsaW5lIGlzIGNhbGxlZCB0aGUgX19SZXNpZHVhbCBTdGFuZGFyZCBFcnJvciAoUlNFKV9fLiBUaGlzIGlzIG9uZSB0aGUgbWV0cmljcyB1c2VkIHRvIGV2YWx1YXRlIHRoZSBvdmVyYWxsIHF1YWxpdHkgb2YgdGhlIGZpdHRlZCByZWdyZXNzaW9uIG1vZGVsLiBUaGUgbG93ZXIgdGhlIFJTRSwgdGhlIGJldHRlciBpdCBpcy4NCg0KU2luY2UgdGhlIG1lYW4gZXJyb3IgdGVybSBpcyB6ZXJvLCB0aGUgb3V0Y29tZSB2YXJpYWJsZSB5IGNhbiBiZSBhcHByb3hpbWF0ZWx5IGVzdGltYXRlZCBhcyBmb2xsb3c6DQoNCg0KJCR5PSBcYmV0YV8wK1xiZXRhXzEqeCQkDQoNCk1hdGhlbWF0aWNhbGx5LCB0aGUgYmV0YSBjb2VmZmljaWVudHMgKCRcYmV0YV8wJCBhbmQgJFxiZXRhXzEkKSBhcmUgZGV0ZXJtaW5lZCBzbyB0aGF0IHRoZSAqKlJTUyoqIGlzIGFzIG1pbmltYWwgYXMgcG9zc2libGUuIFRoaXMgbWV0aG9kIG9mIGRldGVybWluaW5nIHRoZSBiZXRhIGNvZWZmaWNpZW50cyBpcyB0ZWNobmljYWxseSBjYWxsZWQgX19sZWFzdCBzcXVhcmVzX18gcmVncmVzc2lvbiBvciBfX29yZGluYXJ5IGxlYXN0IHNxdWFyZXNfXyAoT0xTKSByZWdyZXNzaW9uLg0KDQpPbmNlLCB0aGUgYmV0YSBjb2VmZmljaWVudHMgYXJlIGNhbGN1bGF0ZWQsIGEgKnQqLXRlc3QgaXMgcGVyZm9ybWVkIHRvIGNoZWNrIHdoZXRoZXIgb3Igbm90IHRoZXNlIGNvZWZmaWNpZW50cyBhcmUgc2lnbmlmaWNhbnRseSBkaWZmZXJlbnQgZnJvbSB6ZXJvLiBBIG5vbi16ZXJvIGJldGEgY29lZmZpY2llbnRzIG1lYW5zIHRoYXQgdGhlcmUgaXMgYSBzaWduaWZpY2FudCByZWxhdGlvbnNoaXAgYmV0d2VlbiB0aGUgcHJlZGljdG9ycyAoJHgkKSBhbmQgdGhlIG91dGNvbWUgdmFyaWFibGUgKCR5JCkuDQoNCg0KIyMjIFJ1bm5pbmcgdGhlIGFuYWx5c2lzDQoNClNvLCB0aGUgZ29hbCBpbiBsaW5lYXIgcmVncmVzc2lvbiBpcyBvYnRhaW4gdGhlIGJlc3QgZXN0aW1hdGVzIGZvciB0aGUgbW9kZWwgY29lZmZpY2llbnRzICgkXGJldGFfMCQgYW5kICRcYmV0YV8xJCkuIEluIFIgeW91IGNhbiBmaXQgbGluZWFyIG1vZGVscyB1c2luZyB0aGUgZnVuY3Rpb24gYGxtYC4NCg0KSW4gdGhpcyBleGFtcGxlLCB3ZSB3aWxsIHVzZSBhIGRhdGEgc2V0IG9uIHBsYW50IGhlaWdodHMgYXJvdW5kIHRoZSB3b3JsZCBgUGxhbnRfaGVpZ2h0LmNzdmAuDQoNCg0KYGBge3J9DQpQbGFudF9oZWlnaHQgPC0gcmVhZC5jc3YoZmlsZSA9ICJEYXRhL1BsYW50X2hlaWdodC5jc3YiLCBoZWFkZXIgPSBUUlVFKQ0KYGBgDQoNClRoZSBtYWluIGFyZ3VtZW50IHRvIGBsbWAgaXMgdGhlIG1vZGVsIGZvcm11bGEgYHkgfiB4YCwgd2hlcmUgdGhlIHJlc3BvbnNlIHZhcmlhYmxlIGlzIG9uIHRoZSBsZWZ0IG9mIHRoZSB0aWxkZSBzeW1ib2wgKGB+YCkgYW5kIHRoZSBleHBsYW5hdG9yeSB2YXJpYWJsZSBpcyBvbiB0aGUgcmlnaHQuIGBsbWAgYWxzbyBoYXMgYW4gb3B0aW9uYWwgZGF0YSBhcmd1bWVudCB0aGF0IGxldHMgeW91IHNwZWNpZnkgYSBkYXRhIGZyYW1lIGZyb20gd2hpY2ggdGhlIHZhcmlhYmxlcyB3aWxsIGJlIHRha2VuLg0KDQoNClRvIHRlc3Qgd2hldGhlciBwbGFudCBoZWlnaHQgaXMgYXNzb2NpYXRlZCB3aXRoIHRlbXBlcmF0dXJlICwgd2Ugd291bGQgbW9kZWwgaGVpZ2h0IGFzIHRoZSBkZXBlbmRlbnQgdmFyaWFibGUgKGluIHRoaXMgY2FzZSB3ZSBhcmUgdXNpbmcgdGhlIGxvZyBvZiBwbGFudCBoZWlnaHQpIGFuZCB0ZW1wZXJhdHVyZSBhcyB0aGUgcHJlZGljdG9yIHZhcmlhYmxlICRsb2dodCA9IFxiZXRhXzAgKyBcYmV0YV8xICogdGVtcCQuIA0KDQoNCmBgYHtyfQ0KbW9kMV9wbGFudDwtIGxtKGxvZ2h0IH4gdGVtcCwgZGF0YSA9IFBsYW50X2hlaWdodCkNCmBgYA0KV2UgY2FuIGV4dHJhY3RlZCB0aGUgYmV0YSBjb2VmZmljaWVudHMgb2YgdGhpcyBsaW5lYXIgbW9kZWwgdXNpbmc6DQoNCmBgYHtyLCAgZXZhbD1ULCB3YXJuaW5nPUYsIG1lc3NhZ2U9Rn0NCm1vZDFfcGxhbnQkY29lZmZpY2llbnRzDQpgYGANClRoZSBlc3RpbWF0ZXMgZm9yIHRoZSBjb2VmZmljaWVudHMgZ2l2ZSB5b3UgdGhlIHNsb3BlKCRcYmV0YV8wJCkgYW5kIGludGVyY2VwdCAoJFxiZXRhXzEkKSBmb3IgdGhlIGB0ZW1wYCB2YXJpYWJsZS4gSW4gdGhpcyBleGFtcGxlLCB0aGUgcmVncmVzc2lvbiBlcXVhdGlvbiBmb3IgKGxvZykgcGxhbnQgaGVpZ2h0IGFzIGEgZnVuY3Rpb24gb2YgdGVtcGVyYXR1cmUgaXM6DQoNCg0KJGxvZyhwbGFudGhlaWdodCkgID0gLTAuMjI1NjYgKyAwLjA0MjQxICogIHRlbXAgKyBcZXBzaWxvbiQgDQoNCg0KKyB0aGUgaW50ZXJjZXB0ICgkXGJldGFfMCQpIGlzICQtMC4yMjU2NiQuIEl0IGNhbiBiZSBpbnRlcnByZXRlZCBhcyB0aGUgcHJlZGljdGVkIChsb2cpIHBsYW50IGhlaWd0aCB3aGVuIHRlbXBlcmF0dXJlIGlzIGVxdWFsIHRvIHplcm8uIFJlZ3Jlc3Npb24gdGhyb3VnaCB0aGUgb3JpZ2luIGlzIHdoZW4geW91IGZvcmNlIHRoZSBpbnRlcmNlcHQgb2YgYSByZWdyZXNzaW9uIG1vZGVsIHRvIGVxdWFsIHplcm8uIEl04oCZcyBhbHNvIGtub3duIGFzIGZpdHRpbmcgYSBtb2RlbCB3aXRob3V0IGFuIGludGVyY2VwdCAoZS5nLiwgdGhlIGludGVyY2VwdC1mcmVlIGxpbmVhciBtb2RlbCAkeSA9IFxiZXRhXzEqeCQgaXMgZXF1aXZhbGVudCB0byB0aGUgbW9kZWwgJHkgPSBcYmV0YV8wICsgXGJldGFfMSp4JCB3aXRoICRcYmV0YV8wPTAkKS4gS25vd2luZyB0aGF0IHRoZSAqKnRydWUgcmVsYXRpb25zaGlwKiogYmV0d2VlbiB5b3VyIHByZWRpY3RvcnMgYW5kIHRoZSBleHBlY3RlZCB2YWx1ZSBvZiB5b3VyIGRlcGVuZGVudCB2YXJpYWJsZSBoYXMgdG8gcGFzcyB0aHJvdWdoIHRoZSBvcmlnaW4gd291bGQgYmUgYSBnb29kIHJlYXNvbiBmb3IgZm9yY2luZyB0aGUgZXN0aW1hdGVkIHJlbGF0aW9uc2hpcCB0aHJvdWdoIHRoZSBvcmlnaW4gaWYgeW91IGtuZXcgZm9yIGNlcnRhaW4gd2hhdCB0aGUgdHJ1ZSByZWxhdGlvbnNoaXAgd2FzIChiZSBjYXJlZnVsIHZlcnkgcmFyZSBjYXNlcyB3aGVyZSBpdCBpcyBqdXN0aWZpZWQgdG8gcmVtb3ZlIHRoZSBpbnRlcmNlcHQpLg0KDQoNCisgdGhlIHJlZ3Jlc3Npb24gYmV0YSBjb2VmZmljaWVudCBmb3IgdGhlIHZhcmlhYmxlIGB0ZW1wYCAoJFxiZXRhMSQpLCBhbHNvIGtub3duIGFzIHRoZSBzbG9wZSwgaXMgJDAuMDQyNDEkLiBUaGlzIG1lYW5zIHRoYXQsIGZvciBvbmUgdW5pdCBvZiAkdGVtcCQsIHdlIGNhbiBleHBlY3QgYW4gaW5jcmVhc2Ugb2YgJDAuMDQyNDEkIHVuaXRzIGluICRsb2cocGxhbnRoZWlnaHQpJC4gDQoNCg0KQ2FsbGluZyBgc3VtbWFyeWAgb24gYSBtb2RlbCBvYmplY3QgcHJvZHVjZXMgYSBsb3Qgb2YgdXNlZnVsIGluZm9ybWF0aW9uIGJ1dCBvbmUgb2YgdGhlIG1haW4gdGhpbmdzIHRvIGxvb2sgb3V0IGZvciBhcmUgdGhlIHQtc3RhdGlzdGljcyBhbmQgcC12YWx1ZXMgZm9yIGVhY2ggY29lZmZpY2llbnQuIFRoZXNlIHRlc3QgdGhlIG51bGwgaHlwb3RoZXNpcyB0aGF0IHRoZSB0cnVlIHZhbHVlIGZvciB0aGUgY29lZmZpY2llbnQgaXMgMC4NCg0KDQpgYGB7cn0NCnN1bW1hcnkobW9kMV9wbGFudCkNCmBgYA0KTG9va2luZyBhdCBvbmx5IHRoZSBwLXZhbHVlcywgdGhpcyBzaW1wbGUgbW9kZWwgc2VlbXMgdG8gZml0IHRoZSBkYXRhIHZlcnkgd2VsbC4gRm9yIHRoZSBpbnRlcmNlcHQgd2UgdXN1YWxseSBkb27igJl0IGNhcmUgaWYgaXQgaXMgemVybyBvciBub3QsIGJ1dCBmb3IgdGhlIG90aGVyIGNvZWZmaWNpZW50ICh0aGUgc2xvcGUpLCBhIHZhbHVlIHNpZ25pZmljYW50bHkgZGlmZmVyaW5nIGZyb20gemVybyBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBpcyBhbiBhc3NvY2lhdGlvbiBiZXR3ZWVuIHRoYXQgZXhwbGFuYXRvcnkgdmFyaWFibGUgYW5kIHRoZSByZXNwb25zZS4gSW4gdGhpcyBleGFtcGxlLCBhbiBpbmNyZWFzZSBpbiB0ZW1wZXJhdHVyZSBpcyBhc3NvY2lhdGVkIHdpdGggYW4gaW5jcmVhc2UgaW4gcGxhbnQgaGVpZ2h0LiBCdXQgYGxtYCBvdXRwdXQgdGVsbHMgdXMgbXVjaCBtb3JlLiBUaGUgc3VtbWFyeSBvdXRwdXRzIHNob3dzIDYgY29tcG9uZW50cywgaW5jbHVkaW5nDQoNCisgKipDYWxsKiogc2hvd3MgdGhlIGZ1bmN0aW9uIGNhbGwgdXNlZCB0byBjb21wdXRlIHRoZSByZWdyZXNzaW9uIG1vZGVsLg0KDQorICoqUmVzaWR1YWxzKiogcHJvdmlkZSBhIHF1aWNrIHZpZXcgb2YgdGhlIGRpc3RyaWJ1dGlvbiBvZiB0aGUgcmVzaWR1YWxzLCB3aGljaCBieSBkZWZpbml0aW9uIGhhdmUgYSBtZWFuIHplcm8uIFRoZXJlZm9yZSwgdGhlIG1lZGlhbiBzaG91bGQgbm90IGJlIGZhciBmcm9tIHplcm8sIGFuZCB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBzaG91bGQgYmUgcm91Z2hseSBlcXVhbCBpbiBhYnNvbHV0ZSB2YWx1ZS4NCg0KKyAqKkNvZWZmaWNpZW50cyoqIHNob3dzIHRoZSByZWdyZXNzaW9uIGJldGEgY29lZmZpY2llbnRzIGFuZCB0aGVpciBzdGF0aXN0aWNhbCBzaWduaWZpY2FuY2UuIFByZWRpY3RvciB2YXJpYWJsZXMsIHRoYXQgYXJlIHNpZ25pZmljYW50bHkgYXNzb2NpYXRlZCB0byB0aGUgb3V0Y29tZSB2YXJpYWJsZSwgYXJlIG1hcmtlZCBieSBzdGFycy4NCg0KKyAqKlJlc2lkdWFsIHN0YW5kYXJkIGVycm9yKiogKFJTRSksICoqUi1zcXVhcmVkKiogKFIyKSBhbmQgdGhlICoqRi1zdGF0aXN0aWMqKiBhcmUgbWV0cmljcyB0aGF0IGFyZSB1c2VkIHRvIGNoZWNrIGhvdyB3ZWxsIHRoZSBtb2RlbCBmaXRzIHRvIG91ciBkYXRhLg0KDQoNCiMjIyMgQ29lZmZpY2llbnRzIHNpZ25pZmljYW5jZQ0KDQpUaGUgY29lZmZpY2llbnRzIHRhYmxlLCBpbiB0aGUgbW9kZWwgc3RhdGlzdGljYWwgc3VtbWFyeSwgc2hvd3M6DQoNCisgdGhlIGVzdGltYXRlcyBvZiB0aGUgKipiZXRhIGNvZWZmaWNpZW50cyoqDQoNCisgdGhlICoqc3RhbmRhcmQgZXJyb3JzKiogKFNFKSwgd2hpY2ggZGVmaW5lcyB0aGUgYWNjdXJhY3kgb2YgYmV0YSBjb2VmZmljaWVudHMuIEZvciBhIGdpdmVuIGJldGEgY29lZmZpY2llbnQsIHRoZSBTRSByZWZsZWN0cyBob3cgdGhlIGNvZWZmaWNpZW50IHZhcmllcyB1bmRlciByZXBlYXRlZCBzYW1wbGluZy4gSXQgY2FuIGJlIHVzZWQgdG8gY29tcHV0ZSB0aGUgY29uZmlkZW5jZSBpbnRlcnZhbHMgYW5kIHRoZSB0LXN0YXRpc3RpYy4NCg0KKyB0aGUgKipfdF8tc3RhdGlzdGljKiogYW5kIHRoZSBhc3NvY2lhdGVkICoqX3BfLXZhbHVlKiosIHdoaWNoIGRlZmluZXMgdGhlIHN0YXRpc3RpY2FsIHNpZ25pZmljYW5jZSBvZiB0aGUgYmV0YSBjb2VmZmljaWVudHMuDQoNCg0KKioxIC0gdC1zdGF0aXN0aWMgYW5kIHAtdmFsdWVzKiogDQoNCkZvciBhIGdpdmVuIHByZWRpY3RvciwgdGhlIHQtc3RhdGlzdGljIChhbmQgaXRzIGFzc29jaWF0ZWQgKnAqLXZhbHVlKSB0ZXN0cyB3aGV0aGVyIG9yIG5vdCB0aGVyZSBpcyBhIHN0YXRpc3RpY2FsbHkgc2lnbmlmaWNhbnQgcmVsYXRpb25zaGlwIGJldHdlZW4gYSBnaXZlbiBwcmVkaWN0b3IgYW5kIHRoZSBvdXRjb21lIHZhcmlhYmxlLCB0aGF0IGlzIHdoZXRoZXIgb3Igbm90IHRoZSBiZXRhIGNvZWZmaWNpZW50IG9mIHRoZSBwcmVkaWN0b3IgaXMgc2lnbmlmaWNhbnRseSBkaWZmZXJlbnQgZnJvbSB6ZXJvLg0KDQpUaGUgc3RhdGlzdGljYWwgaHlwb3RoZXNlcyBhcmUgYXMgZm9sbG93Og0KDQorIE51bGwgaHlwb3RoZXNpcyAoSH4wfik6IHRoZSBjb2VmZmljaWVudHMgYXJlIGVxdWFsIHRvIHplcm8gKGkuZS4sIG5vIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIHggYW5kIHkpDQorIEFsdGVybmF0aXZlIEh5cG90aGVzaXMgKEh+MX4pOiB0aGUgY29lZmZpY2llbnRzIGFyZSBub3QgZXF1YWwgdG8gemVybyAoaS5lLiwgdGhlcmUgaXMgc29tZSByZWxhdGlvbnNoaXAgYmV0d2VlbiAkeCQgYW5kICR5JCkNCg0KTWF0aGVtYXRpY2FsbHksIGZvciBhIGdpdmVuIGJldGEgY29lZmZpY2llbnQgKCRcYmV0YSQpLCB0aGUgX3RfLXRlc3QgaXMgY29tcHV0ZWQgYXMgJHQgPSAoXGJldGEgLSAwKS9TRShcYmV0YSkkLCB3aGVyZSAkU0UoXGJldGEpJCBpcyB0aGUgU0Ugb2YgdGhlIGNvZWZmaWNpZW50ICRcYmV0YSQuIFNpbXBseSBzYWlkLCB0aGUgdC1zdGF0aXN0aWMgbWVhc3VyZXMgdGhlIG51bWJlciBvZiBzdGFuZGFyZCBkZXZpYXRpb25zIHRoYXQgJFxiZXRhJCBpcyBhd2F5IGZyb20gMC4gVGh1cyBhIGxhcmdlIF90Xy1zdGF0aXN0aWMgd2lsbCBwcm9kdWNlIGEgc21hbGwgcC12YWx1ZSAoPWRpZmZlcmVudCkuDQoNClRoZSBoaWdoZXIgdGhlIF90Xy1zdGF0aXN0aWMgKGFuZCB0aGUgbG93ZXIgdGhlIHAtdmFsdWUpLCB0aGUgbW9yZSBzaWduaWZpY2FudCB0aGUgcHJlZGljdG9yLiBUaGUgc3ltYm9scyB0byB0aGUgcmlnaHQgKCoqKikgdmlzdWFsbHkgc3BlY2lmaWVzIHRoZSBsZXZlbCBvZiBzaWduaWZpY2FuY2UuIFRoZSBsaW5lIGJlbG93IHRoZSB0YWJsZSBzaG93cyB0aGUgZGVmaW5pdGlvbiBvZiB0aGVzZSBzeW1ib2xzOyBvbmUgc3RhciBtZWFucyBwIDwgMC4wNSwgdHdvIHN0YXJzIHAgPCAwLjAxLCB0aHJlZSBzdGFycyBwIDwgMC4wMDEuIFNvIHRoZSBtb3JlIHN0YXJzIGJlc2lkZSB0aGUgdmFyaWFibGXigJlzIHAtdmFsdWUsIHRoZSBtb3JlIHNpZ25pZmljYW50IGlzIHRoZSB2YXJpYWJsZS4NCg0KQSBzdGF0aXN0aWNhbGx5IHNpZ25pZmljYW50IGNvZWZmaWNpZW50IGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIGFuIGFzc29jaWF0aW9uIGJldHdlZW4gdGhlIHByZWRpY3RvciAoJHgkKSBhbmQgdGhlIG91dGNvbWUgKCR5JCkgdmFyaWFibGUuDQoNClRoZSBfdF8tc3RhdGlzdGljIGlzIGEgdmVyeSB1c2VmdWwgZ3VpZGUgZm9yIHdoZXRoZXIgb3Igbm90IHRvIGluY2x1ZGUgYSBwcmVkaWN0b3IgaW4gYSBtb2RlbC4gSGlnaCB0LXN0YXRpc3RpY3MgKHdoaWNoIGdvIHdpdGggbG93IHAtdmFsdWVzIG5lYXIgMCkgaW5kaWNhdGUgdGhhdCBhIHByZWRpY3RvciBzaG91bGQgYmUgcmV0YWluZWQgaW4gYSBtb2RlbCwgd2hpbGUgdmVyeSBsb3cgX3RfLXN0YXRpc3RpY3MgaW5kaWNhdGUgYSBwcmVkaWN0b3IgY291bGQgYmUgZHJvcHBlZCAoQnJ1Y2UgJiBCcnVjZSAyMDE3KS4NCg0KKioyIC0gU3RhbmRhcmQgZXJyb3JzIGFuZCBjb25maWRlbmNlIGludGVydmFscyoqDQoNClRoZSBzdGFuZGFyZCBlcnJvciBtZWFzdXJlcyB0aGUgdmFyaWFiaWxpdHkvYWNjdXJhY3kgb2YgdGhlIGJldGEgY29lZmZpY2llbnRzLiBJdCBjYW4gYmUgdXNlZCB0byBjb21wdXRlIHRoZSBjb25maWRlbmNlIGludGVydmFscyBvZiB0aGUgY29lZmZpY2llbnRzLg0KDQpGb3IgZXhhbXBsZSwgdGhlIDk1JSBjb25maWRlbmNlIGludGVydmFsIGZvciB0aGUgY29lZmZpY2llbnQgJFxiZXRhMSQgaXMgZGVmaW5lZCBhcyAkXGJldGExICsvLSAyKlNFKFxiZXRhMSkkLCB3aGVyZToNCg0KdGhlIGxvd2VyIGxpbWl0cyBvZiAkXGJldGFfMSA9IFxiZXRhXzEgLSAyKlNFKFxiZXRhXzEpID0gIDAuMDQyNDE0IC0gIDIqKDAuMDA1NTkzKSA9IDAuMDMxMjI4JA0KDQp0aGUgdXBwZXIgbGltaXRzIG9mICRcYmV0YTEgPSBcYmV0YTEgKyAyKlNFKFxiZXRhMSkgPSAwLjA0MjQxNCArIDIqKDAuMDA1NTkzKSA9IDAuMDUzNjAwJA0KDQpUaGF0IGlzLCB0aGVyZSBpcyBhcHByb3hpbWF0ZWx5IGEgOTUlIGNoYW5jZSB0aGF0IHRoZSBpbnRlcnZhbCBbMC4wMzEsIDAuMDUzXSB3aWxsIGNvbnRhaW4gdGhlIHRydWUgdmFsdWUgb2YgJFxiZXRhMSQuIFNpbWlsYXJseSB0aGUgOTUlIGNvbmZpZGVuY2UgaW50ZXJ2YWwgZm9yICRcYmV0YTAkIGNhbiBiZSBjb21wdXRlZCBhcyAkXGJldGExICsvLSAyKlNFKFxiZXRhMCkkLg0KDQpUbyBnZXQgdGhpcyBpbmZvcm1hdGlvbiwgZWl0aGVyIHlvdSBjYWxjdWxhdGUgYnkgaGFuZHMgb3IgeW91IHNpbXBseSBjYWxsOg0KDQpgYGB7ciwgIGV2YWw9VCwgd2FybmluZz1GLCBtZXNzYWdlPUZ9DQpjb25maW50KG1vZDFfcGxhbnQpDQpgYGANCg0KIyMjIyBNb2RlbCBhY2N1cmFjeQ0KDQpPbmNlIHlvdSBpZGVudGlmaWVkIHRoYXQsIGF0IGxlYXN0LCBvbmUgcHJlZGljdG9yIHZhcmlhYmxlIGlzIHNpZ25pZmljYW50bHkgYXNzb2NpYXRlZCB0aGUgb3V0Y29tZSwgeW91IHNob3VsZCBjb250aW51ZSB0aGUgZGlhZ25vc3RpYyBieSBjaGVja2luZyBob3cgd2VsbCB0aGUgbW9kZWwgZml0cyB0aGUgZGF0YS4gVGhpcyBwcm9jZXNzIGlzIGFsc28gcmVmZXJyZWQgdG8gYXMgdGhlICpnb29kbmVzcy1vZi1maXQqDQoNClRoZSBvdmVyYWxsIHF1YWxpdHkgb2YgdGhlIGxpbmVhciByZWdyZXNzaW9uIGZpdCBjYW4gYmUgYXNzZXNzZWQgdXNpbmcgdGhlIGZvbGxvd2luZyB0aHJlZSBwYXJhbWV0ZXJzLCBkaXNwbGF5ZWQgaW4gdGhlIG1vZGVsIHN1bW1hcnk6DQoNCjEuICoqVGhlIFJlc2lkdWFsIFN0YW5kYXJkIEVycm9yIChSU0UpKioNCg0KVGhlICoqUlNFKiogKGFsc28ga25vd24gYXMgdGhlIG1vZGVsIHNpZ21hKSBpcyB0aGUgKipyZXNpZHVhbCB2YXJpYXRpb24qKiwgcmVwcmVzZW50aW5nIHRoZSBhdmVyYWdlIHZhcmlhdGlvbiBvZiB0aGUgb2JzZXJ2YXRpb25zIHBvaW50cyBhcm91bmQgdGhlIGZpdHRlZCByZWdyZXNzaW9uIGxpbmUuIFRoaXMgaXMgdGhlICoqc3RhbmRhcmQgZGV2aWF0aW9uIG9mIHJlc2lkdWFsIGVycm9ycyoqLg0KDQpSU0UgcHJvdmlkZXMgYW4gYWJzb2x1dGUgbWVhc3VyZSBvZiBwYXR0ZXJucyBpbiB0aGUgKipkYXRhIHRoYXQgY2Fu4oCZdCBiZSBleHBsYWluZWQgYnkgdGhlIG1vZGVsKiouIFdoZW4gY29tcGFyaW5nIHR3byBtb2RlbHMsIHRoZSBtb2RlbCB3aXRoIHRoZSBzbWFsbCBSU0UgaXMgYSBnb29kIGluZGljYXRpb24gdGhhdCB0aGlzIG1vZGVsIGZpdHMgdGhlIGJlc3QgdGhlIGRhdGEuDQoNCkRpdmlkaW5nIHRoZSBSU0UgYnkgdGhlIGF2ZXJhZ2UgdmFsdWUgb2YgdGhlIG91dGNvbWUgdmFyaWFibGUgd2lsbCBnaXZlIHlvdSB0aGUgcHJlZGljdGlvbiBlcnJvciByYXRlLCB3aGljaCBzaG91bGQgYmUgYXMgc21hbGwgYXMgcG9zc2libGUuDQoNCkluIG91ciBleGFtcGxlLCBSU0UgPSBgMC42ODQ4YCwgbWVhbmluZyB0aGF0IHRoZSBvYnNlcnZlZCBQZXRhbC53aWR0aCB2YWx1ZXMgZGV2aWF0ZSBmcm9tIHRoZSB0cnVlIHJlZ3Jlc3Npb24gbGluZSBieSBhcHByb3hpbWF0ZWx5IGAwLjY4NDhgIHVuaXRzIGluIGF2ZXJhZ2UuDQoNCldoZXRoZXIgb3Igbm90IGFuIFJTRSBvZiBgMC42ODQ4YCB1bml0cyBpcyBhbiBhY2NlcHRhYmxlIHByZWRpY3Rpb24gZXJyb3IgaXMgc3ViamVjdGl2ZSBhbmQgZGVwZW5kcyBvbiB0aGUgcHJvYmxlbSBjb250ZXh0LiANCg0KDQpIb3dldmVyLCB3ZSBjYW4gY2FsY3VsYXRlIHRoZSBwZXJjZW50YWdlIGVycm9yLiBJbiBvdXIgZGF0YSBzZXQsIHRoZSBtZWFuIHZhbHVlIG9mIGBsb2dodGAgaXMgJDAuNDU4MjY3JCwgYW5kIHNvIHRoZSBwZXJjZW50YWdlIGVycm9yIGlzICQwLjY4NDgvMC40NTgyNjdcdGltZXMxMDA9MTQ5JSQuIFRoZXJlIGlzIGluZGVlZCBhIGhpZ2ggdmFyaWF0aW9uLg0KDQpgYGB7ciwgIGV2YWw9VCwgd2FybmluZz1GLCBtZXNzYWdlPUZ9DQpzaWdtYShtb2QxX3BsYW50KSoxMDAvbWVhbihQbGFudF9oZWlnaHQkbG9naHQpDQpgYGANCg0KMi4gKipUaGUgUi1zcXVhcmVkICgkUl4yJCkqKg0KDQpUaGUgKipSLXNxdWFyZWQqKiAkUl4yJCByYW5nZXMgZnJvbSAwIHRvIDEgYW5kIHJlcHJlc2VudHMgdGhlIHByb3BvcnRpb24gb2YgaW5mb3JtYXRpb24gKGkuZS4gdmFyaWFuY2UpIGluIHRoZSByZXNwb25zZSB0aGF0IGlzIGV4cGxhaW5lZCBieSB0aGUgZXhwbGFuYXRvcnkgdmFyaWFibGUocykuIFRoZSAqKmFkanVzdGVkICRSXjIkKiogYWRqdXN0cyAkUl4yJCB3aXRoIHRoZSAqKmRlZ3JlZXMgb2YgZnJlZWRvbSoqLg0KDQpUaGUgJFJeMiQgbWVhc3VyZXMsIGhvdyB3ZWxsIHRoZSBtb2RlbCBmaXRzIHRoZSBkYXRhLiBGb3IgYSBzaW1wbGUgbGluZWFyIHJlZ3Jlc3Npb24sICRSXjIkIGlzIHRoZSBzcXVhcmUgb2YgdGhlICoqUGVhcnNvbiBjb3JyZWxhdGlvbiBjb2VmZmljaWVudCoqLg0KDQpBIGhpZ2ggdmFsdWUgb2YgJFJeMiQgaXMgYSBnb29kIGluZGljYXRpb24uIEhvd2V2ZXIsIGFzIHRoZSB2YWx1ZSBvZiAkUl4yJCB0ZW5kcyB0byBpbmNyZWFzZSB3aGVuIG1vcmUgcHJlZGljdG9ycyBhcmUgYWRkZWQgaW4gdGhlIG1vZGVsLCBzdWNoIGFzIGluICoqbXVsdGlwbGUgbGluZWFyIHJlZ3Jlc3Npb24gbW9kZSoqbCwgeW91IHNob3VsZCBtYWlubHkgY29uc2lkZXIgdGhlIGFkanVzdGVkICRSXjIkLCB3aGljaCBpcyBhIHBlbmFsaXplZCAkUl4yJCBmb3IgYSBoaWdoZXIgbnVtYmVyIG9mIHByZWRpY3RvcnMuDQoNCisgQW4gKGFkanVzdGVkKSAkUl4yJCB0aGF0IGlzIGNsb3NlIHRvIDEgaW5kaWNhdGVzIHRoYXQgYSBsYXJnZSBwcm9wb3J0aW9uIG9mIHRoZSB2YXJpYWJpbGl0eSBpbiB0aGUgb3V0Y29tZSBoYXMgYmVlbiBleHBsYWluZWQgYnkgdGhlIHJlZ3Jlc3Npb24gbW9kZWwuDQoNCisgQSBudW1iZXIgbmVhciAwIGluZGljYXRlcyB0aGF0IHRoZSByZWdyZXNzaW9uIG1vZGVsIGRpZCBub3QgZXhwbGFpbiBtdWNoIG9mIHRoZSB2YXJpYWJpbGl0eSBpbiB0aGUgb3V0Y29tZS4NCg0KMy4gKipGLXN0YXRpc3RpYyoqDQoNClRoZSAqKkYtc3RhdGlzdGljKiogZ2l2ZXMgdGhlIG92ZXJhbGwgc2lnbmlmaWNhbmNlIG9mIHRoZSBtb2RlbC4gSXQgYXNzZXNzIHdoZXRoZXIgKiphdCBsZWFzdCBvbmUgcHJlZGljdG9yIHZhcmlhYmxlIGhhcyBhIG5vbi16ZXJvIGNvZWZmaWNpZW50KiouDQoNCkluIGEgc2ltcGxlIGxpbmVhciByZWdyZXNzaW9uLCB0aGlzIHRlc3QgaXMgbm90IHJlYWxseSBpbnRlcmVzdGluZyBzaW5jZSBpdCBqdXN0IGR1cGxpY2F0ZXMgdGhlIGluZm9ybWF0aW9uIGluIGdpdmVuIGJ5IHRoZSAqdCotdGVzdCwgYXZhaWxhYmxlIGluIHRoZSBjb2VmZmljaWVudCB0YWJsZS4gSW4gZmFjdCwgdGhlICpGKi10ZXN0IGlzIGlkZW50aWNhbCB0byB0aGUgc3F1YXJlIG9mIHRoZSB0LXRlc3Q6ICQ1Ny41ID0gKDcuNTgzKV4yJC4gVGhhdCB3b3VsZCBiZSB0cnVlIGluIGFueSBtb2RlbCB3aXRoIDEgZGVncmVlIG9mIGZyZWVkb20uDQoNClRoZSBGLXN0YXRpc3RpYyBiZWNvbWVzICoqbW9yZSBpbXBvcnRhbnQqKiBvbmNlIHdlIHN0YXJ0ICoqdXNpbmcgbXVsdGlwbGUgcHJlZGljdG9ycyoqIGFzIGluIG11bHRpcGxlIGxpbmVhciByZWdyZXNzaW9uLg0KDQpBIGxhcmdlIEYtc3RhdGlzdGljIHdpbGwgY29ycmVzcG9uZHMgdG8gYSBzdGF0aXN0aWNhbGx5IHNpZ25pZmljYW50ICpwKi12YWx1ZSAocCA8IDAuMDUpLiBJbiBvdXIgZXhhbXBsZSwgdGhlIEYtc3RhdGlzdGljIGVxdWFsICQ1Ny41JCBwcm9kdWNpbmcgYSBwLXZhbHVlIG9mICQxLjg2OGUtMTIkLCB3aGljaCBpcyBoaWdobHkgc2lnbmlmaWNhbnQgKCoqKikuDQoNCg0KIyMjIyBPdGhlciB1c2VmdWwgZnVuY3Rpb25zDQoNCmBgYHtyLCAgZXZhbD1GLCB3YXJuaW5nPUYsIG1lc3NhZ2U9Rn0NCmZpdHRlZChtb2QxX3BsYW50KSAjIHByZWRpY3RlZCB2YWx1ZXMNCnJlc2lkdWFscyhtb2QxX3BsYW50KSAjIHJlc2lkdWFscw0KYW5vdmEobW9kMV9wbGFudCkgIyBhbm92YSB0YWJsZQ0KdmNvdihtb2QxX3BsYW50KSAjIGNvdmFyaWFuY2UgbWF0cml4IGZvciBtb2RlbCBwYXJhbWV0ZXJzDQppbmZsdWVuY2UobW9kMV9wbGFudCkgIyByZWdyZXNzaW9uIGRpYWdub3N0aWNzDQpgYGANCg0KIyMjIE1vZGVsIGFzc3VtcHRpb24NCg0KKipMaW5lYXJpdHkqKiBUaGVyZSBpcyBubyBwb2ludCB0cnlpbmcgdG8gZml0IGEgc3RhaWdodCBsaW5lIHRvIGRhdGEgdGhhdCBhcmUgY3VydmVkISBDdXJ2aWxpbmVhciByZWxhdGlvbnNoaXBzIHByb2R1Y2UgVS1zaGFwZWQgcGF0dGVybnMgaW4gcGxvdHMgb2YgdGhlIHJlc2lkdWFscyB2cyB0aGUgZml0dGVkIHZhbHVlcy4gVXNpbmcgdGhlIHBsb3QgZnVuY3Rpb24gb24gYSBtb2RlbCBvYmplY3QgcHJvdmlkZXMgYSBzZXJpZXMgb2YgZm91ciBncmFwaGljYWwgbW9kZWwgZGlhZ25vc3RpY3MsIHRoZSBmaXJzdCBvZiB3aGljaCBpcyBhIHBsb3Qgb2YgcmVzaWR1YWxzIHZlcnN1cyBmaXR0ZWQgdmFsdWVzLg0KDQpgYGB7cn0NCnBsb3QobW9kMV9wbGFudCwgd2hpY2ggPSAxKQ0KYGBgDQoNClRoZSBhYnNlbmNlIG9mIHN0cm9uZyBwYXR0ZXJuIGluIHRoZSBhYm92ZSBwbG90IGluZGljYXRlcyB0aGUgYXNzdW1wdGlvbiBvZiBsaW5lYXJpdHkgaXMgdmFsaWQuIElmIHRoZXJlIGlzIHN0cm9uZyBwYXR0ZXJuLCBvbmUgcG90ZW50aWFsIHNvbHV0aW9uIGlzIHRvIGxvZy10cmFuc2Zvcm0gdGhlIHJlc3BvbnNlLiBOb3RlIGluIHRoZSBhYm92ZSBleGFtcGxlIHBsYW50IGhlaWdodCBoYWQgYWxyZWFkeSBiZWVuIGxvZy10cmFuc2Zvcm1lZC4gVHJ5IHRvIHJ1biB0aGUgc2FtZSBkaWFnbm9zdGljIG9uIHRoZSB1bnRyYW5zZm9ybWVkIGRhdGEsIHZhcmlhYmxlIGBoZWlnaHRgLg0KDQpDbGljayBbaGVyZV0oaHR0cHM6Ly9nYWxsZXJ5LnNoaW55YXBwcy5pby9zbHJfZGlhZy8pIHRvIHNlZSBhIG5pY2UgaW50ZXJhY3RpdmUgYXBwIHRoYXQgc2hvd3MgeW91IHdoYXQgcGF0dGVybnMgb2YgcmVzaWR1YWxzIHlvdSB3b3VsZCBleHBlY3Qgd2l0aCBjdXJ2ZWQgcmVsYXRpb25zaGlwcw0KDQoqKkNvbnN0YW50IHZhcmlhbmNlKiogQW4gZXZlbiBzcHJlYWQgb2YgZGF0YSBhcm91bmQgdGhlIHJlZ3Jlc3Npb24gbGluZSBpcyBkZXNpcmFibGUuIElmIHRoZSBwbG90IG9mIHJlc2lkdWFscyB2ZXJzdXMgZml0dGVkIHZhbHVlcyBpcyBmYW4tc2hhcGVkIHRoZSBhc3N1bXB0aW9uIG9mIGNvbnN0YW50IHZhcmlhbmNlIChha2EgaG9tb2dlbmVpdHkgb2YgdmFyaWFuY2UpIGlzIHZpb2xhdGVkLiBBIGxvZy10cmFuc2Zvcm1hdGlvbiBvZiB0aGUgcmVzcG9uc2UgdmFyaWFibGUgbWF5IGZpeCB0aGlzIHByb2JsZW0sIGJ1dCBpZiBpdCBkb2VzbuKAmXQgdGhlIGJlc3Qgc29sdXRpb24gaXMgdG8gdXNlIGEgZGlmZmVyZW50IGVycm9yIGRpc3RyaWJ1dGlvbiBpbiBhIGdlbmVyYWxpc2VkIGxpbmVhciBtb2RlbCBmcmFtZXdvcmsgKEdMTSkuDQoNCioqTm9ybWFsaXR5KiogQ2hlY2tzIG9mIHdoZXRoZXIgdGhlIGRhdGEgYXJlIG5vcm1hbGx5IGRpc3RyaWJ1dGVkIGFyZSB1c3VhbGx5IHBlcmZvcm1lZCBieSBlaXRoZXIgcGxvdHRpbmcgYSBoaXN0b2dyYW0gb2YgdGhlIHJlc2lkdWFscyBvciB2aWEgYSBxdWFudGlsZSBwbG90IHdoZXJlIHRoZSByZXNpZHVhbHMgYXJlIHBsb3R0ZWQgYWdhaW5zdCB0aGUgdmFsdWVzIGV4cGVjdGVkIGZyb20gYSBub3JtYWwgZGlzdHJpYnV0aW9uICh0aGUgc2Vjb25kIG9mIHRoZSBmaWd1cmVzIG9idGFpbmVkIGJ5IGBwbG90KG1vZF9wbGFudClgLiBJZiB0aGUgcG9pbnRzIGluIHRoZSBxdWFudGlsZSBwbG90IGxpZSBtb3N0bHkgb24gdGhlIGxpbmUsIHRoZSByZXNpZHVhbHMgYXJlIG5vcm1hbGx5IGRpc3RyaWJ1dGVkLiBWaW9sYXRpb25zIG9mIG5vcm1hbGl0eSBjYW4gYmUgZml4ZWQgdmlhIHRyYW5zZm9ybWF0aW9ucyBvciBieSB1c2luZyBhIGRpZmZlcmVudCBlcnJvci1kaXN0cmlidXRpb24gaW4gYSBHTE0uIE5vdGUsIGhvd2V2ZXIsIHRoYXQgbGluZWFyIHJlZ3Jlc3Npb24gaXMgcmVhc29uYWJseSByb2J1c3QgYWdhaW5zdCB2aW9sYXRpb25zIG9mIG5vcm1hbGl0eS4NCg0KYGBge3J9DQpwYXIobWZyb3cgPSBjKDEsIDIpKSAjIFRoaXMgY29kZSBwdXQgdHdvIHBsb3RzIGluIHRoZSBzYW1lIHdpbmRvdw0KaGlzdChtb2QxX3BsYW50JHJlc2lkdWFscykgIyBIaXN0b2dyYW0gb2YgcmVzaWR1YWxzDQpwbG90KG1vZDFfcGxhbnQsIHdoaWNoID0gMikgIyBRdWFudGlsZSBwbG90DQpgYGANCg0KKipJbmRlcGVuZGVuY2UqKiBUaGUgb2JzZXJ2YXRpb25zIG9mIHRoZSByZXNwb25zZSBzaG91bGQgYmUgaW5kZXBlbmRlbnQgb2YgZWFjaCBvdGhlci4gTm9uLWluZGVwZW5kZW50IG9ic2VydmF0aW9ucyBhcmUgdGhvc2UgdGhhdCBhcmUgaW4gc29tZSB3YXkgYXNzb2NpYXRlZCB3aXRoIGVhY2ggb3RoZXIgYmV5b25kIHRoYXQgd2hpY2ggaXMgZXhwbGFpbmVkIGJ5IHRoZSBwcmVkaWN0b3IgdmFyaWFibGUocykuIEZvciBpbnN0YW5jZSwgc2FtcGxlcyBjb2xsZWN0ZWQgZnJvbSB0aGUgc2FtZSBzaXRlLCBvciByZXBlYXRlZGx5IGZyb20gdGhlIHNhbWUgb2JqZWN0LCBtYXkgYmUgbW9yZSBhbGlrZSBkdWUgdG8gc29tZSBhZGRpdGlvbmFsIGZhY3RvciBvdGhlciB0aGFuIHRoZSBtZWFzdXJlZCBleHBsYW5hdG9yeSB2YXJpYWJsZS4gRW5zdXJpbmcgaW5kZXBlbmRlbmNlIGlzIGFuIGlzc3VlIG9mIGV4cGVyaW1lbnRhbCBhbmQgc2FtcGxpbmcgZGVzaWduIGFuZCB3ZSB1c3VhbGx5IGtub3cgaWYgdGhlIGRhdGEgYXJlIGluZGVwZW5kZW50IG9yIG5vdCBpbiBhZHZhbmNlIG9mIG91ciBhbmFseXNpcy4NCg0KVGhlcmUgYXJlIGEgdmFyaWV0eSBvZiBtZWFzdXJlcyBmb3IgZGVhbGluZyB3aXRoIG5vbi1pbmRlcGVuZGVuY2UuIFRoZXNlIGluY2x1ZGUgZW5zdXJpbmcgYWxsIGltcG9ydGFudCBwcmVkaWN0b3JzIGFyZSBpbiB0aGUgbW9kZWw7IGF2ZXJhZ2luZyBhY3Jvc3MgbmVzdGVkIG9ic2VydmF0aW9uczsgb3IgdXNpbmcgYSBtaXhlZC1tb2RlbC4NCg0KDQoNCkJhc2VkIG9uIFBlw7FhICYgU2xhdGUgKDIwMDYpLCB0aGUgZm91ciBhc3N1bXB0aW9ucyBpbiBsaW5lYXIgcmVncmVzc2lvbiBhcmUgbm9ybWFsaXR5LCBoZXRlcm9zY2VkYXN0aWNpdHksIGFuZCBsaW5lYXJpdHksIGFuZCB3aGF0IHRoZSBhdXRob3JzIHJlZmVyIHRvIGFzIHVuY29ycmVsYXRlZG5lc3MuIFRoZSBgZ3ZsbWEoIClgIGZ1bmN0aW9uIGluIHRoZSBgZ3ZsbWFgIHBhY2thZ2UsIHBlcmZvcm1zIGEgZ2xvYmFsIHZhbGlkYXRpb24gb2YgbGluZWFyIG1vZGVsIGFzc3VtcHRpb25zIGFzIHdlbGwgc2VwYXJhdGUgZXZhbHVhdGlvbnMgb2Ygc2tld25lc3MsIGt1cnRvc2lzLCBhbmQgaGV0ZXJvc2NlZGFzdGljaXR5Lg0KDQpgYGB7ciwgIGV2YWw9VCwgd2FybmluZz1GLCBtZXNzYWdlPUZ9DQpndm1vZGVsIDwtIGd2bG1hKG1vZDFfcGxhbnQpDQpzdW1tYXJ5KGd2bW9kZWwpDQpgYGANCiANCiMjIFR3byAob3IgbW9yZSkgcHJlZGljdG9ycw0KDQoqKk11bHRpcGxlIGxpbmVhciByZWdyZXNzaW9uKiogaXMganVzdCBhbiAqKmV4dGVuc2lvbiBvZiBzaW1wbGUgbGluZWFyIHJlZ3Jlc3Npb24qKiB1c2VkIHRvIHByZWRpY3QgYW4gb3V0Y29tZSB2YXJpYWJsZSAoJHkkKSBvbiB0aGUgYmFzaXMgb2YgbXVsdGlwbGUgZGlzdGluY3QgcHJlZGljdG9yIHZhcmlhYmxlcyAoJHgkKS4NCg0KV2l0aCB0aHJlZSBwcmVkaWN0b3IgdmFyaWFibGVzICgkeCQpLCB0aGUgcHJlZGljdGlvbiBvZiAkeSQgaXMgZXhwcmVzc2VkIGJ5IHRoZSBmb2xsb3dpbmcgZXF1YXRpb246DQoNCiQkeSA9IFxiZXRhXzAgKyBcYmV0YV8xKnhfMSArIFxiZXRhXzIqeF8yICsgXGJldGFfMyp4XzMkJA0KVGhlICRcYmV0YSQgdmFsdWVzIG1lYXN1cmUgdGhlIGFzc29jaWF0aW9uIGJldHdlZW4gdGhlIHByZWRpY3RvciB2YXJpYWJsZSBhbmQgdGhlIG91dGNvbWUuIOKAnCRcYmV0YV9qJOKAnSBjYW4gYmUgaW50ZXJwcmV0ZWQgYXMgdGhlIGF2ZXJhZ2UgZWZmZWN0IG9uICR5JCBvZiBhIG9uZSB1bml0IGluY3JlYXNlIGluICR4X2okLCBob2xkaW5nIGFsbCBvdGhlciBwcmVkaWN0b3JzIGZpeGVkLg0KDQokbG9naHQgPSBcYmV0YV8wICsgXGJldGFfMSAqIHRlbXAgICsgXGJldGFfMiAqIGFsdCArIFxiZXRhXzMgKiByYWluJCANCg0Kb3IgDQoNCmBgYHtyfQ0KbW9kMl9wbGFudDwtIGxtKGxvZ2h0IH4gdGVtcCArIGFsdCArIHJhaW4sIGRhdGEgPSBQbGFudF9oZWlnaHQpDQpgYGANCg0KQSBjb21tb24gcHJvYmxlbSB0aGF0IGFyaXNlcyBpbiBtdWx0aXBsZSBsaW5lYXIgcmVncmVzc2lvbiBpcyB0aGUgKiptdWx0aS1jb2xsaW5lYXJpdHkqKi4gVGhpcyBpcyB0aGUgc2l0dWF0aW9uIHdoZW4gdHdvIG9yIG1vcmUgcHJlZGljdG9ycyBhcmUgaGlnaGx5IGxpbmVhcmx5IHJlbGF0ZWQgYmV0d2VlbiB0aGVtLiBNdWx0aWNvbGxpbmVhcml0aXkgaGFzIGltcG9ydGFudCBlZmZlY3RzIG9uIHRoZSBmaXQgb2YgdGhlIG1vZGVsOg0KDQorIEl0IHJlZHVjZXMgdGhlIHByZWNpc2lvbiBvZiB0aGUgZXN0aW1hdGVzLiBBcyBhIGNvbnNlcXVlbmNlLCBzaWducyBvZiBmaXR0ZWQgY29lZmZpY2llbnRzIG1heSBiZSByZXZlcnNlZCBhbmQgdmFsdWFibGUgcHJlZGljdG9ycyBtYXkgYXBwZWFyIGFzIG5vbiBzaWduaWZpY2FudC4NCg0KKyBJdCBpcyBkaWZmaWN1bHQgdG8gZGV0ZXJtaW5lIGhvdyBlYWNoIG9mIHRoZSBoaWdobHkgcmVsYXRlZCBwcmVkaWN0b3JzIGFmZmVjdHMgdGhlIHJlc3BvbnNlLCBzaW5jZSBvbmUgbWFza3MgdGhlIG90aGVyLiBUaGlzIG1heSByZXN1bHQgaW4gbnVtZXJpY2FsIGluc3RhYmlsaXRpZXMuDQoNCkFuIGFwcHJvYWNoIGlzIHRvIGRldGVjdCBtdWx0aWNvbGxpbmVhcml0eSBpcyB0byBjb21wdXRlIGEgY29ycmVsYXRpb24gbWF0cml4IGJldHdlZW4gdGhlIHByZWRpY3RvcnMgYXMgd2UgbGVhcm5lZCBlYXJsaWVyDQoNCg0KYGBge3IsICBldmFsPVQsIHdhcm5pbmc9RiwgbWVzc2FnZT1GfQ0KDQpwbGFudF9wcmVkaWN0b3I8LWRhdGEuZnJhbWUoUGxhbnRfaGVpZ2h0JHRlbXAsUGxhbnRfaGVpZ2h0JGFsdCxQbGFudF9oZWlnaHQkcmFpbikNCmNvcnI8LWNvcihwbGFudF9wcmVkaWN0b3IpDQpwLnZhbDwtcmNvcnIoYXMubWF0cml4KHBsYW50X3ByZWRpY3RvcikpJFANCmNvcnJwbG90KGNvcnIsdHlwZT0ndXBwZXInLG1ldGhvZD0nY29sb3InLCBhZGRDb2VmLmNvbCA9ICJibGFjayIsICBwLm1hdD1hcy5tYXRyaXgocC52YWwpLCBzaWcubGV2ZWwgPSAwLjA1LGRpYWc9RikNCmBgYA0KDQpIZXJlIHdlIGNhbiBzZWUgdGhlcmUgaXMgYSBzaWduaWZpY2FudCBjb3JyZWxhdGlvbiBiZXR3ZWVuIHRoZSBwcmVkaWN0b3JzLiBBIGJldHRlciBhcHByb2FjaCBpcyB0byBjb21wdXRlIHRoZSAqKlZhcmlhbmNlIEluZmxhdGlvbiBGYWN0b3IqKiAoVklGKSBvZiBlYWNoIGNvZWZmaWNpZW50ICRcYmV0YV9qJC4gVGhpcyBpcyBtZWFzdXJlIG9mIGhvdyBsaW5lYXJseSBkZXBlbmRlbnQgaXMgJFhfaiQgd2l0aCB0aGUgcmVzdCBvZiBwcmVkaWN0b3JzOg0KDQoNCiQkXHRleHR7VklGfShcYmV0YV9qKT1cZnJhY3sxfXsxLVJeMl97WF9qfFhfey1qfX19JCQNCndoZXJlICRSXjJfe1hfanxYX3stan19JCBpcyB0aGUgJFJeMiQgZnJvbSBhIHJlZ3Jlc3Npb24gb2YgJFhfaiQgaW50byB0aGUgcmVtYWluaW5nIHByZWRpY3RvcnMuIFRoZSBuZXh0IHJ1bGUgb2YgdGh1bWIgZ2l2ZXMgZGlyZWN0IGluc2lnaHQgaW50byB3aGljaCBwcmVkaWN0b3JzIGFyZSBtdWx0aWNvbGxpbmVhcjoNCg0KICsgKipWSUYgY2xvc2UgdG8gMSoqOiBhYnNlbmNlIG9mIG11bHRpY29sbGluZWFyaXR5Lg0KICsgKipWSUYgbGFyZ2VyIHRoYW4gNSBvciAxMCoqOiBtdWx0aWNvbGluZWFyaXR5ICoqcHJvYmxlbWF0aWMqKi4gIA0KIA0KT3RoZXJzIGNvbnNpZGVyZWQgJFxzcXJ0e1ZJRn0+MiQgYXMgY3JpdGljYWwgbGltaXQgdG8gY29uc2lkZXIgbXVsdGljb2xsaW5lYXJpdHkuDQoNCg0KYGBge3IsICBldmFsPVQsIHdhcm5pbmc9RiwgbWVzc2FnZT1GQUxTRX0NCiMgRXZhbHVhdGUgQ29sbGluZWFyaXR5DQpjYXI6OnZpZihtb2QyX3BsYW50KSAjIHZhcmlhbmNlIGluZmxhdGlvbiBmYWN0b3JzDQpzcXJ0KGNhcjo6dmlmKG1vZDJfcGxhbnQpKSA+IDIgIyBwcm9ibGVtPw0KYGBgDQpOb25lIG9mIHRoZSBwcmVkaWN0b3JzIHNlZW0gcHJvYmxlbWF0aWMgaGVyZS4NCg0KYGBge3J9DQpzdW1tYXJ5KG1vZDJfcGxhbnQpDQpwYXIobWZyb3cgPSBjKDIsIDIpKQ0KcGxvdChtb2QyX3BsYW50KQ0KDQpgYGANCg0KDQojIyBNb2RlbCBzZWxlY3Rpb24NCg0KSWYgeW91IGFpbSBpcyB0byBwcmVkaWN0IHlvdSBhcmUgbG9va2luZyBmb3IgdGhlIGJlc3QgbW9kZWwuIEFuIGluZm9ybWF0aW9uIGNyaXRlcmlvbiBiYWxhbmNlcyB0aGUgZml0bmVzcyBvZiBhIG1vZGVsIHdpdGggdGhlIG51bWJlciBvZiBwcmVkaWN0b3JzIGVtcGxveWVkLiBIZW5jZSwgaXQgZGV0ZXJtaW5lcyBvYmplY3RpdmVseSB0aGUgYmVzdCBtb2RlbCBhcyB0aGUgb25lIHRoYXQgbWluaW1pemVzIHRoZSBpbmZvcm1hdGlvbiBjcml0ZXJpb24uIFR3byBjb21tb24gY3JpdGVyaWEgYXJlIHRoZSAqKkJheWVzaWFuIEluZm9ybWF0aW9uIENyaXRlcmlvbiAoQklDKSoqIGFuZCB0aGUgKipBa2Fpa2UgSW5mb3JtYXRpb24gQ3JpdGVyaW9uIChBSUMpKiouIA0KDQokQUlDKG1vZGVsKT0tMipsb2dMaWsobW9kZWwpICsgbnBhcihtb2RlbCkgKiAyJA0KDQokQklDKG1vZGVsKT0tMipsb2dMaWsobW9kZWwpICsgbnBhcihtb2RlbCkgKiBsb2cobikkDQoNCg0Kd2hlcmUgJExpayhtb2RlbCkkICBpcyB0aGUgbGlrZWxpaG9vZCBvZiB0aGUgbW9kZWwgKGhvdyB3ZWxsIHRoZSBtb2RlbCBmaXRzIHRoZSBkYXRhKSBhbmQgJG5wYXIobW9kZWwpJCBpcyB0aGUgbnVtYmVyIG9mIHBhcmFtZXRlcnMgb2YgdGhlIG1vZGVsLCAkaysyJCBpbiB0aGUgY2FzZSBvZiBhIG11bHRpcGxlIGxpbmVhciByZWdyZXNzaW9uIG1vZGVsIHdpdGggJGskIHByZWRpY3RvcnMuVGhlIEFJQyByZXBsYWNlcyAkbG9nKG4pJCBieSAkMiQsIHNvIGl0IHBlbmFsaXplcyBsZXNzIGNvbXBsZXggbW9kZWxzLlRoaXMgaXMgb25lIG9mIHRoZSByZWFzb25zIHdoeSBCSUMgaXMgcHJlZmVycmVkIGJ5IHNvbWUgcHJhY3RpdGlvbmVycyBmb3IgbW9kZWwgY29tcGFyaXNvbi4gQWxzbywgYmVjYXVzZSBpcyBjb25zaXN0ZW50IGluIHNlbGVjdGluZyB0aGUgdHJ1ZSBtb2RlbDogaWYgZW5vdWdoIGRhdGEgaXMgcHJvdmlkZWQsIHRoZSBCSUMgaXMgZ3VhcmFudGVlZCB0byBzZWxlY3QgdGhlIGRhdGEtZ2VuZXJhdGluZyBtb2RlbCBhbW9uZyBhIGxpc3Qgb2YgY2FuZGlkYXRlIG1vZGVscy4NCg0KQm90aCBhcmUgYmFzZWQgb24gYSAqKmJhbGFuY2UgYmV0d2VlbiB0aGUgbW9kZWwgZml0bmVzcyBhbmQgaXRzIGNvbXBsZXhpdHkqKi5Cb3RoIEJJQyBhbmQgQUlDIGNhbiBiZSBjb21wdXRlZCBpbiBgUmAgdGhyb3VnaCB0aGUgZnVuY3Rpb25zIGBCSUNgIGFuZCBgQUlDYC4gVGhleSB0YWtlIGEgbW9kZWwgYXMgdGhlIGlucHV0LiBUaGUgbG93ZXIgdGhlIGJldHRlciB3aXRoIGEgcnVsZSBvZiB0aHVtYiA9IDIuIA0KDQpOb3RlOiBEbyB5b3UgcmVtZW1iZXIgYWJvdXQgYHNpZ21hYCAodGhlIFJlc2lkdWFsIFN0YW5kYXJkIEVycm9yLCBSU0UpPyBXZSBwcmV2aW91c2x5IHVzZWQgaXQgdG8gY2FsY3VsYXRlIGEgcGVjcmNlbnRhZ2UgZXJyb3IuIFdlbGwsIEFJQyBhbmQgQklDIHVzZWQgdGhlIGxvZyBsaWtlbGlob29kIG9mIHRoZSBtb2RlbCBvYnRhaW4gdXNpbmcgYGxvZ0xpayAobW9kZWwpYC4gWW91IGNhbiByZWNhbGN1bGF0ZSB0aGlzIGxvZ0xpayB1c2luZzogYHN1bShsb2coZG5vcm0oeCA9IHksIG1lYW4gPSBwcmVkaWN0KG1vZGVsKSwgc2QgPSBzaWdtYShtb2RlbCkpKSlgIHdoaWNoIGlsbHVzdHJhdGUgIHRoZSBjb25uZWN0aW9uIGJldHdlZW4gYHNpZ21hYGFuZCBpbmZvcm1hdGlvbiBjcml0ZXJpb24uDQoNCg0KYGBge3IsICBldmFsPVQsIHdhcm5pbmc9RiwgbWVzc2FnZT1GfQ0KbW9kM19wbGFudDwtbG0oZm9ybXVsYSA9IGxvZ2h0IH4gdGVtcCArIHJhaW4sIGRhdGEgPSBQbGFudF9oZWlnaHQpDQpCSUMobW9kMV9wbGFudCk7IEJJQyhtb2QyX3BsYW50KTsgQklDKG1vZDNfcGxhbnQpDQpBSUMobW9kMV9wbGFudCk7IEFJQyhtb2QyX3BsYW50KTsgQUlDKG1vZDNfcGxhbnQpDQpgYGANCg0KSG93ZXZlciwgc2VsZWN0aW5nIGEgc3Vic2V0IG9mIHByZWRpY3RvciB2YXJpYWJsZXMgZnJvbSBhIGxhcmdlciBzZXQgKGUuZy4sIHN0ZXB3aXNlIHNlbGVjdGlvbikgcmVtYWlucyBhIGNvbnRyb3ZlcnNpYWwgdG9waWMuIFlvdSBjYW4gcGVyZm9ybSBzdGVwd2lzZSBzZWxlY3Rpb24gKGZvcndhcmQsIGJhY2t3YXJkLCBib3RoKSB1c2luZyB0aGUgYHN0ZXBBSUMoKWAgYW5kIGBzdGVwQklDKClgIGZ1bmN0aW9uIGZyb20gdGhlIGBNQVNTYCBwYWNrYWdlLiBgc3RlcEFJQygpYCBwZXJmb3JtcyBzdGVwd2lzZSBtb2RlbCBzZWxlY3Rpb24gYnkgZXhhY3QgQUlDLg0KDQo+ICpTb3VyY2U6IEFsaXN0YWlyIFBvb3JlLCBBbmRyZXcgTGV0dGVuLCBHb3JkYW5hIFBvcG92aWMqDQoNCg0KIyBBTk9WQQ0KDQoNCg0KQW5hbHlzaXMgb2YgdmFyaWFuY2UgKEFOT1ZBKSBpcyBvbmUgb2YgdGhlIG1vc3QgZnJlcXVlbnRseSB1c2VkIHRlY2huaXF1ZXMgaW4gdGhlIGJpb2xvZ2ljYWwgYW5kIGVudmlyb25tZW50YWwgc2NpZW5jZXMuIEFOT1ZBIGlzIHVzZWQgdG8gY29udHJhc3QgYSBjb250aW51b3VzIGRlcGVuZGVudCB2YXJpYWJsZSAkeSQgYWNyb3NzIGxldmVscyBvZiBvbmUgb3IgbW9yZSBjYXRlZ29yaWNhbCBpbmRlcGVuZGVudCB2YXJpYWJsZXMgJHgkLiBUaGUgaW5kZXBlbmRlbnQgdmFyaWFibGVzIGFyZSB0ZXJtZWQgdGhlICoqZmFjdG9yKiogb3IgKioqKnRyZWF0bWVudCwgYW5kIHRoZSB2YXJpb3VzIGNhdGVnb3JpZXMgd2l0aGluIHRoYXQgdHJlYXRtZW50IGFyZSB0ZXJtZWQgdGhlICoqbGV2ZWxzKiouIFdlIHdpbGwgc3RhcnQgd2l0aCB0aGUgc2ltcGxlc3QgZGVzaWduIC0gdGhvc2UgQU5PVkEgd2l0aCBhIHNpbmdsZSBmYWN0b3IuDQoNCldoZXJlIGFuIGluZGVwZW5kZW50IHNhbXBsZXMgdC10ZXN0IHdvdWxkIGJlIHVzZWQgZm9yIGNvbXBhcmlzb24gb2YgZ3JvdXAgbWVhbnMgYWNyb3NzIHR3byBsZXZlbHMsIEFOT1ZBIGlzIHVzZWQgZm9yIHRoZSBjb21wYXJpc29uIG9mID4yIGdyb3VwIG1lYW5zLCBvciB3aGVuIHRoZXJlIGFyZSBtb3JlIHRoYW4gdHdvIG9yIG1vcmUgcHJlZGljdG9yIHZhcmlhYmxlcy4gVGhlIGxvZ2ljIG9mIHRoaXMgdGVzdCBpcyBlc3NlbnRpYWxseSB0aGUgc2FtZSBhcyB0aGUgdC10ZXN0IC0gaXQgY29tcGFyZXMgdmFyaWF0aW9uIGJldHdlZW4gZ3JvdXBzIHRvIHZhcmlhdGlvbiB3aXRoaW4gZ3JvdXBzIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBvYnNlcnZlZCBkaWZmZXJlbmNlcyBhcmUgZHVlIHRvIGNoYW5jZSBvciBub3QuDQoNCg0KIyMgT25lLXdheSBBTk9WQQ0KDQpBbHNvIGNhbGxlZCBzaW5nbGUgZmFjdG9yIEFOT1ZBLg0KDQpGb3IgZXhhbXBsZSwgdG8gY29tcGFyZSB0aGUgaGF0Y2hpbmcgdGltZXMgb2YgdHVydGxlIGVnZ3MgaW5jdWJhdGVkIGF0IGZvdXIgZGlmZmVyZW50IHRlbXBlcmF0dXJlcyAoMTXCsEMsIDIwwrBDLCAyNcKwQyBhbmQgMzDCsEMpOyBoYXRjaGluZyB0aW1lIGlzIHRoZSBjb250aW51b3VzIHJlc3BvbnNlIHZhcmlhYmxlIGFuZCB0ZW1wZXJhdHVyZSBpcyB0aGUgY2F0ZWdvcmljYWwgcHJlZGljdG9yIHZhcmlhYmxlIHdpdGggd2l0aCBmb3VyIGxldmVscy4gVGhlIG51bGwgaHlwb3RoZXNpcyB3b3VsZCBiZSB0aGF0IG1lYW4gaGF0Y2hpbmcgdGltZSBpcyBlcXVhbCBmb3IgYWxsIHRlbXBlcmF0dXJlcy4NCg0KJEhfMDogXG11X3sxNX09XG11X3syMH09XG11X3syNX09XG11X3szMH0kDQoNCk5vdGUgdGhhdCBhbiAqKkFOT1ZBIGlzIGEgbGluZWFyIG1vZGVsKiosIGp1c3QgbGlrZSBsaW5lYXIgcmVncmVzc2lvbiBleGNlcHQgdGhhdCB0aGUgcHJlZGljdG9yIHZhcmlhYmxlcyBhcmUgY2F0ZWdvcmljYWwgcmF0aGVyIHRoYW4gY29udGludW91cy4NCg0KJHlfe2lqfT1cbXUgKyBcYmV0YV9pICsgXGVwc2lsb25fe2lqfSQNCg0Kd2hlcmUgJFxtdSQgaXMgdGhlIG92ZXJhbGwgbWVhbiBhbmQgJFxiZXRhX2kkIGlzIHRoZSBlZmZlY3Qgb2YgdGhlICRpXnt0aH0kIGdyb3VwLg0KDQoNCkl0IGlzIHRoZSBzYW1lIGFzIGEgbXVsdGlwbGUgbGluZWFyIHJlZ3Jlc3Npb24gd2l0aCBhIHByZWRpY3RvciB2YXJpYWJsZSBmb3IgZWFjaCBsZXZlbCBvZiB0aGUgY2F0ZWdvcmljYWwgdmFyaWFibGUgKGVhY2ggY29kZWQgYXMgYSBkdW1teSB2YXJpYWJsZSkuIEZvciB0aGUgcXVlc3Rpb24gb2Ygd2hldGhlciBoYXRjaGluZyB0aW1lIG9mIHR1cnRsZXMgZGlmZmVycyBiZXR3ZWVuIGZvdXIgaW5jdWJhdGlvbiB0ZW1wZWF0dXJlcywgd2UgbXVzdCBmaXQgZm91ciBwYXJhbWV0ZXJzIHRvIGRlc2NyaWJlIHRoZSBtZWFuIHJlc3BvbnNlIG9mIGVhY2ggdGVtcGVyYXR1cmUgKHJhdGhlciB0aGFuIGp1c3QgYSBzaW5nbGUgaW50ZXJjZXB0IGFuZCBzaW5nbGUgc2xvcGUgaW4gYSBzaW1wbGUgbGluZWFyIHJlZ3Jlc3Npb24pLiBGb3IgdGhpcyBleGFtcGxlLCBvdXIgbGluZWFyIG1vZGVsIGVxdWF0aW9uIHdpbGwgaGF2ZSB0aGlzIGZvcm06DQoNCiRIYXRjaGluZ1RpbWU9XG11K1xiZXRhXzEuVGVtcF97MTV9K1xiZXRhXzEuVGVtcF97MjB9K1xiZXRhXzEuVGVtcF97MjV9K1xiZXRhXzEuVGVtcF97MzB9K1xlcHNpbG9uJA0KDQpBTk9WQSBwYXJ0aXRpb25zIHRoZSB0b3RhbCB2YXJpYW5jZSBpbnRvIGEgY29tcG9uZW50IHRoYXQgY2FuIGJlIGV4cGxhaW5lZCBieSB0aGUgcHJlZGljdG9yIHZhcmlhYmxlIChhbW9uZyBsZXZlbHMgb2YgdGhlIHRyZWF0bWVudCksIGFuZCBhIGNvbXBvbmVudCB0aGF0IGNhbm5vdCBiZSBleHBsYWluZWQgKHdpdGhpbiBsZXZlbHMsIHRoZSByZXNpZHVhbCB2YXJpYW5jZSkuIFRoZSB0ZXN0IHN0YXRpc3RpYywgRiwgaXMgdGhlIHJhdGlvIG9mIHRoZXNlIHR3byBzb3VyY2VzIG9mIHZhcmlhdGlvbi4NCg0KJEY9XGZyYWN7TVNfe2Ftb25nfX17TVNfe3dpdGhpbn19JA0KDQp3aGVyZSBNUyBhcmUgdGhlIG1lYW4gc3F1YXJlcywgYSBtZWFzdXJlIG9mIHZhcmlhdGlvbi4gVGhlIHByb2JhYmlsaXR5IG9mIG9idGFpbmluZyB0aGUgb2JzZXJ2ZWQgdmFsdWUgb2YgRiBpcyBjYWxjdWxhdGVkIGZyb20gdGhlIGtub3duIHByb2JhYmlsaXR5IGRpc3RyaWJ1dGlvbiBvZiBGLCB3aXRoIHR3byBkZWdyZWVzIG9mIGZyZWVkb20gKG9uZSBmb3IgdGhlIG51bWVyYXRvciA9IHRoZSBudW1iZXIgb2YgbGV2ZWxzIC0xKSBhbmQgb25lIGZvciB0aGUgZGVub21pbmF0b3IgKG51bWJlciBvZiByZXBsaWNhdGVzIHBlciBsZXZlbCAtIDEgeCBudW1iZXIgb2YgbGV2ZWxzKS4NCg0KIyMjIFJ1bm5pbmcgdGhlIGFuYWx5c2lzDQoNClRoZSBkYXRhIHNob3VsZCBiZSBmb3JtYXR0ZWQgc3VjaCB0aGF0IHRoZSBpbmRpdmlkdWFsIHJlcGxpY2F0ZXMgYXJlIHJvd3MgYW5kIHRoZSB2YXJpYWJsZXMgYXJlIHNlcGFyYXRlIGluIGNvbHVtbnMuIEluY2x1ZGUgYSBjb2x1bW4gZm9yIHRoZSBkZXBlbmRlbnQgdmFyaWFibGUsICR5JCwgYW5kIGEgY29ycmVzcG9uZGluZyBjb2x1bW4gZm9yIHRoZSBjYXRlZ29yaWNhbCB2YXJpYWJsZSwgJHgkLiBEb3dubG9hZCB0aGUgc2FtcGxlIGRhdGEgc2V0IGZvciB0aGUgdHVydGxlIGhhdGNoaW5nIGV4YW1wbGUsIGB0dXJ0bGVzLmNzdmAsIGltcG9ydCBpbnRvIFIgYW5kIGNoZWNrIHRoYXQgdGVtcGVyYXR1cmUgdmFyaWFibGUgaXMgYSBmYWN0b3Igd2l0aCB0aGUgYHN0cmAgZnVuY3Rpb24uDQoNCmBgYHtyfQ0KdHVydGxlcyA8LSByZWFkLmNzdihmaWxlID0gImRhdGEvdHVydGxlcy5jc3YiLCBoZWFkZXIgPSBUUlVFKQ0Kc3RyKHR1cnRsZXMpDQpgYGANCg0KSW4gdGhpcyBjYXNlLCBiZWNhdXNlIHdlIGhhdmUgbnVtYmVycyBmb3IgdGhlIGZvdXIgbGV2ZWxzIG9mIHRoZSBUZW1wZXJhdHVyZSB0cmVhdG1lbnQsIHdlIG5lZWQgdG8gY2hhbmdlIHRoYXQgdmFyaWFibGUgdG8gYmVjb21lIGEgZmFjdG9yIHJhdGhlciB0aGFuIGFuIGludGVnZXIuDQoNCmBgYHtyfQ0KdHVydGxlcyRUZW1wZXJhdHVyZSA8LSBmYWN0b3IodHVydGxlcyRUZW1wZXJhdHVyZSkNCmJveHBsb3QoRGF5cyB+IFRlbXBlcmF0dXJlLCBkYXRhID0gdHVydGxlcywgeWxhYiA9ICJIYXRjaGluZyB0aW1lIChkYXlzKSIsIHhsYWIgPSAiVGVtcGVyYXR1cmUgKEMpIikNCmBgYA0KDQpOb3csIHdlIGNhbiBydW4gdGhlIGFuYWx5c2lzIG9mIHZhcmlhbmNlIGNvbnRyYXN0aW5nIGhhdGNoaW5nIHRpbWUgKGRheXMpIGFjcm9zcyB0ZW1wZXJhdHVyZXMgdXNpbmcgdGhlIGZ1bmN0aW9uIGBhb3ZgLiBUaGUgYXJndW1lbnRzIG9mIHRoZSBmdW5jdGlvbiBhcmUgc2ltcGx5IGEgZm9ybXVsYSBzdGF0ZW1lbnQsIGB5fnhgLCB3aXRoIHRoZSByZXNwb25zZSB2YXJpYWJsZSB0byB0aGUgbGVmdCBvZiB0aGUgYH5gLCB0aGUgcHJlZGljdG9yIHZhcmlhYmxlIHRvIHRoZSByaWdodCwgYW5kIHNvbWUgY29kZSB0byBzcGVjaWZ5IHdoaWNoIGRhdGEgZnJhbWUgaG9sZHMgdGhvc2UgdmFyaWFibGVzLg0KDQpgYGB7cn0NCnR1cnRsZXMuYW92IDwtIGFvdihEYXlzIH4gVGVtcGVyYXR1cmUsIGRhdGEgPSB0dXJ0bGVzKQ0Kc3VtbWFyeSh0dXJ0bGVzLmFvdikNCmBgYA0KDQpDaGVjayBidXQgdGhlIHNhbWUgY2FuIGJlIHByb2R1Y2VkIGJ5IHBhc3NpbmcgYSBgbG1gIGluIGBhbm92YSgpYC4gQW4gQU5PVkEgaXMgc2ltcGx5IGFub3RoZXIgd2F5IHRvIHN1bW1hcml6ZSB0aGUgcmVzdWx0cyBvZiBhIGBsbWAsIGVzcGVjaWFsbHkgdXNlZnVsIGluIGNhc2Ugb2YgY2F0ZWdvcmljYWwgdmFyaWFibGVzLiANCg0KYGBge3J9DQp0dXJ0bGVzLmxtIDwtIGxtKERheXMgfiBUZW1wZXJhdHVyZSwgZGF0YSA9IHR1cnRsZXMpDQphbm92YSh0dXJ0bGVzLmxtKSANCmBgYA0KVGhlIHN1bW1hcnkgb3V0cHV0IG9mIGFuIEFOT1ZBIG9iamVjdCBpcyBhIHRhYmxlIHdpdGggdGhlIGRlZ3JlZXMgb2YgZnJlZWRvbSAoRGYpLCBzdW1zIG9mIHNxdWFyZXMgKFN1bSBTcSksIG1lYW4gc3F1YXJlcyAoTWVhbiBTcSkgZm9yIHRoZSBwcmVkaWN0b3IgdmFyaWFibGUgKGkuZS4sIHZhcmlhdGlvbiBhbW9uZyBsZXZlbHMgb2YgeW91ciB0cmVhdG1lbnQpIGFuZCBmb3IgdGhlIFJlc2lkdWFscyAoaS5lLiwgdmFyYXRpb24gd2l0aGluIHRoZSBsZXZlbHMpLiBUaGUgdGVzdCBzdGF0aXN0aWMsICRGJCB2YWx1ZSBhbmQgaXRzIGFzc29jaWF0ZWQgcC12YWx1ZSAoUHIoPkYpKSBhcmUgYWxzbyBwcmVzZW50ZWQuDQoNCkZpcnN0IGNoZWNrIHRoZSBkZWdyZWVzIG9mIGZyZWVkb20uIFRoZSBmYWN0b3IgRGYgPSB0aGUgbnVtYmVyIG9mIGxldmVscyBvZiB5b3VyIGZhY3RvciAtIDEuIFRoZSByZXNpZHVhbCAkRGYgPSBhKG4tMSkkLCB3aGVyZSAkYSQgPSB0aGUgbnVtYmVyIG9mIGxldmVscyBvZiB5b3VyIGZhY3RvciBhbmQgJG4kID0gc2FtcGxlIHNpemUgKHJlcGxpY2F0ZXMgcGVyIGxldmVsKS4NCg0KVGhlIHN1bXMgb2Ygc3F1YXJlcyBhbmQgbWVhbiBzcXVhcmVzIGFyZSBtZWFzdXJlcyBvZiB2YXJpYXRpb24uIFRoZSAkRiQgc3RhdGlzdGljIGlzIHRoZSByYXRpbyBvZiAkTVNfe2Ftb25nfSQgYW5kICRNU197d2l0aGlufSQgYW5kIHRoZSBwLXZhbHVlIGlzIHRoZSBwcm9iYWJpbGl0eSBvZiB0aGUgb2JzZXJ2ZWQgJEYkIHZhbHVlIGZyb20gdGhlICRGJCBkaXN0cmlidXRpb24gKHdpdGggdGhlIGdpdmVuIGRlZ3JlZXMgb2YgZnJlZWRvbSkuDQoNClRoZSBtYWluIHRoaW5nIHRvIGxvb2sgYXQgaW4gdGhlIEFOT1ZBIHRhYmxlIGlzIHdoZXRoZXIgeW91ciBwcmVkaWN0b3IgdmFyaWFibGUgaGFkIGEgc2lnbmlmaWNhbnQgZWZmZWN0IG9uIHlvdXIgcmVzcG9uc2UgdmFyaWFibGUuIEluIHRoaXMgZXhhbXBsZSwgdGhlIHByb2JhYmlsaXR5IHRoYXQgYWxsIGZvdXIgaW5jdWJhdGlvbiB0ZW1wZXJhdHVyZXMgYXJlIGVxdWFsIGlzIDwwLjAwMS4gVGhpcyBpcyB2ZXJ5IHVubGlrZWx5IGFuZCBtdWNoIGxlc3MgdGhhbiAwLjA1LiBXZSB3b3VsZCBjb25jbHVkZSB0aGF0IHRoZXJlIGlzIGEgZGlmZmVyZW5jZSBpbiBoYXRjaGluZyB0aW1lcyBiZXR3ZWVuIHRoZSB0ZW1wZXJhdHVyZXMuDQoNCkluIHRoZSBgbG1gIG91dHB1dCAsIHlvdSBnZXQgYSBiaXQgbW9yZSBpbmZvcm1hdGlvbi4NCg0KYGBge3J9DQpzdW1tYXJ5KHR1cnRsZXMubG0pDQpgYGANClRoZSBvdXRwdXQgZm9yIHRoZSBzdGFuZGFyZCBBTk9WQSB0YWJsZSBpcyBkb3duIHRoZSBib3R0b20gYW5kIGFib3ZlIGl0IHlvdSBnZXQgdGhlIGFjdHVhbCBwYXJhbWV0ZXIgZXN0aW1hdGVzIGZyb20gdGhlIGxpbmVhciBtb2RlbCAodGhlICRcYmV0YV8xJCwgICRcYmV0YV8yJCwgZXRjLiBmcm9tIGFib3ZlKS4gSW4gdGhpcyBleGFtcGxlLCB0dXJ0bGVzIGF0IDE1wrBDIGhhdGNoZWQgYWZ0ZXIgNTguNCBkYXlzLCBvbiBhdmVyYWdlICh0aGUgaW50ZXJjZXB0IGluIHRoZSBtb2RlbCkuIFRoZSBvdGhlciBwYXJhbWV0ZXIgZXN0aW1hdGVzIGFyZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGVhY2ggbGV2ZWwgb2YgdGVtcGVyYXR1cmUgYW5kIHRoZSBpbnRlcmNlcHQuIEZvciBleGFtcGxlLCBhdCAyMMKwQyB0aGV5IHdlcmUgMTMuOCBkYXlzIGZhc3RlciAoaS5lLiwgdGhlIG1lYW4gZm9yIDIwwrBDID0gNTguNC0xMy44ID0gNDQuNiBkYXlzKS4NCg0KSWYgeW91IGRldGVjdCBhbnkgc2lnbmlmaWNhbnQgZGlmZmVyZW5jZXMgaW4gdGhlIEFOT1ZBLCB3ZSBhcmUgdGhlbiBpbnRlcmVzdGVkIGluIGtub3dpbmcgZXhhY3RseSB3aGljaCBncm91cHMgZGlmZmVyIGZyb20gb25lIGFub3RoZXIsIGFuZCB3aGljaCBkbyBub3QuIFJlbWVtYmVyIHRoYXQgYSBzaWduaWZpY2FudCBwIHZhbHVlIGluIHRoZSB0ZXN0IHlvdSBqdXN0IHJhbiB3b3VsZCByZWplY3QgdGhlIG51bGwgaHlwb3RoZXNpcyB0aGUgbWVhbnMgb2YgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSB3ZXJlIHRoZSBzYW1lIGFjcm9zcyBhbGwgZ3JvdXBzLCBidXQgbm90IGlkZW50aWZ5IHdoaWNoIHdlcmUgZGlmZmVyZW50IGZyb20gZWFjaCBvdGhlci4gVG8gc2VlIGEgY29tcGFyaXNvbiBiZXR3ZWVuIGVhY2ggbWVhbiBhbmQgZWFjaCBvdGhlciBtZWFuLCB3ZSBjYW4gdXNlIGEgVHVrZXnigJlzIHBvc3QtaG9jIHRlc3QuDQoNCmBgYHtyfQ0KVHVrZXlIU0QodHVydGxlcy5hb3YpDQpgYGANCiMjIyBBc3N1bXB0aW9ucw0KDQpBcyBmb3IgYW55IGxpbmVhciBtb2RlbHMsIFRoZSBpbXBvcnRhbnQgYXNzdW1wdGlvbnMgb2YgQU5PVkEgYXJlIGluZGVwZW5kZW5jZSwgaG9tb2dlbmVpdHkgb2YgdmFyaWFuY2UgYW5kIG5vcm1hbGl0eS4gTWFueSBhZHZvY2F0ZSBhIHF1YWxpdGF0aXZlIGV2YWx1YXRpb24gb2YgdGhlIG5vcm1hbGl0eSBhbmQgaG9tb2dlbmVpdHkgb2YgdmFyaWFuY2UgYXNzdW1wdGlvbnMsIGJ5IGV4YW1pbmluZyB0aGUgcGF0dGVybnMgb2YgdmFyaWF0aW9uIGluIHRoZSByZXNpZHVhbHMsIHJhdGhlciB0aGFuIGEgZm9ybWFsIHRlc3QuIExpbmVhciBtb2RlbHMgaW4gZ2VuZXJhbCBhcmUgcXVpdGUg4oCYcm9idXN04oCZIGZvciB2aW9sYXRpbmcgdGhlc2UgYXNzdW1wdGlvbnMgKGhldGVyb2dlbmVpdHkgYW5kIG5vcm1hbGl0eSksIHdpdGhpbiByZWFzb24gb2YgY291cnNlLg0KDQoNCmBgYHtyfQ0KcGFyKG1mcm93ID0gYygxLCAzKSkgIyBUaGlzIGNvZGUgcHV0IHR3byBwbG90cyBpbiB0aGUgc2FtZSB3aW5kb3cNCmhpc3QodHVydGxlcy5hb3YkcmVzaWR1YWxzKQ0KcGxvdCh0dXJ0bGVzLmFvdiwgd2hpY2ggPSAyKQ0KcGxvdCh0dXJ0bGVzLmFvdiwgd2hpY2ggPSAxKQ0KYGBgDQoNClZpb2xhdGlvbnMgb2Ygbm9ybWFsaXR5IGFuZCBob21vZ2VuZWl0eSBvZiB2YXJpYW5jZSBjYW4gYmUgZml4ZWQgdmlhIHRyYW5zZm9ybWF0aW9ucyBvciBieSB1c2luZyBhIGRpZmZlcmVudCBlcnJvci1kaXN0cmlidXRpb24gaW4gYSBnZW5lcmFsaXNlZCBsaW5lYXIgbW9kZWwgKEdMTSkuDQoNCiMjIEZhY3RvcmlhbCBBTk9WQQ0KDQpDb25zaWRlciBhbiBleGFtcGxlIHdoZXJlIGEgcmVzZWFyY2hlciBpcyB0ZXN0aW5nIHRoZSBlZmZlY3RzIG9mIG1ldGFsIGNvbnRhbWluYXRpb24gb24gdGhlIG51bWJlciBvZiBzcGVjaWVzIGZvdW5kIGluIHNlc3NpbGUgbWFyaW5lIGludmVydGVicmF0ZXMgKHNwb25nZXMsIGJyeW96b2FucyBhbmQgc2VhIHNxdWlydHMgZXRjLikuIFRoZXkgd291bGQgbGlrZSB0byBrbm93IHdoZXRoZXIgY29wcGVyIHJlZHVjZXMgc3BlY2llcyByaWNobmVzcywgYnV0IGFsc28ga25vdyB0aGF0IHRoZSByaWNobmVzcyBvZiBpbnZlcnRlYnJhdGVzIGNhbiBkZXBlbmQgb24gd2hldGhlciB0aGUgc3Vic3RyYXRlIGlzIHZlcnRpY2FsIG9yIGhvcml6b250YWwuIENvbnNlcXVlbnRseSwgdGhleSByYW4gYW4gZXhwZXJpbWVudCB3aGVyZSBzcGVjaWVzIHJpY2huZXNzIHdhcyByZWNvcmRlZCBpbiByZXBsaWNhdGUgc2FtcGxlcyBpbiBlYWNoIG9mIHRoZSBzaXggY29tYmluYXRpb25zIG9mIGNvcHBlciBlbnJpY2htZW50ICjigJxOb25l4oCdLOKAnExvd+KAnSzigJxIaWdo4oCdKSBhbmQgb3JpZW50YXRpb24gKOKAnFZlcnRpY2Fs4oCdLOKAnEhvcml6b250YWzigJ0pLiBUaGUgZXhwZXJpbWVudGFsIGRlc2lnbiBpbiB0ZXJtZWQgKipmYWN0b3JpYWwqKiBiZWNhdXNlICoqYWxsIGxldmVscyBvZiBvbmUgdHJlYXRtZW50IGFyZSByZXByZXNlbnRlZCBpbiBhbGwgbGV2ZWxzIG9mIHRoZSBvdGhlciB0cmVhdG1lbnRzIChhbHNvIHRlcm1lZCBvcnRob2dvbmFsKSoqLg0KDQpgYGB7cn0NCnNlc3NpbGUgPC0gcmVhZC5jc3YoZmlsZSA9ICJkYXRhL3Nlc3NpbGUuY3N2IiwgaGVhZGVyID0gVFJVRSkNCiMgY2hlY2sgeW91ciBwcmVkaWN0b3JzIHdpdGggYHN0cmANCmJveHBsb3QoUmljaG5lc3MgfiBDb3BwZXIgKiBPcmllbnRhdGlvbiwgZGF0YSA9IHNlc3NpbGUsIG5hbWVzID0gYygiSGlnaC5IIiwgIkxvdy5IIiwgIk5vbmUuSCIsICJIaWdoLlYiLCAiTG93LlYiLCAiTm9uZS5WIiksIHlsYWIgPSAiU3BlY2llcyByaWNobmVzcyIsIHhsYWIgPSAiQ29wcGVyL09yaWVudGF0aW9uIiwgeWxpbSA9IGMoMCwgODApKQ0KYGBgDQoNCg0KVGhlIGZhY3RvcmlhbCBBTk9WQSB3aWxsIHRlc3Q6DQoNCi0gd2hldGhlciB0aGVyZSBhcmUgYW55IGRpZmZlcmVuY2VzIGluIHJpY2huZXNzIGFtb25nIHRoZSB0aHJlZSBsZXZlbHMgb2YgY29wcGVyIGVucmljaG1lbnQNCi0gd2hldGhlciB0aGVyZSBhcmUgYW55IGRpZmZlcmVuY2VzIGluIHJpY2huZXNzIGFtb25nIHRoZSB0d28gbGV2ZWxzIG9mIHN1YnN0cmF0ZSBvcmllbnRhdGlvbg0KLSB3aGV0aGVyIHRoZXJlIGlzIGFueSBpbnRlcmFjdGlvbiBiZXR3ZWVuIGNvcHBlciBhbmQgb3JpZW50YXRpb24NCg0KWW91IGhhdmUgdGhyZWUgbnVsbCBoeXBvdGhlc2VzOg0KDQotIHRoZXJlIGlzIG5vIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgbWVhbnMgZm9yIGVhY2ggbGV2ZWwgb2YgY29wcGVyLCBIbzogJFxtdV97bm9uZX09XG11X3tsb3d9PVxtdV97aGlnaH0kDQoNCi0gdGhlcmUgaXMgbm8gZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBtZWFucyBmb3IgZWFjaCBsZXZlbCBvZiBvcmllbnRhdGlvbiwgSG86ICAkXG11X3t2ZXJ0aWNhbH09XG11X3tob3Jpem9udGFsfSQNCg0KLSB0aGVyZSBpcyBubyBpbnRlcmFjdGlvbiBiZXR3ZWVuIHRoZSBmYWN0b3JzDQoNCg0KVGhpcyBpcyBmYXIgYmV0dGVyIHRoYW4gcnVubmluZyB0d28gc2VwYXJhdGUgc2luZ2xlIGZhY3RvciBBTk9WQXMgdGhhdCBjb250cmFzdCBjb3BwZXIgZWZmZWN0cyBmb3IgZWFjaCBsZXZlbCBvZiBvcmllbnRhdGlvbiBiZWNhdXNlIHlvdSBoYXZlIG1vcmUgc3RhdGlzdGljYWwgcG93ZXIgKGhpZ2hlciBkZWdyZWVzIG9mIGZyZWVkb20pIGZvciB0aGUgdGVzdHMgb2YgaW50ZXJlc3QsIGFuZCB5b3UgZ2V0IGEgZm9ybWFsIHRlc3Qgb2YgdGhlIGludGVyYWN0aW9uIGJldHdlZW4gZmFjdG9ycyB3aGljaCBpcyBvZnRlbiBzY2llbnRpZmljYWxseSBpbnRlcmVzdGluZy4NCg0KJHlfe2lqfT1cbXUgKyBcYWxwaGFfaSArIFxiZXRhX2ogKyAoXGFscGhhXGJldGEpX3tpan0gKyBcZXBzaWxvbl97aWprfSQNCg0Kd2hlcmUgJFxtdSQgaXMgdGhlIG92ZXJhbGwgbWVhbiwgJFxhbHBoYV9pJCBpcyB0aGUgZWZmZWN0IG9mIHRoZSBpPHN1cD50aDwvc3VwPiBncm91cCBvZiB0aGUgZmlyc3QgZmFjdG9yLCAkXGJldGFfaiQgaXMgdGhlIGVmZmVjdCBvZiB0aGUgajxzdXA+dGg8L3N1cD4gZ3JvdXAgb2YgdGhlIHNlY29uZCBmYWN0b3IsIGFuZCAkXGFscGhhXGJldGEkIHRoZSBpbnRlcmFjdGlvbi4gQXRob3VnaCB3ZSBoYXZlIHR3byBmYWN0b3JzLCBhbmQgYW4gaW50ZXJhY3Rpb24gZWZmZWN0LCB0aGlzIHJlcXVpcmVzIGZpdHRpbmcgbW9yZSB0aGFuIDMgcGFyYW1ldGVycyBpbiBvdXIgbW9kZWwgYmVjYXVzZSB3ZSBoYXZlIDMgbGV2ZWxzIG9mIEZhY3RvciBBIChDb3BwZXIpIGFuZCAyIGxldmVscyBvZiBGYWN0b3IgQiAoT3JpZW50YXRpb24pLg0KDQpXaXRoIHR3byBmYWN0b3JzLCBBTk9WQSBwYXJ0aXRpb25zIHRoZSB0b3RhbCB2YXJpYW5jZSBpbnRvIGEgY29tcG9uZW50IHRoYXQgY2FuIGJlIGV4cGxhaW5lZCBieSB0aGUgZmlyc3QgcHJlZGljdG9yIHZhcmlhYmxlIChhbW9uZyBsZXZlbHMgb2YgdGhlIHRyZWF0bWVudCBBKSwgYSBjb21wb25lbnQgdGhhdCBjYW4gYmUgZXhwbGFpbmVkIGJ5IHRoZSBzZWNvbmQgcHJlZGljdG9yIHZhcmlhYmxlIChhbW9uZyBsZXZlbHMgb2YgdGhlIHRyZWF0bWVudCBCKSwgYSBjb21wb25lbnQgdGhhdCBjYW4gYmUgZXhwbGFpbmVkIGJ5IHRoZSBpbnRlcmFjdGlvbiwgYW5kIGEgY29tcG9uZW50IHRoYXQgY2Fubm90IGJlIGV4cGxhaW5lZCAod2l0aGluIGxldmVscywgdGhlIHJlc2lkdWFsIHZhcmlhbmNlKS4gVGhlIHRlc3Qgc3RhdGlzdGljLCAkRiQsIGlzIGNhbGN1bGF0ZWQgdGhyZWUgdGltZXMgdG8gdGVzdCBlYWNoIG9mIHRoZSBudWxsIGh5cG90aGVzZXMuIEZvciB0d28gZml4ZWQgZmFjdG9ycywgdGhlICRGJCByYXRpb3MgYXJlOg0KDQoNCiRGPVxmcmFje01TX3tBfX17TVNfe3dpdGhpbn19JA0KDQokRj1cZnJhY3tNU197Qn19e01TX3t3aXRoaW59fSQNCg0KJEY9XGZyYWN7TVNfe0FCfX17TVNfe3dpdGhpbn19JA0KDQp3aGVyZSBNUyBhcmUgdGhlIG1lYW4gc3F1YXJlcywgYSBtZWFzdXJlIG9mIHZhcmlhdGlvbi4gVGhlIHByb2JhYmlsaXR5IG9mIG9idGFpbmluZyB0aGUgb2JzZXJ2ZWQgdmFsdWUgb2YgJEYkIGlzIGNhbGN1bGF0ZWQgZnJvbSB0aGUga25vd24gcHJvYmFiaWxpdHkgZGlzdHJpYnV0aW9uIG9mICRGJCwgd2l0aCB0d28gZGVncmVlcyBvZiBmcmVlZG9tIChvbmUgZm9yIHRoZSBudW1lcmF0b3IgPSB0aGUgbnVtYmVyIG9mIGxldmVscyAtMSkgYW5kIG9uZSBmb3IgdGhlIGRlbm9taW5hdG9yLiBOb3RlIHRoYXQgdGhlc2UgJEYkIHJhdGlvcyB3aWxsIGNoYW5nZSBpZiBhbnkgZmFjdG9ycyBhcmUgcmFuZG9tIChzZWUgYmVsb3cgZm9yIHRoZSBkaXN0aW5jdGlvbiBiZXR3ZWVuIGZpeGVkIGFuZCByYW5kb20gZmFjdG9ycykuDQoNCiMjIyBSdW5uaW5nIHRoZSBhbmFseXNpcw0KDQpGb3IgdGhpcyB0d28gZmFjdG9yIGRlc2lnbiwgd2UgdXNlOg0KDQoNCmBgYHtyfQ0Kc2Vzc2lsZS5hb3YgPC0gYW92KFJpY2huZXNzIH4gQ29wcGVyICogT3JpZW50YXRpb24sIGRhdGEgPSBzZXNzaWxlKQ0KIyBzYW1lIGFzOg0Kc2Vzc2lsZS5hb3YgPC0gYW92KFJpY2huZXNzIH4gQ29wcGVyICsgT3JpZW50YXRpb24gKyBDb3BwZXI6T3JpZW50YXRpb24sIGRhdGEgPSBzZXNzaWxlKQ0Kc3VtbWFyeShzZXNzaWxlLmFvdikNCg0KIyBzYW1lIGFzOg0Kc2Vzc2lsZS5sbSA8LSBsbShSaWNobmVzcyB+IENvcHBlciAqIE9yaWVudGF0aW9uLCBkYXRhID0gc2Vzc2lsZSkNCmFub3ZhKHNlc3NpbGUubG0pDQpgYGANCkNoZWNrIHRoYXQgeW91IGhhdmUgdGhlIGNvcnJlY3QgZGVncmVlcyBvZiBmcmVlZG9tLiBGb3IgYSB0d28gZmFjdG9yIGRlc2lnbiB3aXRoIGZpeGVkIGZhY3RvcnMgdGhleSBhcmU6DQoNCi0gRmFjdG9yIEE6IGEgLSAxICh3aGVyZSBhID0gbnVtYmVyIG9mIGxldmVscyBvZiBGYWN0b3IgQSkNCi0gRmFjdG9yIEI6IGIgLSAxICh3aGVyZSBiID0gbnVtYmVyIG9mIGxldmVscyBvZiBGYWN0b3IgQikNCi0gSW50ZXJhY3Rpb24gKEFCKTogKGEtMSkoYi0xKQ0KLSBSZXNpZHVhbDogYWIobiAtMSkgKHdoZXJlIG4gPSBzYW1wbGUgc2l6ZSkNCg0KVGhlIHN1bXMgb2Ygc3F1YXJlcyBhbmQgbWVhbiBzcXVhcmVzIGFyZSBtZWFzdXJlcyBvZiB2YXJpYXRpb24uIFRoZXJlIGFyZSB0aHJlZSBGIHN0YXRpc3RpY3MsIGNvcnJlc3BvbmRpbmcgdG8gYSB0ZXN0IG9mIGVhY2ggb2YgdGhlIG1haW4gZWZmZWN0cyBhbmQgb25lIGZvciB0aGUgaW50ZXJhY3Rpb24uIFRoZSBwLXZhbHVlcyBhcmUgdGhlIHByb2JhYmlsaXRpZXMgb2YgdGhlIG9ic2VydmVkIEYgdmFsdWVzIGZyb20gdGhlIEYgZGlzdHJpYnV0aW9uICh3aXRoIHRoZSBnaXZlbiBkZWdyZWVzIG9mIGZyZWVkb20pLg0KDQpJbiB0aGlzIGV4YW1wbGUsIHRoZXJlIGlzIHN0cm9uZyBldmlkZW5jZSB0byByZWplY3QgYWxsIHRocmVlIG51bGwgaHlwb3RoZXNlczoNCg0KLSB0aGF0IGFsbCBsZXZlbHMgb2YgdGhlIGNvcHBlciB0cmVhdG1lbnQgYXJlIGVxdWFsIChQIDwgMC4wMDEpLA0KLSB0aGF0IHRoZSB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbCBvcmllbnRhdGlvbnMgYXJlIGVxdWFsIChQIDwgMC4wMDEpDQotIHRoYXQgdGhlcmUgaXMgbm8gaW50ZXJhY3Rpb24gYmV0d2VlbiBjb3BwZXIgYW5kIG9yaWVudGF0aW9uIChQIDwgMC4wMDEpDQoNCkEgc2lnbmlmaWNhbnQgaW50ZXJhY3Rpb24gbWVhbnMgdGhhdCB0aGUgZWZmZWN0IG9mIG9uZSBmYWN0b3IgZGVwZW5kcyB1cG9uIHRoZSBvdGhlci4gSW4gdGhpcyBleGFtcGxlLCBpdCB3b3VsZCBtZWFuIHRoYXQgdGhlIGVmZmVjdCBvZiBjb3BwZXIgd2FzIG5vdCBjb25zaXN0ZW50IGJldHdlZW4gdGhlIHZlcnRpY2FsIGFuZCBob3Jpem9udGFsIGhhYml0YXRzLiBDb25zZXF1ZW50bHksIHRoZSBpbnRlcnByZXRhdGlvbiBvZiB0aGUgbWFpbiBlZmZlY3RzIGJlY29tZXMgbW9yZSBjb21wbGV4LiBBIHF1aWNrIHdheSB0byBoZWxwIHlvdSB1bmRlcnN0YW5kIGFuIGludGVyYWN0aW9uIGlmIHlvdSBnZXQgb25lIGlzIHRvIGV4YW1pbmUgYW4gaW50ZXJhY3Rpb25zIHBsb3QuDQoNCg0KYGBge3J9DQppbnRlcmFjdGlvbi5wbG90KHNlc3NpbGUkQ29wcGVyLCBzZXNzaWxlJE9yaWVudGF0aW9uLCBzZXNzaWxlJFJpY2huZXNzKQ0KYGBgDQoNCkhlcmUgeW91IGNhbiBzZWUgdGhhdCB0aGUgZWZmZWN0IG9mIGNvcHBlciAoYSBkZWNsaW5lIGluIHNwZWNpZXMgcmljaG5lc3MpIGlzIG1vcmUgcHJvbm91bmNlZCBpbiB0aGUgaGFiaXRhdHMgd2l0aCBhIHZlcnRpY2FsIG9yaWVudGF0aW9uLCBhbmQgdGhhdCB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSB0d28gaGFiaXRhdHMgY2hhbmdlcyB3aXRoIGV4cG9zdXJlIHRvIGNvcHBlci4NCg0KKipNdWx0aXBsZSBjb21wYXJpc29ucyoqIElmIHlvdSBkZXRlY3QgYW55IHNpZ25pZmljYW50IGRpZmZlcmVuY2VzIGluIHRoZSBBTk9WQSwgd2UgYXJlIHRoZW4gaW50ZXJlc3RlZCBpbiBrbm93aW5nIGV4YWN0bHkgd2hpY2ggbGV2ZWxzIGRpZmZlciBmcm9tIG9uZSBhbm90aGVyLCBhbmQgd2hpY2ggZG8gbm90LiBSZW1lbWJlciB0aGF0IGEgc2lnbmlmaWNhbnQgcCB2YWx1ZSBpbiB0aGUgdGVzdCB5b3UganVzdCByYW4gd291bGQgcmVqZWN0IHRoZSBudWxsIGh5cG90aGVzaXMgdGhlIG1lYW5zIHdlcmUgdGhlIHNhbWUgYWNyb3NzIGFsbCBncm91cHMsIGJ1dCBub3QgaWRlbnRpZnkgd2hpY2ggd2VyZSBkaWZmZXJlbnQgZnJvbSBlYWNoIG90aGVyLiBJZiB0aGVyZSBpcyBubyBpbnRlcmFjdGlvbiwgeW91IGNhbiBydW4gYSBwb3N0LWhvYyB0ZXN0IG9uIGVhY2ggb2YgdGhlIG1haW4gZWZmZWN0cyAob25seSBuZWVkZWQgaWYgdGhlcmUgYXJlIG1vcmUgdGhhbiB0d28gbGV2ZWxzIGZvciBhbiBlZmZlY3QpLiBJZiB0aGVyZSBpcyBhbiBpbnRlcmFjdGlvbiwgeW91IHdpbGwgbmVlZCB0byBjb25zaWRlciBwb3N0LWhvYyB0ZXN0cyB0aGF0IGNvbnRyYXN0IHRoZSBtZWFucyBmcm9tIGFsbCBjb21iaW5hdGlvbnMgb2YgYm90aCBmYWN0b3JzLg0KDQojIyMgQXNzdW1wdGlvbnMNCg0KVGhlIGFzc3VtcHRpb25zIG9mIGZhY3RvcmlhbCBBTk9WQeKAmXMgYXJlIHRoZSBzYW1lIGFzIGZvciBhbGwgbGluZWFyIG1vZGVscyBpbmNsdWRpbmcgdGhlIHNpbXBsZXIgb25lLXdheSBBTk9WQeKAmXMsIGJlaW5nICoqaW5kZXBlbmRlbmNlKiosICoqbm9ybWFsaXR5KiogYW5kICoqaG9tb2dlbmVpdHkgb2YgdmFyaWFuY2VzKiouIFdlIGFsc28gbmVlZCB0byBjb25zaWRlciB0d28gbmV3IGlzc3VlczogMSkgd2hldGhlciB5b3VyIGZhY3RvcnMgYXJlICoqZml4ZWQqKiBvciAqKnJhbmRvbSoqLCBhbmQgMikgd2hldGhlciB5b3VyIHNhbXBsaW5nIG9yIGV4cGVyaW1lbnRhbCBkZXNpZ24gaXMgKipiYWxhbmNlZCoqIChpLmUuLCBoYXMgdGhlIHNhbWUgbnVtYmVyIG9mIHJlcGxpY2F0ZXMgaW4gZWFjaCBjb21iaW5hdGlvbiBvZiB0cmVhdG1lbnRzKS4NCg0KKipGaXhlZCBhbmQgcmFuZG9tIGZhY3RvcnMqKiBUaGVyZSBpcyBhbiBpbXBvcnRhbnQgZGlzdGluY3Rpb24gYmV0d2VlbiBmYWN0b3JzIHdob3NlIGxldmVscyBhcmUgdGhlIG9ubHkgb25lcyBvZiBpbnRlcmVzdCAodGVybWVkIGZpeGVkKSwgYW5kIGZhY3RvcnMgd2hvc2UgbGV2ZWxzIGFyZSBhIHNhbXBsZWQgZnJvbSBhIGxhcmdlciBjb2xsZWN0aW9uIG9mIHBvc3NpYmxlIGxldmVscyAodGVybWVkIHJhbmRvbSkuIEZvciBleGFtcGxlLCBpZiB3ZSByZXBlYXRlZCB0aGUgZXhwZXJpbWVudCBhYm92ZSBhdCB0aHJlZSBkaWZmZXJlbnQgc2l0ZXMgaW4gYW5vdGhlciBoYXJib3VyLCBjaG9zZW4gZnJvbSBtYW55IHBvc3NpYmxlIHNpdGVzLCB3ZSB3b3VsZCBjb25zaWRlciBzaXRlIGEgcmFuZG9tIGZhY3Rvci4gV2UgYXJlIG5vdCBpbnRlcmVzdGVkIGluIHRob3NlIHNpdGVzIGluIHBhcnRpY3VsYXIsIGJ1dCB3b3VsZCBsaWtlIHRvIGtub3cgaWYgb3VyIGV4cGVyaW1lbnRhbCB0cmVhdG1lbnRzIHdlcmUgY29uc2lzdGVudCBhY3Jvc3Mgc2l0ZXMuIE9uIHRoZSBvdGhlciBoYW5kLCBpZiB5b3Ugd2VyZSBvbmx5IGludGVyZXN0ZWQgaW4gS2VlbHVuZyBIYXJib3VyIGFuZCBLYW9zaGl1bmcgSGFyYm91ciwgdGhlbiB0aGVzZSB0d28gY291bGQgYmUgY29uc2lkZXJlZCB0d28gbGV2ZWxzIG9mIGEgZml4ZWQgZmFjdG9yLiBUcmVhdGluZyBzaXRlcyBhcyBhIGZpeGVkIGZhY3RvciBpbiB0aGF0IGNhc2UgbWVhbnMgdGhhdCB5b3UgY29uY2x1c2lvbnMgc2hvdWxkIG5vdCBiZSBleHRyYXBvbGF0ZWQgdG8gb3RoZXIgcG9zc2libGUgc2l0ZXMsIGJ1dCByZXN0cmljdGVkIHRvIHRob3NlIHBhcnRpY3VsYXIgc2l0ZXMuDQoNClN0YXRpc3RpY2FsbHksIHRoZXJlIGlzIGEgYmlnIGRpZmZlcmVuY2UgYmV0d2VlbiBhIGZpeGVkIGZhY3RvcnMgd2VyZSB5b3UgaGF2ZSBtZWFzdXJlZCBhbGwgcG9zc2libGUgbGV2ZWxzIG9mIGludGVyZXN0IChlLmcsIGNvbnRyb2wgdnMgYSBzaW5nbGUgdHJlYXRtZW50KSBhbmQgcmFuZG9tIGZhY3RvcnMgd2hlcmUgdGhlIGxldmVscyBhcmUgc2FtcGxlZCBmcm9tIGFsbCBwb3NzaWJsZSBsZXZlbHMuIEluIGFuYWx5c2lzIG9mIHZhcmlhbmNlLCBhbGwgdGhpcyBtYXR0ZXJzIGJlY2F1c2UgdGhlIEYtdGVzdHMgdGhhdCBhcmUgYmVpbmcgdXNlZCB0byB0ZXN0IHlvdXIgaHlwb3RoZXNlcyBhcmUgY29uc3RydWN0ZWQgZGlmZmVyZW50bHkgZGVwZW5kaW5nIG9uIHdoaWNoIGZhY3RvcnMgYXJlIGZpeGVkIGFuZCByYW5kb20uIEluIHRoZSBleGFtcGxlIGFib3ZlLCBhbGwgZmFjdG9ycyB3ZXJlIGZpeGVkIGFuZCB0aGUgZGVub21pbmF0b3Igb2YgYWxsIEYgdGVzdHMgd2FzICRNU197d2l0aGlufSQuIEluIG1vZGVscyB3aXRoIGFsbCBmYWN0b3JzIHJhbmRvbSwgYW5kIG1vZGVscyB3aXRoIGEgbWl4IG9mIGZpeGVkIGFuZCByYW5kb20gZmFjdG9ycyAodGVybWVkIG1peGVkIGVmZmVjdHMgbW9kZWxzKSwgb3RoZXIgY29tcG9uZW50cyBvZiB0aGUgdmFyaWF0aW9uIGFyZSB1c2VkIGFzIHRoZSBkZW5vbWluYXRvcnMgaW4gdGhlICRGJCB0ZXN0cy4NCg0KSWYgeW91IGhhdmUgcmFuZG9tIGZhY3RvcnMsIHlvdSB3aWxsIG5lZWQgdG8gcmVhZCBtb3JlIHRvIGVzdGFibGlzaCB0aGUgY29ycmVjdCBGIHJhdGlvcyBmb3IgeW91ciBzcGVjaWZpYyBkZXNpZ24uDQoNCioqQmFsYW5jZWQgYW5kIHVuYmFsYW5jZWQgZGVzaWducyoqIElkZWFsbHksIGZhY3RvcmlhbCBBTk9WQSBzaG91bGQgYmUgY29uZHVjdGVkIHdpdGggYSBiYWxhbmNlZCBkZXNpZ24gLSBvbmUgd2l0aCB0aGUgc2FtZSBudW1iZXIgb2YgcmVwbGljYXRlcyBpbiBlYWNoIGNvbWJpbmF0aW9uIG9mIGZhY3RvcnMuIEJhbGFuY2VkIGRlc2lnbnMgYXJlIGxlc3MgbGlrZWx5IHRvIGJlIGFmZmVjdGVkIGJ5IG1pbm9yIGRldmlhdGlvbnMgZnJvbSB0aGUgYXNzdW1wdGlvbnMgb2Ygbm9ybWFsaXR5IGFuZCBob21vZ2VuZWl0eSBvZiB2YXJpYW5jZS4gVW5mb3J0dW5hdGVseSwgdW5iYWxhbmNlZCBkZXNpZ25zIHdoZXJlIHlvdSBoYXZlIHVuZXF1YWwgbnVtYmVycyBvZiByZXBsaWNhdGVzIGZvciBlYWNoIGxldmVsIGFyZSBjb21tb24gaW4gcHJhY3RpY2UgKGUuZy4gYmFkIHdlYXRoZXIgcHJldmVudGVkIHNhbXBsaW5nIHRoZSBzZWNvbmQgc2l0ZSBhcyBpbnRlbnNpdmVseSwgdm9sdW50ZWVyIGxvc3QgdGhlIGRhdGEgc2hlZXQgZXRjISkuDQoNClVuYmFsYW5jZWQgZGVzaWducyBhcmUgbW9yZSBzdXNjZXB0aWJsZSB0byB2aW9sYXRpbmcgdGhlIGFzc3VtcHRpb25zIG9mIEFOT1ZBIGFuZCB0aGVyZSBpcyBubyBzaW5nbGUgd2F5IHRvIHBhcnRpdGlvbmluZyB0aGUgJFNTX3t0b3RhbH0kIGludG8gdGhlIG1haW4gZWZmZWN0IGFuZCBpbnRlcmFjdGlvbiBjb21wb25lbnRzLiBUaGUgYGFvdmAgYW5kIGBsbWAgZnVuY3Rpb25zIGluIFIgdXNlIHdoYXQgYXJlIGNhbGxlZCAqKlR5cGUgSSBzdW1zIG9mIHNxdWFyZXMqKiB3aGVyZSB0aGUgdGVybXMgaW4gdGhlIG1vZGVsIGFyZSBmaXR0ZWQgc2VxdWVudGlhbGx5IChpLmUuLCBob3cgbXVjaCB2YXJpYXRpb24gaXMgZXhwbGFpbmVkIGJ5IGZhY3RvciBBLCB0aGVuIGhvdyBtdWNoIGFkZGl0aW9uYWwgdmFyaWF0aW9uIGlzIGV4cGxhaW5lZCBieSBhZGRpbmcgZmFjdG9yIEIpLiBUaGlzIG1lYW5zIHRoYXQgdGhlIG9yZGVyIG9mIHRoZSB0ZXJtcyBpbiBtb2RlbCBtYXR0ZXJzOiB0aGUgbW9kZWwgZm9ybXVsYWUgYFkgfiBBICsgQiArIEE6QmAgYW5kIGBZIH4gQiArIEEgKyBCOkFgIHdpbGwgZ2l2ZSB5b3UgZGlmZmVyZW50IHJlc3VsdHMuDQoNClRoZXJlIGlzIGEgZmFpciBiaXQgb2YgZGViYXRlIG9uIHRoaXMgaW4gdGhlIHN0YXRpc3RpY2FsIGxpdGVyYXR1cmUsIGJ1dCBtYW55IGFkdmlzZSB1c2luZyB3aGF0IGFyZSBjYWxsZWQgVHlwZSBJSSBvciBUeXBlIElJSSBzdW1zIG9mIHNxdWFyZXMgZm9yIHVuYmFsYW5jZWQgZGVzaWducy4gT3RoZXIgc29mdHdhcmUgcGFja2FnZXMgbGlrZSBTUFNTLCBTWVNUQVQgYW5kIE1pbml0YWIgd2lsbCBhdXRvbWF0aWNhbGx5IHVzZSBUeXBlIElJSSBzdW1zIG9mIHNxdWFyZXMgd2hlcmUgdGhlIG9yZGVyIG9mIHRlcm1zIGluIHRoZSBtb2RlbCBkb2VzbuKAmXQgbWF0dGVyLiBUbyBhY2Nlc3MgdGhlc2UgaW4gUiwgd2UgY2FuIHVzZSB0aGUgYEFub3ZhYCBmdW5jdGlvbiBpbiB0aGUgYGNhcmAgcGFja2FnZS4gQnV0IHRoaXMgZGViYXRlIGlzIGFsc28gb25lIG9mIHJlYXNvbiBtYW55IHJlc2VhcmNoZXIgcHJlZmVyIHRvIGF2b2lkIG9yIGRvZXMgbm90IGxpa2UgQU5PVkFzLg0KDQojIyBOZXN0ZWQgQU5PVkENCg0KSW4gdGhlIHR3by13YXkgQU5PVkEgZGVzaWduLCB0aGUgdHdvIGZhY3RvcnMgYXJlIGtub3duIGFzIGZhY3RvcmlhbCAoaS5lLiwgdGhlcmUgd2FzIGV2ZXJ5IGNvbWJpbmF0aW9uIG9mIGV2ZXJ5IGxldmVsIG9mIGVhY2ggZmFjdG9yKS4gT3RoZXIgZXhwZXJpbWVudGFsIGRlc2lnbnMgZmVhdHVyZSBmYWN0b3JzIHRoYXQgYXJlIHRlcm1lZCBuZXN0ZWQuIFRoaXMgaXMgd2hlbiBlYWNoIGxldmVsIG9mIG9uZSBvZiB0aGUgZmFjdG9ycyBpcyB1bmlxdWUgdG8gb25seSBvbmUgbGV2ZWwgb2YgdGhlIG90aGVyIGZhY3Rvci4gSW4gdGhlIG5lc3RlZCBkZXNpZ24sIHRoZSBsZXZlbHMgb2YgZmFjdG9yIEIgYXBwZWFyIGluIG9ubHkgb25lIG9mIHRoZSBsZXZlbHMgaW4gZmFjdG9yIEEsIG5vdCBib3RoLiBUaGlzIG9mdGVuIGhhcHBlbnMgd2l0aCBmYWN0b3JzIGxpa2Ug4oCcc2l0ZeKAnSBvciDigJxhcmVh4oCdIC0gdGhleSB1c3VhbGx5IGJlbG9uZyB0byBvbmx5IG9uZSBsZXZlbCBvZiB5b3VyIG90aGVyIGZhY3Rvci4gRmFjdG9yIEIgaXMgdGVybWVkIG5lc3RlZCB3aXRoaW4gZmFjdG9yIEEsIHVzdWFsbHkgd3JpdHRlbiBhcyBCKEEpLiBUaGVzZSBkZXNpZ25zIGhhdmUgZGlmZmVyZW50IHNvdXJjZXMgb2YgdmFyaWFuY2UgdG8gdGhlIGZhY3RvcmlhbCBkZXNpZ25zLCBhbmQgZG8gbm90IGhhdmUgYW4gaW50ZXJhY3Rpb24gdGVybS4gVGhlIGRlc2lnbnMgYXJlIHF1aXRlIGNvbW1vbiBpbiBlY29sb2d5IGFuZCBlbnZpcm9ubWVudGFsIHNjaWVuY2VzLCBhbmQgYXJlIG9mdGVuIHVzZWQgdG8gcGFydGl0aW9uIHZhcmlhbmNlIGluIHNwYXRpYWxseSBoaWVyYXJjaGljYWwgc2FtcGxpbmcgKGUuZy4sIGhhYml0YXRzLCBhcmVhcyB3aXRoaW4gaGFiaXRhdHMsIHBsb3RzIHdpdGhpbiBhcmVhcyBldGMuKS4NCg0KVGhlIGV4YW1wbGVzIGJlbG93IGNvbWVzIGZyb20gYW4gZXhwZXJpbWVudCBpbnZlc3RpZ2F0aW5nIHRoZSBpbXBhY3Qgb2YgaW50cm9kdWNlZCBBbWVyaWNhbiBtaW5rIG9uIHNtYWxsIHJvZGVudHMgKHZvbGVzKSBpbiBGaW5sYW5kLiBUaGUgaHlwb3RoZXNpcyB3YXMgdGhhdCBtaW5rIHByZXkgdXBvbiB2b2xlcyB0aGVyZWJ5IHJlZHVjaW5nIHZvbGUgbnVtYmVycyBhbmQgbGltaXRpbmcgdGhlaXIgcG9wdWxhdGlvbiBzaXplLiBUbyB0ZXN0IHRoaXMsIG1pbmtzIHdlcmUgcmVtb3ZlZCBmcm9tIGxhcmdlIGFyZWFzICg+IDIwIGttMikgaW4gdGhlIEJhbHRpYyBTZWEuIFRoZSBIbyBmcm9tIHRoZSBleHBlcmltZW50IGlzIHRoYXQgdGhlIG1lYW4gY291bnQgb2Ygdm9sZXMgb24gaXNsYW5kcyBpbiByZW1vdmFsIHNpdGVzIHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhlIG1lYW4gdm9sZSBjb3VudCBvbiBpc2xhbmRzIGluIGNvbnRyb2wgYXJlYXMuIA0KVGhlIGRhdGEgcmVwcmVzZW50IHR3byB0cmVhdG1lbnRzIChtaW5rIHJlbW92YWwgYW5kIGNvbnRyb2wpIGFuZCB0d28gYXJlYXMgbmVzdGVkIHdpdGhpbiBlYWNoIHRyZWF0bWVudC4gVGhlbiB0aGVyZSBhcmUgMTAgc2FtcGxlcyBpbiBlYWNoIGFyZWEuIEVhY2ggb2YgdGhlc2Ugc2FtcGxlcyByZXByZXNlbnRzIHRoZSBudW1iZXJzIG9mIGluZGl2aWR1YWwgdm9sZXMgdHJhcHBlZCBvbiBhbiBpc2xhbmQgKGFsbCBpc2xhbmRzIHdlcmUgbW9yZSB0aGFuIDMwMCBtIGFwYXJ0IGVuc3VyaW5nIHNvbWUgaW5kZXBlbmRlbmNlKSBvdmVyIDQgbmlnaHRzLg0KDQpUaGUgZGVzaWduIGlzIG5lc3RlZCBiZWNhdXNlIGFuIGFyZWEgY2Fubm90IGJlbG9uZyB0byBib3RoIGEgcmVtb3ZhbCB0cmVhdG1lbnQgYW5kIGEgY29udHJvbC4gSXQgaXMgdXNlZnVsIHRvIHRoaW5rIG9mIGFyZWFzIGFzIGJlaW5nIHRoZSByZXBsaWNhdGVzIGZvciB0aGUgdHJlYXRtZW50LCBhbmQgdGhlIGluZGl2aWR1YWwgc2FtcGxlcyBhcyBiZWluZyByZXBsaWNhdGVzIGZvciBlYWNoIGFyZWEuDQoNCiMjIyBSdW5uaW5nIHRoZSBhbmFseXNpcw0KDQoNCmBgYHtyfQ0KIyBJbnB1dCBkYXRhIGZpbGUgYW5kIGNoZWNrIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGRhdGENCm1pbmsgPC0gcmVhZC5jc3YoZmlsZSA9ICJkYXRhL21pbmsuY3N2IiwgaGVhZGVyID0gVFJVRSkNCiMgZ3JvdXBlZCBib3hwbG90DQpnZ3Bsb3QobWluaywgYWVzKHg9VHJlYXRtZW50LCB5PVZvbGVzLCBmaWxsPUFyZWEpKSArIA0KICAgIGdlb21fYm94cGxvdCgpDQpgYGANCg0KYGBge3J9DQpNaW5rLm5lc3RlZCA8LSBhb3YoVm9sZXMgfiBUcmVhdG1lbnQgKyBBcmVhICVpbiUgVHJlYXRtZW50LCBkYXRhID0gbWluaykNCnN1bW1hcnkoTWluay5uZXN0ZWQpDQpgYGANClRoZSBvdXRwdXQgaXMgYSBsaXR0bGUgZGlmZmVyZW50IHRvIHRoZSBmYWN0b3JpYWwgQU5PVkEuIFRoZSB0b3Agc2VjdGlvbiBnaXZlcyBhIHNpZ25pZmljYW5jZSB0ZXN0IG9mIHRoZSBmaXhlZCBlZmZlY3QsIFRyZWF0bWVudCwgLSB0aGlzIGlzIHdoYXQgd2XigJlyZSBpbnRlcmVzdGVkIGluLiBUaGUgcmVzaWR1YWxzIGZvciB0aGlzIHRlc3QgYXJlIHRob3NlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmFuZG9tIGVmZmVjdCDigJhBcmVh4oCZLg0KDQpBIHNpZ25pZmljYW50IEYtcmF0aW8gKFA8MC4wNSkgZm9yIGEgbmVzdGVkIGZhY3RvciBpbmRpY2F0ZXMgaGlnaCB2YXJpYW5jZSBhbW9uZyBzdWJncm91cHMgd2l0aGluIGEgZ3JvdXAuIEZvciBleGFtcGxlLCBhIGRpZmZlcmVuY2UgaW4gbWVhbiB2b2xlIG51bWJlcnMgb2YgdGhlIHR3byBhcmVhcyB3aXRoaW4gYSB0cmVhdG1lbnQuIFRoaXMgaXMgZXhwZWN0ZWQsIGhvd2V2ZXIsIGxlYWRzIHRvIGZldyBkZWdyZWVzIG9mIGZyZWVkb20gdG8gdGVzdCBtYWluIGVmZmVjdHMuIEFkZGl0aW9uYWxseSwgaXQgc3VnZ2VzdHMgdHJlYXRtZW50cyBtYXkgbm90IGhhdmUgYSB1bmlmb3JtIGVmZmVjdCBhY3Jvc3MgbGV2ZWxzIG9mIHRoZSBuZXN0ZWQgZmFjdG9yLiBGb3IgZXhhbXBsZSwgdm9sZXMgaW4gb25lIHJlbW92YWwgYXJlYSBzaG93ZWQgYSBzdHJvbmdlciByZXNwb25zZSB0aGFuIGFub3RoZXIgYXJlYS4NCg0KKipGLXJhdGlvcyoqDQoNCi0gQW1vbmcgZ3JvdXBzID0gTVNhbW9uZy9NU3N1Ymdyb3VwDQotIEZhY3RvciBCID0gTVNzdWJncm91cC9NU1Jlc2lkdWFsDQoNCioqRGVncmVlcyBvZiBmcmVlZG9tKioNCg0KLSBBbW9uZyBncm91cHMgPSAoYSAtIDEpICh3aGVyZSBhID0gbnVtYmVyIG9mIGxldmVscyBvZiBGYWN0b3IgQSkNCi0gQW1vbmcgc3ViZ3JvdXBzID0gYShiIC0gMSkgKHdoZXJlIGIgPSBudW1iZXIgb2YgbGV2ZWxzIG9mIEZhY3RvciBCKQ0KLSBXaXRoaW4gc3ViZ3JvdXBzID0gYWIobiAtIDEpICh3aGVyZSBuID0gc2FtcGxlIHNpemUpDQoNCldoZXJlIHRoZXJlIGFyZSBncmVhdGVyIHRoYW4gMiBsZXZlbHMgb2YgdGhlIHRoZSBmaXhlZCBmYWN0b3Igb2YgaW50ZXJlc3QsICpwb3N0LWhvYyogYW5hbHlzaXMgY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGdyb3VwcyBkaWZmZXIuDQoNCioqUG9vbGluZyoqIEFsd2F5cyBleGFtaW5lIG5lc3RlZCBmYWN0b3JzIGJlZm9yZSB0aGUgdXBwZXIgbGV2ZWxzLiBJZiB0aGUgdmFyaWFuY2UgZXhwbGFpbmVkIGJ5IHRoZSBuZXN0ZWQgZmFjdG9yIGlzIG5lZ2xpZ2libGUsIGl0IGNhbiBiZSBwb29sZWQuIElmIHRoZSBGIHJhdGlvIG9mIE1Tc3ViZ3JvdXAvTVN3aXRoaW4gaXMgbm9uIHNpZ25pZmljYW50IHRoZW4geW91IGRvbuKAmXQgbmVlZCBzdWJncm91cHMgYW5kIGNhbiBwZXJmb3JtIGEgb25lIGZhY3RvciBhbmFseXNpcy4NCg0KRXZlbiBpZiBNU3N1Ymdyb3VwL01Td2l0aGluIGlzIG5vbi1zaWduaWZpY2FudCBhdCBhID0gMC4wNSwgdGhlcmUgbWF5IGJlIHN1Ymdyb3VwIGVmZmVjdHMgKG1heSBiZSBoaWdoIFR5cGUgSUkgZXJyb3IpLiBUbyBiZSBjYXV0aW91cywgb25seSBwb29sIFNTIHdoZW4gUD4+PjAuMDUsIHNvIHRoZXJlIGlzIHZlcnkgbGl0dGxlIGNoYW5jZSB0aGF0IHlvdSBhcmUgaW5jb3JyZWN0bHkgYWNjZXB0aW5nIHRoZSBudWxsIGh5cG90aGVzaXMgb2Ygbm8gZWZmZWN0Lg0KDQojIyMgQXNzdW1wdGlvbnMNCg0KVGhlIHNhbWUgYXNzdW1wdGlvbnMgb2YgbGluZWFyIG1vZGVscyBhcHBseSB0byBuZXN0ZWQgQU5PVkHigJlzOyAqKmluZGVwZW5kZW5jZSoqLCAqKm5vcm1hbGl0eSoqIGFuZCAqKmhldGVyb2dlbmVpdHkqKiBvZiB2YXJpYW5jZXMuIEJlY2F1c2UgdGVzdHMgb2YgdGhlIGZpeGVkIGZhY3RvciBBIHVzZXMgdXNlcyB0aGUgbWVhbnMgb2YgdGhlIG5lc3RlZCBGYWN0b3IgQiwgdGhlIGFzc3VtcHRpb25zIG9mIGhvbW9nZW5laXR5IGFuZCBub3JtYWxpdHkgYXBwbHkgd2l0aCByZXNwZWN0IHRvIHRoZSBtZWFucyBvZiBGYWN0b3IgQi4gDQoNCj4gKlNvdXJjZTogSmFtZXMgTGF2ZW5kZXIgJiBBbGlzdGFpciBQb29yZSoNCg0KIyBHTE1zDQoNCkdlbmVyYWxpc2VkIGxpbmVhciBtb2RlbHMgKEdMTXMpIGFyZSB1c2VkIHdoZW4gdGhlIGRpc3RyaWJ1dGlvbiBvZiBkYXRhIGRvIG5vdCBjb25mb3JtIHRvIHRoZSBhc3N1bXB0aW9ucyBvZiBsaW5lYXIgbW9kZWxzLCBzcGVjaWZpY2FsbHkgdGhlIGFzc3VtcHRpb25zIG9mIG5vcm1hbGx5IGRpc3RyaWJ1dGVkIHJlc2lkdWFscyBhbmQgbm8gcmVsYXRpb25zaGlwIGJldHdlZW4gdGhlIHZhcmlhbmNlIGFuZCB0aGUgbWVhbiAoZS5nLiwgcHJlc2VuY2UvYWJzZW5jZSwgY291bnQgb3IgaGlnaGx5IHNrZXdlZCBkYXRhKS4NCg0KIyMgSW50cm9kdWN0aW9uDQoNCkxpbmVhciBtb2RlbHMgKGUuZy4sIGxpbmVhciByZWdyZXNzaW9uKSBhcmUgdXNlZCB0byBtb2RlbCB0aGUgcmVsYXRpb25zaGlwIGJldHdlZW4gYSAqKmNvbnRpbnVvdXMqKiByZXNwb25zZSB2YXJpYWJsZSAkeSQgYW5kIG9uZSBvciBtb3JlIGV4cGxhbmF0b3J5IHZhcmlhYmxlcyAkeF8xLHhfMiwuLi4kLiBXaGVuIHdlIGhhdmUgYSAqKmRpc2NyZXRlKiogcmVzcG9uc2Ugd2UgdXNlIEdMTXMuIA0KDQoqKlByb3BlcnRpZXMgb2YgR0xN4oCZcyoqIERpc2NyZXRlIHJlc3BvbnNlIGRhdGEsIGxpa2UgY291bnRzIGFuZCBwcmVzZW5jZS9hYnNlbmNlIGRhdGEsIGdlbmVyYWxseSBleGhpYml0IGEgbWVhbi12YXJpYW5jZSByZWxhdGlvbnNoaXAuIEZvciBleGFtcGxlOyBmb3IgY291bnRzIHRoYXQgYXJlIG9uIGF2ZXJhZ2UgNSwgd2Ugd291bGQgZXhwZWN0IG1vc3Qgc2FtcGxlcyB0byBiZSBiZXR3ZWVuIGFib3V0IDEgYW5kIDksIGJ1dCBmb3IgY291bnRzIHRoYXQgYXJlIG9uIGF2ZXJhZ2UgNTAwLCBtb3N0IG9mIHRoZSBvYnNlcnZhdGlvbnMgd2lsbCB0ZW5kIHRvIGJlIGJldHdlZW4gNDUwIGFuZCA1NTAsIGdpdmluZyB1cyBhIG11Y2ggbGFyZ2VyIHZhcmlhbmNlIHdoZW4gdGhlIG1lYW4gaXMgbGFyZ2UuIEluIGNvbnRyYXN0LCBhcyB3ZSBrbm93IGl0IGFscmVhZHksIGxpbmVhciBtb2RlbHMgYXNzdW1lIGNvbnN0YW50IHZhcmlhbmNlLiBZb3UgbWlnaHQgdHJhbnNmb3JtIGNvdW50IGRhdGEgYW5kICBmaXQgYSBsaW5lYXIgbW9kZWwuIFRoaXMgY2FuIHJlZHVjZSB0aGUgbWVhbiB2YXJpYW5jZSByZWxhdGlvbnNoaXAsIGJ1dCBpdCB3b27igJl0IGdldCByaWQgb2YgaXQgY29tcGxldGVseSwgZXNwZWNpYWxseSBpZiB5b3UgaGF2ZSBhIGxvdCBvZiB6ZXJvcyBpbiB5b3VyIGRhdGEuIFRvIGFuYWx5c2UgZGlzY3JldGUgZGF0YSBhY2N1cmF0ZWx5IHdlIG5lZWQgdG8gdXNlIEdMTeKAmXMuDQoNCg0KDQpBIEdMTSBtYWtlcyBzb21lIGltcG9ydGFudCBhc3N1bXB0aW9ucyAod2XigJlsbCBjaGVjayB0aGVzZSBsYXRlciBmb3Igb3VyIGV4YW1wbGVzKToNCg0KMS4gVGhlIG9ic2VydmVkICR5JCBhcmUgaW5kZXBlbmRlbnQsIGNvbmRpdGlvbmFsIG9uIHNvbWUgcHJlZGljdG9ycyAkeCQNCjIuIFRoZSByZXNwb25zZSAkeSQgY29tZSBmcm9tIGEga25vd24gZGlzdHJpYnV0aW9uIHdpdGggYSBrbm93biBtZWFuLXZhcmlhbmNlIHJlbGF0aW9uc2hpcA0KMy4gVGhlcmUgaXMgYSBzdHJhaWdodCBsaW5lIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIGEga25vd24gZnVuY3Rpb24gJGckIG9mIHRoZSBtZWFuIG9mICR5JCBhbmQgdGhlIHByZWRpY3RvcnMgJHgkDQoNCiRnKFxtdV95KT1cYWxwaGErXGJldGFfMXhfMStcYmV0YV8yeF8yKy4uLiQNCg0KDQpOb3RlOiBsaW5rIGZ1bmN0aW9ucyBgZygpYCBhcmUgYW4gaW1wb3J0YW50IHBhcnQgb2YgZml0dGluZyBHTE3igJlzLCBidXQgYmV5b25kIHRoZSBzY29wZSBvZiB0aGlzIGludHJvZHVjdG9yeSB0dXRvcmlhbC4gQWxsIHlvdSBuZWVkIHRvIGtub3cgaXMgdGhhdCB0aGUgZGVmYXVsdCBsaW5rIGZvciBiaW5vbWlhbCBkYXRhIGlzIHRoZSBgbG9naXQoKWAgYW5kIGZvciBjb3VudCBkYXRhIGl04oCZcyBgbG9nKClgLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWUgYD9mYW1pbHlgLg0KDQojIyBCaW5vbWlhbCBleGFtcGxlDQoNCklmIGhhZCBzdXJ2ZXllZCBhIGJlYWNoIGFuZCB3YW50ZWQgdG8gYW5hbHlzZSBob3cgdGhlIHByZXNlbmNlIG9mIGEgY3JhYiB2YXJpZWQgd2l0aCB0aW1lIGFuZCBkaXN0YW5jZSBmcm9tIHRoZSB3YXRlciBsaW5lLCB0aGUgcmVzcG9uc2UgdmFyaWFibGUgaXMgZGlzY3JldGU6IHRoZSBwcmVzZW5jZSBvciBhYnNlbmNlIG9mIGEgY3JhYiBpbiBhIGdpdmVuIHJlcGxpY2F0ZS4gVGhlIGZpcnN0IGZldyByb3dzIG9mIHRoZSBkYXRhIHNldCB3b3VsZCBsb29rIGxpa2UgdGhpczoNCg0KYGBge3J9DQpDcmFiX1BBIDwtIHJlYWQuY3N2KCJkYXRhL2NyYWJzLmNzdiIsIGhlYWRlciA9IFQpDQpoZWFkKENyYWJfUEEpDQpgYGANCg0KIyMjIFJ1bm5pbmcgdGhlIGFuYWx5c2lzDQoNCg0KVGhlIHZhcmlhYmxlIGBDcmFiUHJlc2AgY29udGFpbnMgYmlub21pYWwgZGF0YSwgaS5lLiBwcmVzZW5jZS9hYnNlbmNlIGRhdGEgb3IgZGF0YSBhcyAwLzEuRml0dGluZyBhIEdMTSB1c2VzIGEgdmVyeSBzaW1pbGFyIHN5bnRheCB0byBmaXR0aW5nIGxpbmVhciBtb2RlbHMgYnV0IHdlIHVzZSB0aGUgYGdsbWAgZnVuY3Rpb24gaW5zdGVhZCBvZiBgbG1gLiBXZSBhbHNvIG5lZWQgdG8gaW5kaWNhdGUgdGhlIGBmYW1pbHlgIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBmdW5jdGlvbi4gVG8gdGVzdCB3aGV0aGVyIHRoZSBwcm9iYWJpbGl0eSBvZiBjcmFiIHByZXNlbmNlIGNoYW5nZXMgd2l0aCB0aW1lIChhIGZhY3RvcikgYW5kIGRpc3RhbmNlIChhIGNvbnRpbnVvdXMgdmFyaWFibGUpLCB3ZSBmaXQgdGhlIGZvbGxvd2luZyBtb2RlbC4gVGhlIHJlc3BvbnNlIHZhcmlhYmxlIChwcmVzZW5jZS9hYnNlbmNlIG9mIGNyYWJzKSBpcyBiaW5vbWlhbCwgc28gd2UgdXNlIGBmYW1pbHk9Ymlub21pYWxgLg0KDQpgYGB7cn0NCmZ0LmNyYWIgPC0gZ2xtKENyYWJQcmVzIH4gVGltZSAqIERpc3QsIGZhbWlseSA9IGJpbm9taWFsLCBkYXRhID0gQ3JhYl9QQSkNCmBgYA0KDQojIyMgQXNzdW1wdGlvbnMNCg0KQmVmb3JlIHdlIGxvb2sgYXQgdGhlIHJlc3VsdHMgb2Ygb3VyIGFuYWx5c2lzIGl04oCZcyBpbXBvcnRhbnQgdG8gY2hlY2sgdGhhdCBvdXIgZGF0YSBtZXQgdGhlIGFzc3VtcHRpb25zIG9mIHRoZSBtb2RlbCB3ZSB1c2VkLiBMZXTigJlzIGxvb2sgYXQgYWxsIHRoZSBhc3N1bXB0aW9ucyBpbiBvcmRlci4NCg0KKipBc3N1bXB0aW9uIDEgOiBUaGUgb2JzZXJ2ZWQgJHkkIGFyZSBpbmRlcGVuZGVudCwgY29uZGl0aW9uYWwgb24gc29tZSBwcmVkaWN0b3JzICR4JCoqDQoNCldlIGNhbuKAmXQgY2hlY2sgdGhpcyBhc3N1bXB0aW9uIGZyb20gdGhlIHJlc3VsdHMsIGJ1dCB5b3UgY2FuIGVuc3VyZSBpdOKAmXMgdHJ1ZSBieSB0YWtpbmcgYSByYW5kb20gc2FtcGxlIGZvciB5b3VyIGV4cGVyaW1lbnRhbCBkZXNpZ24uIElmIHlvdXIgZXhwZXJpbWVudGFsIGRlc2lnbiBpbnZvbHZlcyBhbnkgcHNldWRvLXJlcGxpY2F0aW9uLCB0aGlzIGFzc3VtcHRpb24gd2lsbCBiZSB2aW9sYXRlZC4gRm9yIGNlcnRhaW4gdHlwZXMgb2YgcHNldWRvLXJlcGxpY2F0aW9uIHlvdSBjYW4gdXNlIG1peGVkIG1vZGVscyBpbnN0ZWFkLg0KDQoqKkFzc3VtcHRpb24gMiA6IFRoZSByZXNwb25zZSAkeSQgY29tZSBmcm9tIGEga25vd24gZGlzdHJpYnV0aW9uIHdpdGggYSBrbm93biBtZWFuLXZhcmlhbmNlIHJlbGF0aW9uc2hpcCoqDQoNClRoZSBtZWFuIHZhcmlhbmNlIHJlbGF0aW9uc2hpcCBpcyB0aGUgbWFpbiByZWFzb24gd2UgdXNlIEdMTeKAmXMgaW5zdGVhZCBvZiBsaW5lYXIgbW9kZWxzLiBXZSBuZWVkIHRvIGNoZWNrIHRoYXQgdGhlIGRpc3RyaWJ1dGlvbiBtb2RlbHMgdGhlIG1lYW4tdmFyaWFuY2UgcmVsYXRpb25zaGlwIG9mIG91ciBkYXRhIHdlbGwuIEZvciBiaW5vbWlhbCBkYXRhIHRoaXMgaXMgbm90IGEgYmlnIGNvbmNlcm4sIGJ1dCBsYXRlciBvbiB3aGVuIHdlIGFuYWx5c2UgY291bnQgZGF0YSBpdOKAmWxsIGJlIHZlcnkgaW1wb3J0YW50LiBUbyBjaGVjayB0aGlzIGFzc3VtcHRpb24gd2UgbG9vayBhdCBhIHBsb3Qgb2YgcmVzaWR1YWxzLCBhbmQgdHJ5IHRvIHNlZSBpZiB0aGVyZSBpcyBhIGZhbiBzaGFwZS4NCg0KDQpgYGB7cn0NCnBsb3QoZnQuY3JhYiwgd2hpY2ggPSAxKQ0KYGBgDQoNClVuZm9ydHVuYXRlbHkgdGhlIGBnbG1gIHBsb3QgZnVuY3Rpb24gZ2l2ZXMgdXMgYSB2ZXJ5IG9kZCBsb29raW5nIHBsb3QgZHVlIHRvIHRoZSBkaXNjcmV0ZW5lc3Mgb2YgdGhlIGRhdGEgKGkuZS4sIG1hbnkgcG9pbnRzIG9uIHRvcCBvZiBlYWNoIG90aGVyKS4gRm9yIGEgbW9yZSB1c2VmdWwgcGxvdCB3ZSBjYW4gaW5zdGVhZCBmaXQgdGhlIG1vZGVsIHVzaW5nIHRoZSBgbWFueWdsbWAgZnVuY3Rpb24gaW4gdGhlIGBtdmFidW5kYCBwYWNrYWdlLiBXZSBuZWVkIGEgc2xpZ2h0IGNoYW5nZSB0byB0aGUgZmFtaWx5IGFyZ3VtZW50LCBmb3IgYG1hbnlnbG1gIHdlIHdyaXRlIGBmYW1pbHkgPSAiYmlub21pYWwiYC4NCg0KYGBge3J9DQpmdC5jcmFiLm1hbnkgPC0gbWFueWdsbShDcmFiUHJlcyB+IFRpbWUgKiBEaXN0LCBmYW1pbHkgPSAiYmlub21pYWwiLCBkYXRhID0gQ3JhYl9QQSkNCnBsb3QoZnQuY3JhYi5tYW55KQ0KYGBgDQoNCk5vdyB3ZSBjYW4gbG9vayBmb3IgYSBmYW4gc2hhcGUgaW4gdGhlIHJlc2lkdWFsIHBsb3QuIEZvciB0aGVzZSBkYXRhLCB0aGVyZSBkb2VzbuKAmXQgc2VlbSB0byBiZSBhIGZhbiBzaGFwZSwgc28gd2UgY2FuIGNvbmNsdWRlIHRoZSBtZWFuLXZhcmlhbmNlIGFzc3VtcHRpb24gdGhlIG1vZGVsIG1hZGUgd2FzIHJlYXNvbmFibGUgZm9yIG91ciBkYXRhLiBUaGUgcmVzaWR1YWxzIGluIHRoaXMgcGxvdCBoYXZlIGEgcmFuZG9tIGNvbXBvbmVudC4gSWYgeW91IHNlZSBhIHBhdHRlcm4gaXTigJlzIGJlc3QgdG8gcmVwZWF0IHRoZSBwbG90IGEgZmV3IHRpbWVzIHRvIHNlZSBpZiB0aGUgcGF0dGVybiBpcyByZWFsLg0KDQoNCioqQXNzdW1wdGlvbiAzIDogVGhlcmUgaXMgYSBzdHJhaWdodCBsaW5lIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIGEga25vd24gZnVuY3Rpb24gJGckIG9mIHRoZSBtZWFuICR5JCAgYW5kIGhlIHByZWRpY3RvciAkeCQqKg0KDQpUbyBjaGVjayB0aGlzIGFzc3VtcHRpb24sIHdlIGNoZWNrIHRoZSByZXNpZHVhbCBwbG90IGFib3ZlIGZvciBub24tbGluZWFyaXR5LCBvciBhIFUtc2hhcGUuIEluIG91ciBjYXNlIHRoZXJlIGlzIG5vIGV2aWRlbmNlIG9mIG5vbi1saW5lYXJpdHkuIElmIHRoZSByZXNpZHVhbHMgc2VlbSB0byBnbyBkb3duIHRoZW4gdXAsIG9yIHVwIHRoZW4gZG93biwgd2UgbWF5IG5lZWQgdG8gYWRkIGEgcG9seW5vbWlhbCBmdW5jdGlvbiBvZiB0aGUgcHJlZGljdG9ycyB1c2luZyB0aGUgYHBvbHlgIGZ1bmN0aW9uLg0KDQoNCiMjIyBJbnRlcnByZXRpbmcNCg0KSWYgYWxsIHRoZSBhc3N1bXB0aW9uIGNoZWNrcyBhcmUgb2theSwgd2UgY2FuIGhhdmUgYSBsb29rIGF0IHRoZSByZXN1bHRzIHRoZSBtb2RlbCBnYXZlIHVzLiBUaGUgdHdvIG1haW4gZnVuY3Rpb25zIGZvciBpbmZlcmVuY2UgYXJlIHRoZSBzYW1lIGFzIGZvciBsaW5lYXIgbW9kZWxzOiBgc3VtbWFyeWAgYW5kIGBhbm92YWAuDQoNClRoZSBwLXZhbHVlcyB0aGVzZSBnaXZlIHlvdSBpZiB5b3UgdXNlIGBnbG1gIGZvciBmaXR0aW5nIHRoZSBtb2RlbCB3b3JrIHdlbGwgaW4gbGFyZ2Ugc2FtcGxlcywgYWx0aG91Z2ggdGhleSBhcmUgc3RpbGwgYXBwcm94aW1hdGUuIEZvciBiaW5vbWlhbCBtb2RlbHMgaW4gcGFydGljdWxhciB0aGUgcC12YWx1ZXMgZnJvbSB0aGUgYHN1bW1hcnlgIGZ1bmN0aW9uIGNhbiBiZSBmdW5ueSwgYW5kIHdlIHByZWZlciB0byB1c2UgdGhlIGBhbm92YWAgZnVuY3Rpb24gdG8gc2VlIGlmIHByZWRpY3RvcnMgYXJlIHNpZ25pZmljYW50LiBUaGUgYHN1bW1hcnkoKWAgZnVuY3Rpb24gaXMgc3RpbGwgdXNlZnVsIHRvIGxvb2sgYXQgdGhlIG1vZGVsIGVxdWF0aW9uLg0KDQpgYGB7cn0NCmFub3ZhKGZ0LmNyYWIsIHRlc3QgPSAiQ2hpc3EiKQ0KYGBgDQpUaGUgcC12YWx1ZSBmb3IgKlRpbWUqIGlzIHNtYWxsIChQPDAuMDEpLCBzbyB3ZSBjb25jbHVkZSB0aGVyZSBpcyBhbiBlZmZlY3Qgb2YgdGltZSBvbiB0aGUgcHJlc2VuY2Ugb2YgY3JhYnMsIGJ1dCBubyBlZmZlY3Qgb2YgZGlzdGFuY2Ugb3IgYW4gaW50ZXJhY3Rpb24gYmV0d2VlbiB0aW1lIGFuZCBkaXN0YW5jZS4gVGhpcyBzYW1wbGUgaXMgcmVhc29uYWJseSBsYXJnZSwgc28gdGhlc2UgcC12YWx1ZXMgc2hvdWxkIGJlIGEgZ29vZCBhcHByb3hpbWF0aW9uLiBGb3IgYSBzbWFsbCBzYW1wbGUgaXQgaXMgb2Z0ZW4gYmV0dGVyIHRvIHVzZSByZXNhbXBsaW5nIHRvIGNhbGN1bGF0ZSBwLXZhbHVlcy4gV2hlbiB5b3UgdXNlIGBtYW55Z2xtYCB0aGUgc3VtbWFyeSBhbmQgYW5vdmEgZnVuY3Rpb25zIHVzZSByZXNhbXBsaW5nIGJ5IGRlZmF1bHQuDQoNCg0KYGBge3J9DQphbm92YShmdC5jcmFiLm1hbnkpDQpgYGANCkluIHRoaXMgY2FzZSB0aGUgcmVzdWx0cyBhcmUgcXVpdGUgc2ltaWxhciwgYnV0IGluIHNtYWxsIHNhbXBsZXMgaXQgY2FuIG9mdGVuIG1ha2UgYSBiaWcgZGlmZmVyZW5jZS4NCg0KWW91IGNhbiBhbHNvIHVzZSBgc3VtbWFyeWAgd2l0aCBlaXRoZXIgdGhlIGBnbG1gIG9yIGBtYW55Z2xtYCBmdW5jdGlvbi4gVGhpcyBpcyBpbnRlcnByZXRlZCBpbiBhIHNpbWlsYXIgbWFubmVyIGFzIGZvciBsaW5lYXIgcmVncmVzc2lvbiwgYnV0IHdlIG5lZWQgdG8gaW5jbHVkZSB0aGUgbGluayBmdW5jdGlvbiwgYGdgLg0KDQpgYGB7cn0NCnN1bW1hcnkoZnQuY3JhYikNCmBgYA0KDQpJZiAkcCQgaXMgdGhlIHByb2JhYmlsaXR5IG9mIGNyYWIgcHJlc2VuY2UsIHRoaXMgb3V0cHV0IHRlbGxzIHVzOg0KDQokbG9naXQocCkgPSAtMy4wMSArIDAuMjYgKiBUaW1lIC0gMC4wMyAqIERpc3QgKyAwLjAxICogVGltZSAqIERpc3QkDQoNCg0KKipDb25jbHVzaW9uOioqICBXZSB1c2VkIGEgYmlub21pYWwgbGluZWFyIG1vZGVsIGJlY2F1c2Ugb2YgYmluYXJ5IGRhdGEgKHByZXNlbmNlL2Fic2NlbmNlKSBvZiBjcmFicy4gSW5mZXJlbmNlIHdhcyBjYXJyaWVkIG91dCB1c2luZyBib290c3RyYXAgcmVzYW1wbGluZyB3aXRoIDEwMDAgcmVzYW1wbGVzIChkZWZhdWx0IHdoZW4gdXNpbmcgbWFueWdsbSkuIFRoZXJlIGlzIHN0cm9uZyBldmlkZW5jZSB0aGF0IHRoZSBwcmVzZW5jZSBvZiBjcmFicyB2YXJpZXMgd2l0aCB0aW1lIChwID0gMC4wMSkuIE5vdGUgdGhhdCBmb3IgbXVsdGlwbGUgcHJlZGljdG9ycyBpdOKAmXMgYmVzdCB0byBkaXNwbGF5IHRoZSByZXN1bHRzIGluIGEgdGFibGUuDQoNCiMjIFBvaXNzb24gZXhhbXBsZQ0KDQpGb3IgdGhpcyB3b3JrZWQgZXhhbXBsZSwgd2UgaGF2ZSBjb3VudHMgb2YgZGlmZmVyZW50IGFuaW1hbCBncm91cHMgYXQgY29udHJvbCBzaXRlcyBhbmQgc2l0ZXMgd2hlcmUgYnVzaCByZWdlbmVyYXRpb24gaGFzIGJlZW4gY2FycmllZCBvdXQgKHRyZWF0bWVudCkuIFdlIHdhbnQgdG8ga25vdyBpZiB0aGUgdGhlIGJ1c2ggcmVnZW5lcmF0aW9uIGFjdGl2aXRpZXMgaGF2ZSBhZmZlY3RlZCB0aGUgY291bnQgb2Ygc2x1Z3MuDQoNCmBgYHtyfQ0KUmV2ZWcgPC0gcmVhZC5jc3YoImRhdGEvcmV2ZWdldGF0aW9uLmNzdiIsIGhlYWRlciA9IFQpDQpoZWFkKFJldmVnKQ0KYGBgDQpJZiB5b3UgdmlldyB0aGUgZnJlcXVlbmN5IGhpc3RvZ3JhbSBvZiB0aGUgc2x1ZyBjb3VudHMsIHlvdSB3aWxsIHNlZSB0aGF0IGl0IGlzIHZlcnkgc2tld2VkLCB3aXRoIG1hbnkgc21hbGwgdmFsdWVzIGFuZCBmZXcgbGFyZ2UgY291bnRzICh0aGUgdmFyaWFibGUgbmFtZSwgU29sZW9saWZlcmEsIGlzIHRoZSBvcmRlciBuYW1lIG9mIHRlcnJlc3RyaWFsIHNsdWdzKS4NCg0KDQpgYGB7cn0NCmhpc3QoUmV2ZWckU29sZW9saWZlcmEpDQpgYGANCg0KVGhlIGRlZmF1bHQgZGlzdHJpYnV0aW9uIGZvciBjb3VudCBkYXRhIGlzIHRoZSBQb2lzc29uLiBUaGUgUG9pc3NvbiBkaXN0cmlidXRpb24gYXNzdW1lcyB0aGUgdmFyaWFuY2UgZXF1YWxzIHRoZSBtZWFuLiBUaGlzIGlzIHF1aXRlIGEgcmVzdHJpY3RpdmUgYXNzdW1wdGlvbiB3aGljaCBlY29sb2dpY2FsIGNvdW50IGRhdGEgb2Z0ZW4gdmlvbGF0ZS4gV2UgbWF5IG5lZWQgdG8gdXNlIHRoZSBtb3JlIGZsZXhpYmxlIG5lZ2F0aXZlLWJpbm9taWFsIGRpc3RyaWJ1dGlvbiBpbnN0ZWFkLg0KDQojIyMgUnVubmluZyB0aGUgYW5hbHlzaXMNCg0KV2UgY2FuIHVzZSBhIEdMTSB0byB0ZXN0IHdoZXRoZXIgdGhlIGNvdW50cyBvZiBzbHVncyAoZnJvbSB0aGUgb3JkZXIgU29sZW9saWZlcmEpIGRpZmZlciBiZXR3ZWVuIGNvbnRyb2wgYW5kIHJlZ2VuZXJhdGVkIHNpdGVzLiBUbyBmaXQgdGhlIEdMTSwgd2Ugd2lsbCB1c2UgdGhlIGBtYW55Z2xtYCBmdW5jdGlvbiBpbnN0ZWFkIG9mIGBnbG1gIHNvIHdlIGhhdmUgYWNjZXNzIHRvIG1vcmUgdXNlZnVsIHJlc2lkdWFsIHBsb3RzLg0KDQoNCmBgYHtyfQ0KZnQuc29sLnBvaXMgPC0gbWFueWdsbShTb2xlb2xpZmVyYSB+IFRyZWF0bWVudCwgZmFtaWx5ID0gInBvaXNzb24iLCBkYXRhID0gUmV2ZWcpDQpgYGANCg0Kd2hlcmUgU29sZW9saWZlcmEgaXMgdGhlIHJlc3BvbnNlIHZhcmlhYmxlLCBhbmQgVHJlYXRtZW50IGlzIHRoZSBwcmVkaWN0b3IgdmFyaWFibGUgKHdpdGggdHdvIGxldmVscywgY29udHJvbCBhbmQgcmV2ZWdldGF0ZWQpLg0KDQoNCiMjIyBBc3N1bXB0aW9ucw0KDQpCZWZvcmUgd2UgbG9vayBhdCB0aGUgcmVzdWx0cywgd2UgbmVlZCB0byBsb29rIGF0IHRoZSByZXNpZHVhbCBwbG90IHRvIGNoZWNrIHRoZSBhc3N1bXB0aW9uDQoNCmBgYHtyLCB3YXJuaW5nID0gRn0NCnBsb3QoZnQuc29sLnBvaXMpDQpgYGANCg0KSXTigJlzIGhhcmQgdG8gc2F5IHdoZXRoZXIgdGhlcmUgaXMgYW55IG5vbi1saW5lYXJpdHkgaW4gdGhpcyBwbG90LCB0aGlzIGlzIGJlY2F1c2UgdGhlIHByZWRpY3RvciBpcyBiaW5hcnkgKHRyZWF0bWVudCB2cyByZXZlZ2V0YXRlZCkuIExvb2tpbmcgYXQgdGhlIHZhcmlhbmNlIGFzc3VtcHRpb24sIGl0IGRvZXMgYXBwZWFyIGFzIHRob3VnaCB0aGVyZSBpcyBhIGZhbiBzaGFwZS4gVGhlIHJlc2lkdWFscyBhcmUgbW9yZSBzcHJlYWQgb3V0IG9uIHRoZSByaWdodCB0aGFuIHRoZSBsZWZ0IC0gd2UgY2FsbCB0aGlzIG92ZXJkaXNwZXJzaW9uLg0KDQpUaGlzIHRlbGxzIHVzIHRoZSB2YXJpYW5jZSBhc3N1bXB0aW9uIG9mIHRoZSBQb2lzc29uIG1heSBiZSB0b28gcmVzdHJpY3RpdmUgYW5kIHdlIHNob3VsZCB0cnkgYSBkaWZmZXJlbnQgZGlzdHJpYnV0aW9uLiBXZSBjYW4gaW5zdGVhZCBmaXQgYSBuZWdhdGl2ZS1iaW5vbWlhbCBkaXN0cmlidXRpb24gaW4gYG1hbnlnbG1gIGJ5IGNoYW5naW5nIHRoZSBmYW1pbHkgYXJndW1lbnQgdG8gYGZhbWlseT0ibmVnYXRpdmUgYmlub21pYWwiYC4NCg0KYGBge3J9DQpmdC5zb2wubmIgPC0gbWFueWdsbShTb2xlb2xpZmVyYSB+IFRyZWF0bWVudCwgZmFtaWx5ID0gIm5lZ2F0aXZlIGJpbm9taWFsZSIsIGRhdGEgPSBSZXZlZykNCmBgYA0KDQpMb29rIGFnYWluIGF0IHRoZSByZXNpZHVhbCBwbG90Og0KDQpgYGB7ciwgd2FybmluZyA9IEZ9DQpwbG90KGZ0LnNvbC5uYikNCmBgYA0KDQpUaGlzIHNlZW1zIHRvIGhhdmUgaW1wcm92ZWQgdGhlIHJlc2lkdWFsIHBsb3QuIFRoZXJlIGlzIG5vIGxvbmdlciBhIHN0cm9uZyBmYW4gc2hhcGUsIHNvIHdlIGNhbiBnbyBhaGVhZCBhbmQgbG9vayBhdCB0aGUgcmVzdWx0cy4NCg0KDQojIyMgSW50ZXJwcmV0aW5nDQoNCg0KYGBge3J9DQphbm92YShmdC5zb2wubmIpDQpgYGANCmBgYHtyfQ0Kc3VtbWFyeShmdC5zb2wubmIpDQpgYGANCkJvdGggaW5kaWNhdGUgc3Ryb25nIGV2aWRlbmNlIG9mIGEgdHJlYXRtZW50IGVmZmVjdCAocDwwLjAxKS4gVG8gZXh0cmFjdCB0aGUgbW9kZWwgZXF1YXRpb24gd2UgY2FuIGxvb2sgYXQgdGhlIGNvZWZmaWNpZW50cyBmcm9tIHRoZSBmaXQuDQoNCmBgYHtyfQ0KZnQuc29sLm5iJGNvZWZmaWNpZW50cw0KYGBgDQoNClRoZSBkZWZhdWx0IGxpbmsgZnVuY3Rpb24gZm9yIFBvaXNzb24gYW5kIG5lZ2F0aXZlIGJpbm9taWFsIG1vZGVscyBpcyAkbG9nJC4gSWYgd2Ugd3JpdGUgdGhlIG1lYW4gY291bnQgYXMgJFxsYW1iZGEkDQoNCiRsb2coXGxhbWJkYSk9LTAuOTIrMi4xMiBcdGltZXMgVHJlYXRtZW50JA0KDQoqKkNvbmNsdXNpb246KiogIFdlIHVzZWQgYSBuZWdhdGl2ZS1iaW5vbWlhbCBnZW5lcmFsaXNlZCBsaW5lYXIgbW9kZWwgZHVlIHRvIG92ZXJkaXNwZXJzaW9uIGV2aWRlbnQgaW4gdGhlIGRhdGEuIEluZmVyZW5jZSB3YXMgY2FycmllZCBvdXQgdXNpbmcgYm9vdHN0cmFwIHJlc2FtcGxpbmcgd2l0aCAxMDAwIHJlc2FtcGxlcyAoZGVmYXVsdCB3aGVuIHVzaW5nIG1hbnlnbG0pLiBUaGVyZSBpcyBzdHJvbmcgZXZpZGVuY2Ugb2YgcG9zaXRpdmUgZWZmZWN0IG9mIGJ1c2ggcmVnZW5lcmF0aW9uIG9uIHRoZSBhYnVuZGFuY2Ugb2Ygc2x1Z3MgZnJvbSB0aGUgb3JkZXIgU29sZW9saWZlcmEgKHAgPCAwLjAwMSkuDQoNCmBgYHtyfQ0KYm94cGxvdChTb2xlb2xpZmVyYSB+IFRyZWF0bWVudCwgeWxhYiA9ICJDb3VudCIsIHhsYWIgPSAiVHJlYXRtZW50IiwgZGF0YSA9IFJldmVnKQ0KYGBgDQo+ICpTb3VyY2U6IEdvcmRhbmEgUG9wb3ZpYyoNCg0KDQoNCiMgTWl4ZWQgbW9kZWxzDQoNCg0KDQpNaXhlZCBtb2RlbHMgYXJlIHRob3NlIHdpdGggYSBtaXh0dXJlIG9mIGZpeGVkIGFuZCByYW5kb20gZWZmZWN0cy4gUmFuZG9tIGVmZmVjdHMgYXJlIGNhdGVnb3JpY2FsIGZhY3RvcnMgd2hlcmUgdGhlIGxldmVscyBoYXZlIGJlZW4gc2VsZWN0ZWQgZnJvbSBtYW55IHBvc3NpYmxlIGxldmVscyBhbmQgdGhlIGludmVzdGlnYXRvciB3b3VsZCBsaWtlIHRvIG1ha2UgaW5mZXJlbmNlcyBiZXlvbmQganVzdCB0aGUgbGV2ZWxzIGNob3Nlbi4gVHJpY2t5IGNvbmNlcHQsIGJ1dCBpbWFnaW5lIGNvbnRyYXN0aW5nIHR3byBoYWJpdGF0IHR5cGVzIChmb3Jlc3QgYW5kIGdyYXNzbGFuZCkgYnkgc2FtcGxpbmcgZml2ZSBzaXRlcyB3aXRoaW4gZWFjaCwgYW5kIGZpdmUgcmVwbGljYXRlIG1lYXN1cmVzIHdpdGhpbiBlYWNoIHNpdGUuIEhhYml0YXQgdHlwZSBpcyBhIGZpeGVkIGZhY3RvciB3aXRoIHRoZSByZXNlYXJjaGVyIG9ubHkgaW50ZXJlc3RlZCBpbiB0aG9zZSB0d28gbGV2ZWxzIG9mIGhhYml0YXQgdHlwZS4gSWYgdGhlIGZpdmUgc2l0ZXMgd2VyZSBjaG9zZW4gZnJvbSBhIGxhcmdlciBjb2xsZWN0aW9uIG9mIHBvc3NpYmxlIHNpdGVzLCB0aGVuIHNpdGUgaXMgY29uc2lkZXJlZCBhIHJhbmRvbSBlZmZlY3Qgd2l0aCAxMCBsZXZlbHMuDQoNCllvdSB3aWxsIG5lZWQgdG8gdXNlIG1peGVkIGVmZmVjdCBtb2RlbHMgaWYgeW91IGhhdmUgYSByYW5kb20gZmFjdG9yIGluIHlvdXIgZXhwZXJpbWVudGFsIGRlc2lnbi4gQSByYW5kb20gZmFjdG9yOg0KDQotIGlzIGNhdGVnb3JpY2FsDQotIGhhcyBhIGxhcmdlIG51bWJlciBvZiBsZXZlbHMNCi0gb25seSBhIHJhbmRvbSBzdWJzYW1wbGUgb2YgbGV2ZWxzIGlzIGluY2x1ZGVkIGluIHlvdXIgZGVzaWduDQotIHlvdSB3YW50IHRvIG1ha2UgaW5mZXJlbmNlIGluIGdlbmVyYWwsIGFuZCBub3Qgb25seSBmb3IgdGhlIGxldmVscyB5b3Ugb2JzZXJ2ZWQNCg0KDQoqKkFzc3VtcHRpb25zIG9mIG1peGVkIG1vZGVscyoqDQoNCi0gVGhlIG9ic2VydmVkICR5JCBhcmUgaW5kZXBlbmRhbnQsIGNvbmRpdGlvbmFsIG9uIHNvbWUgcHJlZGljdG9yICR4JA0KLSBUaGUgcmVzcG9uc2UgJHkkIGFyZSBub3JtYWxseSBkaXN0cmlidXRlZCwgY29uZGl0aW9uYWwgb24gc29tZSBwcmVkaWN0b3JzICR4JA0KLSBUaGUgcmVzcG9uc2UgJHkkIGhhcyBjb25zdGFudCB2YXJpYW5jZSwgY29uZGl0aW9uYWwgb24gc29tZSBwcmVkaWN0b3JzICR4JA0KLSBUaGVyZSBpcyBhIHN0cmFpZ2h0IGxpbmUgcmVsYXRpb25zaGlwIGJldHdlZW4gJHkkIGFuZCB0aGUgcHJlZGljdG9ycyAkeCQgYW5kIHJhbmRvbSBlZmZlY3RzICR6JA0KLSBSYW5kb20gZWZmZWN0ICR6JCBhcmUgaW5kZXBlbmRhbnQgb2YgJHkkDQotIFJhbmRvbSBlZmZlY3QgJHokIGFyZSBub3JtYWxseSBkaXN0cmlidXRlZA0KDQoNClRoaXMgaXMgYSB0b3VnaCBjb25jZXB0IHRvIGdldCB5b3VyIGhlYWQgYXJvdW5kLCBhbmQgaXMgYmVzdCBleHBsYWluZWQgd2l0aCBhbiBleGFtcGxlLiBUaGUgZGF0YSB3ZSB3aWxsIGFuYWx5c2UgaGVyZSBhcmUgY291bnRzIG9mIGludmVydGVicmF0ZXMgYXQgMy00IHNpdGVzIGluIGVhY2ggb2YgNyAocmFuZG9tbHkgY2hvc2VuKSBlc3R1YXJpZXMuIEhlcmUgdGhlIGVzdHVhcmllcyBhcmUgdGhlIHJhbmRvbSBlZmZlY3QsIGFzIHRoZXJlIGFyZSBhIGxhcmdlIG51bWJlciBvZiBwb3NzaWJsZSBlc3R1YXJpZXMsIGFuZCB3ZSBvbmx5IHNhbXBsZSBmcm9tIGEgcmFuZG9tIGZldyBvZiB0aGVtLCBidXQgd2Ugd291bGQgbGlrZSB0byBtYWtlIGluZmVyZW5jZSBhYm91dCBlc3R1YXJpZXMgaW4gZ2VuZXJhbC4gV2Ugd2lsbCB1c2UgdGhlIHBhY2thZ2UgYGxtZTRgIGZvciBhbGwgb3VyIG1peGVkIGVmZmVjdCBtb2RlbGxpbmcuIEl0IHdpbGwgYWxsb3cgdXMgdG8gbW9kZWwgYm90aCBjb250aW51b3VzIGFuZCBkaXNjcmV0ZSBkYXRhIHdpdGggb25lIG9yIG1vcmUgcmFuZG9tIGVmZmVjdHMuIA0KDQoNCmBgYHtyLCBtZXNzYWdlPUZ9DQpFc3R1YXJpZXMgPC0gcmVhZC5jc3YoImRhdGEvZXN0dWFyaWVzLmNzdiIsIGhlYWRlciA9IFQpDQpgYGANCg0KDQojIyBMaW5lYXIgTWl4ZWQgbW9kZWxzIHdpdGggb25lIHJhbmRvbSBlZmZlY3QNCg0KV2UgYWltIHRvIGludmVzdGlnYXRlIHRoZSBlZmZlY3RzIG9mIHdhdGVyIHBvbGx1dGlvbiBvbiB0aGUgYWJ1bmRhbmNlIG9mIHNvbWUgc3VidGlkYWwgbWFyaW5lIGludmVydGVicmF0ZXMgYnkgY29tcGFyaW5nIHNhbXBsZXMgZnJvbSBhbHRlcmVkIGFuZCBwcmlzdGluZSBlc3R1YXJpZXMuIFNpbmNlIHRoZSB0b3RhbCBjb3VudHMgYXJlIGxhcmdlLCB3ZSAgYXNzdW1lIHRoZSBkYXRhIGFyZSBjb250aW51b3VzLiBJbiB0aGlzIGRhdGFzZXQsIHdlIGZvY3VzIG9uIHRoZSBlZmZlY3RzIG9mIG1vZGlmaWNhdGlvbiBvbiBpbnZlcnRlYnJhdGVzLCByZWdhcmRsZXNzIG9mIHRoZSBlc3R1YXJpZXMuIA0KDQoNCg0KIyMjIFJ1bm5pbmcgdGhlIGFuYWx5c2lzDQoNCldlIGhhdmUgYSAqKmZpeGVkIGVmZmVjdCoqIChNb2RpZmljYXRpb247IG1vZGlmaWVkIHZzIHByaXN0aW5lKSBhbmQgYSAqKnJhbmRvbSBlZmZlY3QqKiAoRXN0dWFyeSkuIFdlIGNhbiB1c2UgdGhlIGBsbWVyYCBmdW5jdGlvbiB0byBmaXQgYSBtb2RlbCBmb3IgYW55IGRlcGVuZGVudCB2YXJpYWJsZXMgd2l0aCBhIGNvbnRpbnVvdXMgZGlzdHJpYnV0aW9uLiBUbyBmaXQgYSBtb2RlbCBmb3IgdGhlIGBUb3RhbGAgYWJ1bmRhbmNlIHZhcmlhYmxlLCB3ZSB1c2U6DQoNCg0KYGBge3J9DQpmdC5lc3R1IDwtIGxtZXIoVG90YWwgfiBNb2RpZmljYXRpb24gKyAoMSB8IEVzdHVhcnkpLCBkYXRhID0gRXN0dWFyaWVzLCBSRU1MID0gVCkNCmBgYA0Kd2hlcmUgYFRvdGFsYCBpcyB0aGUgKipkZXBlbmRlbnQgdmFyaWFibGUqKiAobGVmdCBvZiB0aGUgYH5gKSwgYE1vZGlmaWNhdGlvbmAgaXMgdGhlICoqZml4ZWQgZWZmZWN0KiosIGFuZCBgRXN0dWFyeWAgaXMgdGhlICoqcmFuZG9tIGVmZmVjdCoqLg0KDQpOb3RlIHRoZSBzeW50YXggZm9yIG9uZSByYW5kb20gZWZmZWN0IGlzIGAoMXxFc3R1YXJ5KWAgLSB0aGlzIGlzIGZpdHRpbmcgYSBkaWZmZXJlbnQgaW50ZXJjZXB0IChoZW5jZSBgMWApIGZvciBlYWNoIEVzdHVhcnkuDQoNClRoaXMgbW9kZWwgY2FuIGJlIGZpdCBieSBtYXhpbXVtIGxpa2VsaWhvb2QgKGBSRU1MPUZgKSBvciByZXN0cmljdGVkIG1heGltdW0gbGlrZWxpaG9vZCAoYFJFTUw9VGApLiBGb3IgZml0dGluZyBtb2RlbHMgaXTigJlzIGJlc3QgdG8gdXNlIGBSRU1MYCwgYXMgaXQgaXMgbGVzcyBiaWFzZWQgKHVuYmlhc2VkIGZvciBiYWxhbmNlZCBzYW1wbGVzKSwgcGFydGljdWxhcmx5IGluIHNtYWxsIHNhbXBsZXMuIEhvd2V2ZXIgdG8gdXNlIHRoZSBgYW5vdmFgIGZ1bmN0aW9uIGFuZC9vciBjb21wYXJpbmcgbW9kZWxzIHdlIG5lZWQgdG8gcmVmaXQgd2l0aCBtYXhpbXVtIGxpa2VsaWhvb2QuDQoNCiMjIyBNb2RlbCBhc3N1bXB0aW9ucw0KDQpCZWZvcmUgd2UgbG9vayBhdCB0aGUgcmVzdWx0cyBvZiBvdXIgYW5hbHlzaXMsIGl04oCZcyBpbXBvcnRhbnQgdG8gY2hlY2sgdGhhdCBvdXIgZGF0YSBtZXQgdGhlIGFzc3VtcHRpb25zIG9mIHRoZSBtb2RlbCB3ZSB1c2VkLiBMZXTigJlzIGxvb2sgYXQgYWxsIHRoZSBhc3N1bXB0aW9ucyBpbiBvcmRlci4NCg0KKipBc3N1bXB0aW9uIDEqKjogVGhlIG9ic2VydmVkICR5JCBhcmUgaW5kZXBlbmRlbnQsIGNvbmRpdGlvbmFsIG9uIHNvbWUgZml4ZWQgZWZmZWN0cyAkeCQgYW5kIHJhbmRvbSBlZmZlY3RzICR6JA0KDQpXZSBjYW7igJl0IGNoZWNrIHRoaXMgYXNzdW1wdGlvbiwgYnV0IHlvdSBjYW4gZW5zdXJlIGl04oCZcyB0cnVlIGJ5IHRha2luZyBhIHJhbmRvbSBzYW1wbGUgd2l0aGluIGVhY2ggbGV2ZWwgb2YgdGhlIHJhbmRvbSBlZmZlY3QgaW4geW91ciBleHBlcmltZW50YWwgZGVzaWduLg0KDQoqKkFzc3VtcHRpb24gMioqOiBUaGUgcmVzcG9uc2UgJHkkIGFyZSBub3JtYWxseSBkaXN0cmlidXRlZCwgY29uZGl0aW9uYWwgb24gc29tZSBwcmVkaWN0b3JzICR4JCBhbmQgcmFuZG9tIGVmZmVjdHMgJHokDQoNClRoaXMgYXNzdW1wdGlvbiBpcyBvbmx5IGNyaXRpY2FsIHdoZW4gd2UgaGF2ZSBhIHNtYWxsIHNhbXBsZSBzaXplIG9yIHZlcnkgc2tld2VkIGRhdGEuIFdlIGNhbiBjaGVjayBpdCB3aXRoIGEgbm9ybWFsIHF1YW50aWxlIHBsb3Qgb2YgcmVzaWR1YWxzLg0KDQoNCmBgYHtyfQ0KcXFub3JtKHJlc2lkdWFscyhmdC5lc3R1KSkNCmBgYA0KV2UgYXJlIGxvb2tpbmcgZm9yIGEgc3RyYWlnaHQgbGluZSByZWxhdGlvbnNoaXAuIEhlcmUsIHRoZSBhc3N1bXB0aW9uIG9mIG5vcm1hbGl0eSBzZWVtcyByZWFzb25hYmxlLg0KDQoqKkFzc3VtcHRpb24gMyoqOiBUaGUgcmVzcG9uc2UgJHkkIGhhcyBjb25zdGFudCB2YXJpYW5jZSwgY29uZGl0aW9uYWwgb24gc29tZSBmaXhlZCBlZmZlY3RzICR4JCBhbmQgcmFuZG9tIGVmZmVjdHMgJHokDQoNCkxpa2UgYSBsaW5lYXIgbW9kZWwsIGEgbWl4ZWQgbW9kZWwgYXNzdW1lcyBjb25zdGFudCB2YXJpYW5jZS4gV2UgY2FuIGNoZWNrIHRoaXMgYnkgbG9va2luZyBmb3IgYSBmYW4gc2hhcGUgaW4gdGhlIHJlc2lkdWFsIHBsb3QgKHJlc2lkdWFscyB2cyBmaXR0ZWQgdmFsdWVzKS4NCg0KYGBge3J9DQpzY2F0dGVyLnNtb290aChyZXNpZHVhbHMoZnQuZXN0dSkgfiBmaXR0ZWQoZnQuZXN0dSkpDQpgYGANClRoaXMgcmVzaWR1YWwgcGxvdCBzZWVtcyByZWFzb25hYmxlLCB0aGVyZSBhcmUgZGlmZmVyZW5jZXMgaW4gdmFyaWFiaWxpdHkgYmV0d2VlbiBlc3R1YXJpZXMsIGJ1dCB2YXJpYWJpbGl0eSBkb2VzIG5vdCBpbmNyZWFzZSB3aXRoIHRoZSBtZWFuLiBOb3RlLCB0aGF0IHRoZSBmdW5jdGlvbiBgc2NhdHRlci5zbW9vdGhgIGlzIGp1c3QgYSBzY2F0dGVyIHBsb3Qgd2l0aCBhIGZpdHRlZCwgc21vb3RoZWQgY3VydmUuDQoNCioqQXNzdW1wdGlvbiA0Kio6IFRoZXJlIGlzIGEgc3RyYWlnaHQgbGluZSByZWxhdGlvbnNoaXAgYmV0d2VlbiAkeSQgYW5kIHRoZSBwcmVkaWN0b3IgJHgkIGFuZCByYW5kb20gZWZmZWN0ICR6JA0KDQpUbyBjaGVjayB0aGlzIGFzc3VtcHRpb24sIHdlIGNoZWNrIHRoZSByZXNpZHVhbCBwbG90IGFnYWluIGZvciBub24tbGluZWFyaXR5LCBvciBhIFUtc2hhcGUuIEluIG91ciBjYXNlIHRoZXJlIGlzIG5vIGV2aWRlbmNlIG9mIG5vbi1saW5lYXJpdHkuIElmIHRoZSByZXNpZHVhbHMgc2VlbSB0byBnbyBkb3duIHRoZW4gdXAsIG9yIHVwIHRoZW4gZG93biwgd2UgbWF5IG5lZWQgdG8gYWRkIGEgcG9seW5vbWlhbCBmdW5jdGlvbiBvZiB0aGUgcHJlZGljdG9ycyB1c2luZyB0aGUgYHBvbHlgIGZ1bmN0aW9uLg0KDQoNCioqQXNzdW1wdGlvbiA1Kio6IFJhbmRvbSBlZmZlY3RzIGB6YCBhcmUgaW5kZXBlbmRlbnQgb2YgYHlgLg0KDQpXZSBjYW7igJl0IGNoZWNrIHRoaXMgYXNzdW1wdGlvbiwgYnV0IHlvdSBjYW4gZW5zdXJlIGl04oCZcyB0cnVlIGJ5IHRha2luZyBhIHJhbmRvbSBzYW1wbGUgb2YgZXN0dWFyaWVzLg0KDQoqKkFzc3VtcHRpb24gNioqOiBSYW5kb20gZWZmZWN0cyBgemAgYXJlIG5vcm1hbGx5IGRpc3RyaWJ1dGVkLg0KDQpUaGlzIGFzc3VtcHRpb24gaXMgbm90IGNydWNpYWwgKGFuZCBkaWZmaWN1bHQpIHRvIGNoZWNrLg0KDQojIyMgTW9kZWwgaW50ZXJwcmV0YXRpb24NCg0KIyMjIyBIeXBvdGhlc2lzIHRlc3QgZm9yIHRoZSBmaXhlZCBlZmZlY3QNCg0KVGhlIHBhY2thZ2UgYGxtZTRgIHdvbuKAmXQgZ2l2ZSB5b3UgcC12YWx1ZXMgZm9yIGZpeGVkIGVmZmVjdHMgYXMgcGFydCBvZiB0aGUgb3V0cHV0IGluIGBzdW1tYXJ5YC4gVGhpcyBpcyBiZWNhdXNlIHRoZSBwLXZhbHVlcyBmcm9tIFdhbGQgdGVzdHMgKHVzaW5nIGBzdW1tYXJ5YCkgYW5kIGxpa2VsaWhvb2QgcmF0aW8gdGVzdHMgKHVzaW5nIGBhbm92YWApIGFyZSBvbmx5IGFwcHJveGltYXRlIGluIG1peGVkIG1vZGVscy4NCg0KTmV2ZXJ0aGVsZXNzLCB3ZSB3aWxsIHVzZSB0aGUgYGFub3ZhYCBmdW5jdGlvbiB0byB0ZXN0IGZvciBhbiBlZmZlY3Qgb2YgbW9kaWZpY2F0aW9uIG9uIHRoZSB0b3RhbCBhYnVuZGFuY2Ugb2YgaW52ZXJ0ZWJyYXRlcywgdGFraW5nIGludG8gYWNjb3VudCB0aGUgcmFuZG9tIGVmZmVjdCBvZiBlc3R1YXJ5Lg0KDQpGaXJzdCwgd2UgZml0IHRoZSBmdWxsIG1vZGVsIGJ5IG1heGltdW0gbGlrZWxpaG9vZCwgYW5kIGEgc2Vjb25kIG1vZGVsIHRoYXQgbGFja3MgdGhlIGZpeGVkIGVmZmVjdCBvZiBNb2RpZmljYXRpb24NCg0KDQpgYGB7cn0NCmZ0LmVzdHUgPC0gbG1lcihUb3RhbCB+IE1vZGlmaWNhdGlvbiArICgxIHwgRXN0dWFyeSksIGRhdGEgPSBFc3R1YXJpZXMsIFJFTUwgPSBGKQ0KZnQuZXN0dS4wIDwtIGxtZXIoVG90YWwgfiAoMSB8IEVzdHVhcnkpLCBkYXRhID0gRXN0dWFyaWVzLCBSRU1MID0gRikNCmBgYA0KDQpUaGVuLCB3ZSBjb21wYXJlIHRoZXNlIHR3byBtb2RlbHMgd2l0aCBhIGxpa2VsaWhvb2QgcmF0aW8gdGVzdCwgdXNpbmcgdGhlIGBhbm92YWAgZnVuY3Rpb24uDQoNCmBgYHtyfQ0KYW5vdmEoZnQuZXN0dS4wLCBmdC5lc3R1KQ0KYGBgDQpXZSBmaW5kIHRoYXQgdGhlcmUgaXMgZXZpZGVuY2Ugb2YgYW4gZWZmZWN0IG9mIE1vZGlmaWNhdGlvbiAocCA9IDAuMDIzODUpLiBUaGUgcGFja2FnZSBgbG1lclRlc3RgZXh0ZW5kZWQgb3V0cHV0IG9mIHRoZSBzdW1tYXJ5IG9mIHlvdXIgYGxtZXJgIG9iamVjdC4gSGVyZSwgdGhlIHJlc3VsdHMgd2lsbCBnaXZlIHlvdSBwPSAwLjA2NzYxMSBmb3IgdGhlIGVmZmVjdCBvZiBNb2RpZmljYXRpb24uIEFzIG1lbnRpb25lZCBlYXJsaWVyLCB3aGV0aGVyIHAtdmFsdWVzIHByb3ZpZGUgdGhlIHJpZ2h0IGluZGljYXRpb24gZm9yIHNpZ25pZmljYW5jZSBpcyB0aGUgb2JqZWN0IG9mIGRpc2N1c3Npb24uDQoNCldlIGNhbiBhbHNvIGNhbGN1bGF0ZSBjb25maWRlbmNlIGludGVydmFscyBmb3IgZWFjaCBtb2RlbCBwYXJhbWV0ZXIgdXNpbmcgdGhlIGNvbmZpbnQgZnVuY3Rpb24uDQoNCmBgYHtyfQ0KY29uZmludChmdC5lc3R1KQ0KYGBgDQpUaGlzIGFsc28gcHJvdmlkZXMgZXZpZGVuY2UgZm9yIGFuIGVmZmVjdCBvZiBNb2RpZmljYXRpb24gYXMgdGhpcyBwYXJhbWV0ZXIgKGkuZS4sIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIG1vZGlmaWVkIGFuZCBwcmlzdGluZSBlc3R1YXJpZXMpIGhhcyA5NSUgY29uZmlkZW5jZSBpbnRlcnZhbHMgdGhhdCBkbyBub3Qgb3ZlcmxhcCB6ZXJvLg0KDQojIyMjIEh5cG90aGVzaXMgdGVzdCBmb3IgcmFuZG9tIGVmZmVjdHMNCg0KWW91IGNhbiB1c2UgdGhlIGBhbm92YWAgZnVuY3Rpb24gdG8gdGVzdCBmb3IgcmFuZG9tIGVmZmVjdHMsIGJ1dCB0aGUgcC12YWx1ZXMgYXJlIHZlcnkgYXBwcm94aW1hdGUgYW5kIHRoaXMgcHJvY2VkdXJlIGlzIG5vdCByZWNvbW1lbmRlZC4gSW5zdGVhZCB3ZSB3aWxsIHVzZSBhICoqcGFyYW1ldHJpYyBib290c3RyYXAqKi4gVGhpcyBpcyBhIHNpbXVsYXRpb24gYmFzZWQgbWV0aG9kIHdoaWNoIGludm9sdmVzIGEgZmFpciBjaHVuayBvZiBjb2RlLCBidXQgdGhlcmXigJlzIG5vdCBtdWNoIGFib3V0IHRoZSBjb2RlIHlvdSBoYXZlIHRvIGNoYW5nZSBmb3IgZGlmZmVyZW50IG1vZGVscywgaXTigJlzIG1vc3RseSBqdXN0IGEgbWF0dGVyIG9mIGNvcHktcGFzdGUuDQoNClBhcmFtZXRyaWMgYm9vdHN0cmFwDQoNCmBgYHtyLCBtZXNzYWdlPUZ9DQpuQm9vdCA8LSAxMDAwDQpsclN0YXQgPC0gcmVwKE5BLCBuQm9vdCkNCmZ0Lm51bGwgPC0gbG0oVG90YWwgfiBNb2RpZmljYXRpb24sIGRhdGEgPSBFc3R1YXJpZXMpICMgbnVsbCBtb2RlbA0KZnQuYWx0IDwtIGxtZXIoVG90YWwgfiBNb2RpZmljYXRpb24gKyAoMSB8IEVzdHVhcnkpLCBkYXRhID0gRXN0dWFyaWVzLCBSRU1MID0gRikgIyBhbHRlcm5hdGUgbW9kZWwNCmxyT2JzIDwtIDIgKiBsb2dMaWsoZnQuYWx0KSAtIDIgKiBsb2dMaWsoZnQubnVsbCkgIyBvYnNlcnZlZCB0ZXN0IHN0YXQNCmZvciAoaUJvb3QgaW4gMTpuQm9vdCkNCnsNCiAgRXN0dWFyaWVzJFRvdGFsU2ltIDwtIHVubGlzdChzaW11bGF0ZShmdC5udWxsKSkgIyByZXNhbXBsZWQgZGF0YQ0KICBiTnVsbCA8LSBsbShUb3RhbFNpbSB+IE1vZGlmaWNhdGlvbiwgZGF0YSA9IEVzdHVhcmllcykgIyBudWxsIG1vZGVsDQogIGJBbHQgPC0gbG1lcihUb3RhbFNpbSB+IE1vZGlmaWNhdGlvbiArICgxIHwgRXN0dWFyeSksIGRhdGEgPSBFc3R1YXJpZXMsIFJFTUwgPSBGKSAjIGFsdGVybmF0ZSBtb2RlbA0KICBsclN0YXRbaUJvb3RdIDwtIDIgKiBsb2dMaWsoYkFsdCkgLSAyICogbG9nTGlrKGJOdWxsKSAjIHJlc2FtcGxlZCB0ZXN0IHN0YXQNCn0NCm1lYW4obHJTdGF0ID4gbHJPYnMpICMgUC12YWx1ZSBmb3IgdGVzdCBvZiBFc3R1YXJ5IGVmZmVjdA0KYGBgDQoNClRoZXJlIGlzIHN0cm9uZyBldmlkZW5jZSBmb3IgaW5jbHVkaW5nIGVzdHVhcnkgaW4geW91ciBtb2RlbCAocCA9IDAuMDAxKS4gWW91IGNvdWxkIHVzZSBzaW1pbGFyIGNvZGUgdG8gdGVzdCBmb3IgdGhlIGVmZmVjdCBvZiBNb2RpZmljYXRpb24gd2l0aCBhIHBhcmFtZXRyaWMgYm9vdHN0cmFwLg0KDQpJbiB5b3VyIHJlc3VsdHMsIHlvdSBzaG91bGQgbWVudGlvbiB0aGF0IHlvdSBhcmUgdXNpbmcgbWl4ZWQgbW9kZWxzIHdpdGggUiBwYWNrYWdlIGBsbWU0YC4gWW91IHNob3VsZCBhbHNvIG1lbnRpb24gaG93IHlvdSBjYXJyaWVkIG91dCBpbmZlcmVuY2UsIGkuZS4gbGlrZWxpaG9vZCByYXRpbyB0ZXN0cyAodXNpbmcgdGhlIGBhbm92YWAgZnVuY3Rpb24pIG9yIHBhcmFtZXRyaWMgYm9vdHN0cmFwLiBJbiB0aGUgcmVzdWx0cyBzZWN0aW9uIGZvciBvbmUgcHJlZGljdG9yLCBpdCBzdWZmaWNlcyB0byB3cml0ZSBvbmUgbGluZSwgZS5nLiDigJxUaGVyZSBpcyBzdHJvbmcgZXZpZGVuY2UgKHA8MC4wMDEpIG9mIG5lZ2F0aXZlIGVmZmVjdCBvZiBtb2RpZmljYXRpb24gb24gdG90YWwgYWJ1bmRhbmNlLiBGb3IgbXVsdGlwbGUgcHJlZGljdG9ycyBpdOKAmXMgYmVzdCB0byBkaXNwbGF5IHRoZSByZXN1bHRzIGluIGEgdGFibGUuDQoNCg0KYGBge3J9DQpNb2RFc3QgPC0gdW5pcXVlKEVzdHVhcmllc1tjKCJFc3R1YXJ5IiwgIk1vZGlmaWNhdGlvbiIpXSkgIyBmaW5kIHdoaWNoIEVzdHVhcmllcyBhcmUgbW9kaWZpZWQNCg0KIyBQcmVwYXJlIGEgdmVjdG9yIG9mIGNvbG9ycyB3aXRoIHNwZWNpZmljIGNvbG9yIGJ5IG1vZGlmaWNhdGlvbiBsZXZlbHMNCm15Q29sb3JzIDwtIGlmZWxzZSh1bmlxdWUoTW9kRXN0JE1vZGlmaWNhdGlvbikgPT0gIk1vZGlmaWVkIiwgcmdiKDAuMSwgMC4xLCAwLjcsIDAuNSksDQogIGlmZWxzZSh1bmlxdWUoTW9kRXN0JE1vZGlmaWNhdGlvbikgPT0gIlByaXN0aW5lIiwgcmdiKDAuOCwgMC4xLCAwLjMsIDAuNiksDQogICAgImdyZXk5MCINCiAgKQ0KKQ0KDQpib3hwbG90KFRvdGFsIH4gRXN0dWFyeSwgZGF0YSA9IEVzdHVhcmllcywgY29sID0gbXlDb2xvcnMsIHhsYWIgPSAiRXN0dWFyeSIsIHlsYWIgPSAiVG90YWwgaW52ZXJ0ZWJyYXRlcyIpDQpsZWdlbmQoImJvdHRvbWxlZnQiLA0KICBpbnNldCA9IC4wMiwNCiAgYygiIE1vZGlmaWVkICIsICIgUHJpc3RpbmUgIiksIGZpbGwgPSB1bmlxdWUobXlDb2xvcnMpLCBob3JpeiA9IFRSVUUsIGNleCA9IDAuOA0KKQ0KDQojIDAgaWYgTW9kaWZpZWQsIDEgaWYgUHJpc3RpbmUNCmlzLm1vZCA8LSBpZmVsc2UodW5pcXVlKE1vZEVzdCRNb2RpZmljYXRpb24pID09ICJNb2RpZmllZCIsIDAsDQogIGlmZWxzZSh1bmlxdWUoTW9kRXN0JE1vZGlmaWNhdGlvbikgPT0gIlByaXN0aW5lIiwgMSwgTkEpDQopDQoNCkVzdC5tZWFucyA8LSBjb2VmKGZ0LmVzdHUpJEVzdHVhcnlbLCAxXSArIGNvZWYoZnQuZXN0dSkkRXN0dWFyeVssIDJdICogaXMubW9kICMgTW9kZWwgbWVhbnMNCg0Kc3RyaXBjaGFydChFc3QubWVhbnMgfiBzb3J0KHVuaXF1ZShFc3R1YXJ5KSksIGRhdGEgPSBFc3R1YXJpZXMsIHBjaCA9IDE4LCBjb2wgPSAicmVkIiwgdmVydGljYWwgPSBUUlVFLCBhZGQgPSBUUlVFKQ0KYGBgDQoNCiMjIyBGQVEgbWl4ZWQgbW9kZWxzDQoNCjEuIERvIEkgbmVlZCBiYWxhbmNlZCBzYW1wbGVzIHRvIGZpdCBhIG1peGVkIG1vZGVsPw0KDQpObywgdW5iYWxhbmNlZCBkZXNpZ25zIGFyZSBmaW5lLiBCYWxhbmNlZCBkZXNpZ25zIHdpbGwgZ2VuZXJhbGx5IGdpdmUgeW91IGJldHRlciBwb3dlciB0aG91Z2gsIHNvIHRoZXkgYXJlIGdvb2QgdG8gYWltIGZvci4NCg0KMi4gU2hvdWxkIEkgc2FtcGxlIG1hbnkgbGV2ZWxzIG9mIHRoZSByYW5kb20gZWZmZWN0LCBvciBsb3RzIG9mIG9ic2VydmF0aW9ucyB3aXRoaW4gZWFjaCBsZXZlbD8NCg0KVGhpcyBkZXBlbmRzIG9uIHdoYXQgeW91IGFyZSBpbnRlcmVzdGVkIGluLiBJbiBvdXIgZXhhbXBsZSwgd2UgYXJlIGludGVyZXN0ZWQgaW4gdGhlIGVmZmVjdCBvZiBtb2RpZmljYXRpb24uIEluIHRoZSBzdHVkeSBkZXNpZ24sIGVzdHVhcmllcyBmYWxsIGRpcmVjdGx5IGJlbG93IG1vZGlmaWNhdGlvbiwgc28gd2UgbmVlZCBhIGxvdCBvZiBlc3R1YXJpZXMgd2l0aGluIGVhY2ggbGV2ZWwgb2YgTW9kaWZpY2F0aW9uIHRvIG1ha2UgZ29vZCBpbmZlcmVuY2UgYWJvdXQgdGhlIGVmZmVjdHMgb2YgbW9kaWZpY2F0aW9uLiBUaGlzIGlzIHRydWUgaW4gZ2VuZXJhbCwgeW91IG5lZWQgbG90cyBvZiBzYW1wbGVzIGluIHRoZSBsZXZlbCBiZWxvdyB0aGUgbGV2ZWwgeW91IGFyZSBwcmltYXJpbHkgaW50ZXJlc3RlZCBpbi4NCg0KMy4gRG9lcyBteSByYW5kb20gZmFjdG9yIGhhdmUgdG8gYmUgYSByYW5kb20gZWZmZWN0Pw0KDQpOb3QgbmVjZXNzYXJpbHkuIElmIHlvdSBoYXZlIGEgcmFuZG9tIGZhY3RvciAoaS5lLiwgeW91IGhhdmUgYSByYW5kb20gc2FtcGxlIG9mIGNhdGVnb3JpZXMgZnJvbSBhIGNhdGVnb3JpY2FsIHZhcmlhYmxlKSBhbmQgeW91IHdhbnQgdG8gbWFrZSBpbmZlcmVuY2VzIGFib3V0IHRoYXQgdmFyaWFibGUgaW4gZ2VuZXJhbCwgbm90IGp1c3QgYXQgdGhlIGNhdGVnb3JpZXMgeW91IG9ic2VydmVkLCB0aGVuIGluY2x1ZGUgaXQgYXMgYSByYW5kb20gZWZmZWN0LiBJZiB5b3UgYXJlIGhhcHB5IG1ha2luZyBpbmZlcmVuY2UgYWJvdXQganVzdCB0aGUgbGV2ZWxzIHlvdSBvYnNlcnZlZCwgdGhlbiB5b3UgY2FuIGluY2x1ZGUgaXQgYXMgYSBmaXhlZCBlZmZlY3QuIEluIG91ciBleGFtcGxlIHdlIHdhbnRlZCB0byBtYWtlIGluZmVyZW5jZSBhYm91dCBtb2RpZmljYXRpb24gaW4gZ2VuZXJhbCwgaS5lLiBpbiBldmVyeSBtb2RpZmllZCBhbmQgdW5tb2RpZmllZCBlc3R1YXJ5LCBzbyB3ZSBpbmNsdWRlZCBlc3R1YXJ5IGFzIGEgcmFuZG9tIGVmZmVjdC4gSWYgd2UgaGFkIHRyZWF0ZWQgRXN0dWFyeSBhcyBhIGZpeGVkIGZhY3Rvciwgd2Ugd291bGQgaGF2ZSBiZWVuIHJlc3RyaWN0ZWQgdG8gbWFraW5nIGNvbmNsdXNpb25zIGFib3V0IG9ubHkgdGhlIGVzdHVhcmllcyB3ZSBzYW1wbGUuDQoNCjQuIFdoYXQgaWYgdGhlIGxldmVscyBvZiBteSBmYWN0b3IgYXJlbuKAmXQgcmVhbGx5IHJhbmRvbT8NCg0KVGhpcyBtaWdodCBiZSBhIHByb2JsZW0gYXMgYXNzdW1wdGlvbiA0IG1heSBub3QgaG9sZC4gWW91IHNob3VsZCBhbHdheXMgc2FtcGxlIHRoZSByYW5kb20gZWZmZWN0IHJhbmRvbWx5IHRvIGF2b2lkIGJpYXMgYW5kIGluY29ycmVjdCBjb25jbHVzaW9ucy4NCg0KIyMgQ3Jvc3NlZCBhbmQgbmVzdGVkIEZhY3RvcnMNCg0KTWFueSBleHBlcmltZW50YWwgZGVzaWducyBpbiBlY29sb2d5IGFuZCBlbnZpcm9ubWVudGFsIHNjaWVuY2VzIHJlcXVpcmUgbWl4ZWQgbW9kZWxzIHdpdGggc2V2ZXJhbCAqKnJhbmRvbSBlZmZlY3RzKiogKGZhY3RvcnMpLiBZb3UgbWlnaHQgaGF2ZSBoZWFyZCBvZiAqKm5lc3RlZCoqIGFuZCAqKmNyb3NzZWQqKiBmYWN0b3JzLg0KDQpUd28gZmFjdG9ycyBhcmUgKipjcm9zc2VkKiogd2hlbiBldmVyeSBjYXRlZ29yeSAobGV2ZWwpIG9mIG9uZSBmYWN0b3IgY28tb2NjdXJzIGluIHRoZSBkZXNpZ24gd2l0aCBldmVyeSBjYXRlZ29yeSBvZiB0aGUgb3RoZXIgZmFjdG9yLiBJbiBvdGhlciB3b3JkcywgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIG9ic2VydmF0aW9uIGluIGV2ZXJ5IGNvbWJpbmF0aW9uIG9mIGNhdGVnb3JpZXMgZm9yIHRoZSB0d28gZmFjdG9ycy4NCg0KQSBmYWN0b3IgaXMgKipuZXN0ZWQqKiB3aXRoaW4gYW5vdGhlciBmYWN0b3Igd2hlbiBlYWNoIGNhdGVnb3J5IG9mIHRoZSBmaXJzdCBmYWN0b3IgY28tb2NjdXJzIHdpdGggb25seSBvbmUgY2F0ZWdvcnkgb2YgdGhlIG90aGVyLiBJbiBvdGhlciB3b3JkcywgYW4gb2JzZXJ2YXRpb24gaGFzIHRvIGJlIHdpdGhpbiBvbmUgY2F0ZWdvcnkgb2YgRmFjdG9yIDIgaW4gb3JkZXIgdG8gaGF2ZSBhIHNwZWNpZmljIGNhdGVnb3J5IG9mIEZhY3RvciAxLiBBbGwgY29tYmluYXRpb25zIG9mIGNhdGVnb3JpZXMgYXJlIG5vdCByZXByZXNlbnRlZC4NCg0KVGhlcmUgYXJlIGFsc28gaW50ZXJtZWRpYXRlIGRlc2lnbnMgdGhhdCBhcmUgcGFydGlhbGx5IGNyb3NzZWQsIHdoZXJlIHNvbWUgbGV2ZWxzIG9mIG9uZSBmYWN0b3Igb2NjdXIgaW4gc2V2ZXJhbCAoYnV0IG5vdCBhbGwpIGxldmVscyBvZiB0aGUgc2Vjb25kIGZhY3Rvci4gVGhlc2UgZGVzaWducyBoYXZlIG9mdGVuIGJlZW4gdGF1Z2h0IGFzIHNlcGFyYXRlIHByb2JsZW1zIHdpdGggZGlmZmVyZW50IHdheXMgdG8gY2Fycnkgb3V0IGFuYWx5c2VzIG9mIHZhcmlhbmNlIChBTk9WQXMpIGRlcGVuZGluZyBvbiBpZiB5b3UgaGF2ZSBjcm9zc2VkIG9yIG5lc3RlZCBmYWN0b3JzLiBVc2luZyBtaXhlZCBtb2RlbHMgd2l0aCB0aGUgcGFja2FnZSBsbWU0LCB3ZSBjYW4gdGhpbmsgaWYgYWxsIG9mIHRoZXNlIGluIG9uZSBmcmFtZXdvcmssIHdoZXJlIG5lc3RlZCBhbmQgY3Jvc3NlZCBkZXNpZ25zIGFyZSBtb2RlbGxlZCBpbiB0aGUgc2FtZSB3YXkuIFRoaW5raW5nIGFib3V0IGZhY3RvcnMgYXMgY3Jvc3NlZCBvciBuZXN0ZWQgaXMgc2ltcGxpZmllZCB0byBjYXJlZnVsIGxhYmVsbGluZyBvZiBmYWN0b3IgbGV2ZWxzIC0gbW9yZSBvbiB0aGlzIGxhdGVyLg0KDQoNCiMjIyBSdW5uaW5nIHRoZSBhbmFseXNpcw0KDQpXZSB3aWxsIGRvIGFzIHdlIGRpZCBiZWZvcmUgdXNpbmcgYE1vZGlmaWNhdGlvbmAgYXMgYSBmaXhlZCBmYWNvciB3aXRoIHR3byBsZXZlbHMgYG1vZGlmaWVkYCBhbmQgYHByaXN0aW5lYCwgYnV0IHRoaXMgdGltZSB3ZSB3aWxsIGNvbnNpZGVyICoqdHdvIHJhbmRvbSBlZmZlY3RzKiogKGBFc3R1YXJ5YCBhbmQgYFNpdGVgKS4gYFNpdGVgIGlzIG5lc3RlZCB3aXRoaW4gYEVzdHVhcnlgIGFzIGVhY2ggc2l0ZSBjYW4gb25seSBiZWxvbmcgaW4gb25lIGVzdHVhcnkuIFdoZW4gZW50ZXJpbmcgdGhlIGRhdGEsIGhvd2V2ZXIsIHdl4oCZdmUgYmVlbiBjYXJlbGVzcyBhbmQgbnVtYmVyZWQgc2l0ZXMgd2l0aGluIGVhY2ggZXN0dWFyeSBhcyAxLCAyLCAzIGV0Yy4NCg0KV2UgY2FuIHNlZSB0aGlzIGJ5IGxvb2tpbmcgYXQgdGhlIGRhdGEsIGFuZCBhIGNyb3NzIHRhYnVsYXRpb24uDQoNCmBgYHtyfQ0KRXN0dWFyaWVzWzE6MTAsIF0NCnh0YWJzKH4gRXN0dWFyeSArIFNpdGUsIEVzdHVhcmllcywgc3BhcnNlID0gVFJVRSkNCmBgYA0KDQpFc3R1YXJ5IGBKQUtgIGFuZCBlc3R1YXJ5IGBKRVJgIGVhY2ggaGF2ZSBzaXRlcyBudW1iZXJlZCBgMWAsIGV2ZW4gdGhvdWdoIHRoZXNlIHNpdGVzIGFyZSBub3QgY29ubmVjdGVkIGluIGFueSB3YXkuIFdlIGNhbiBhbHNvIHNlZSB0aGlzIGluIHRoZSBjcm9zcyB0YWJ1bGF0aW9uIGB4dGFic2AuIFRoaXMgc2l0ZSBsYWJlbGxpbmcgbG9va3MgY3Jvc3NlZCwgd2hlcmUgZWFjaCBzaXRlIG9jY3VycyBpbiBlYWNoIGVzdHVhcnksIHJhdGhlciB0aGFuIG5lc3RlZC4NCg0KV2UgY2FuIGZpeCB0aGlzIGJ5IHNpbXBseSB0ZWxsaW5nIFIgdGhhdCBgU2l0ZWAgaXMgbmVzdGVkIGluIGBFc3R1YXJ5YC4gSXQgaXMgYmVzdCBwcmFjdGljZSwgaG93ZXZlciwgdG8gZG8gdGhpcyBhdCB0aGUgZGF0YSBlbnRyeSBzdGFnZS4gSWYgdGhpbmdzIGFyZSB0aGUgc2FtZSwgdGhlbiB0aGV5IHNob3VsZCBiZSBsYWJlbGxlZCB0aGUgc2FtZSwgYW5kIGlmIHRoZXkgYXJlIG5vdCB0aGV5IHNob3VsZCBiZSBsYWJlbGxlZCBkaWZmZXJlbnRseS4NCg0KVG8gY3JlYXRlIGEgdW5pcXVlIGxhYmVsIGZvciBlYWNoIHNpdGUgaW4gdGhpcyBkYXRhIHNldCwgd2UgY29udmVydCBgU2l0ZWAgdG8gYSBmYWN0b3IgKGl0IHdhcyBhbiBpbnRlZ2VyKSwgYW5kIGNyZWF0ZSBhIG5ldyB2YXJpYWJsZSAoYFNpdGVXaXRoaW5gKSB0aGF0IGlzIHRoZSBjb21iaW5hdGlvbiBvZiBFc3R1YXJ5IGFuZCBTaXRlDQoNCmBgYHtyfQ0KRXN0dWFyaWVzJFNpdGUgPC0gYXMuZmFjdG9yKEVzdHVhcmllcyRTaXRlKQ0KRXN0dWFyaWVzJFNpdGVXaXRoaW4gPC0gcGFzdGUwKEVzdHVhcmllcyRFc3R1YXJ5LCAiXyIsIEVzdHVhcmllcyRTaXRlKQ0KYGBgDQoNCk5vdywgY2hlY2sgdGhlIHN0cnVjdHVyZSB0byBzZWUgdGhhdCBlYWNoIHNpdGUgaXMgbmVzdGVkIGluIG9ubHkgb25lIEVzdHVhcnksIGNvbnNpc3RlbnQgd2l0aCB0aGUgZXhwZXJpbWVudGFsIGRlc2lnbi4NCg0KYGBge3J9DQp4dGFicyh+IEVzdHVhcnkgKyBTaXRlV2l0aGluLCBFc3R1YXJpZXMsIHNwYXJzZSA9IFRSVUUpDQpgYGANCg0KVG8gZml0IGEgbW9kZWwgZm9yIHRvdGFsIGFidW5kYW5jZSwgd2Ugd291bGQgdXNlOg0KDQoNCmBgYHtyfQ0KZml0Lm1vZCA8LSBsbWVyKFRvdGFsIH4gTW9kaWZpY2F0aW9uICsgKDEgfCBFc3R1YXJ5KSArICgxIHwgU2l0ZVdpdGhpbiksIGRhdGEgPSBFc3R1YXJpZXMpDQojIHNhbWUgYXM6IGxtZXIoVG90YWwgfiBNb2RpZmljYXRpb24gKyAoMSB8IEVzdHVhcnkvU2l0ZVdpdGhpbiksIGRhdGEgPSBFc3R1YXJpZXMpDQpzdW1tYXJ5KGZpdC5tb2QpDQpgYGANCndoZXJlIGBUb3RhbGAgaXMgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSAobGVmdCBvZiB0aGUgYH5gKSwgYE1vZGlmaWNhdGlvbmAgaXMgdGhlIGZpeGVkIGVmZmVjdCwgYW5kIGBFc3R1YXJ5YCBhbmQgYFNpdGVXaXRoaW5gIGFyZSB0aGUgcmFuZG9tIGVmZmVjdHMuDQoNCldl4oCZbGwgYWxzbyBmaXQgdGhlICoqV1JPTkcqKiBtb2RlbCwgdG8gc2VlIHRoZSBkaWZmZXJlbmNlIGlmIHdlIGhhZCB1c2VkIHRoZSBvbGQgbGFiZWxzIGZvciBlYWNoIHNpdGUuDQoNCmBgYHtyfQ0KZml0Lndyb25nIDwtIGxtZXIoVG90YWwgfiBNb2RpZmljYXRpb24gKyAoMSB8IEVzdHVhcnkpICsgKDEgfCBTaXRlKSwgZGF0YSA9IEVzdHVhcmllcykNCnN1bW1hcnkoZml0Lndyb25nKQ0KYGBgDQpUaGUgb25seSBwbGFjZSB3ZSBjYW4gc2VlIGFuIG9idmlvdXMgZGlmZmVyZW5jZSBpcyB1bmRlciB0aGUgUmFuZG9tIGVmZmVjdHMgdGFibGUuIEZvciB0aGUgKipjb3JyZWN0KiogbW9kZWwgd2UgaGF2ZSBOdW1iZXIgb2Ygb2JzOiA1MiwgZ3JvdXBzOiBTaXRlV2l0aGluLCAyNjsgRXN0dWFyeSwgNyB3aGlsZSB0aGUgKip3cm9uZyoqIG1vZGVsIHRlbGxzIHVzIHdlIGhhdmUgb25seSA0IHNpdGVzLCB3aGljaCB3ZSBrbm93IGlzIGluY29ycmVjdC4NCg0KKk5vdGUqOiBmaXQud3Jvbmcgd291bGQgYmUgY29ycmVjdCBpZiB3ZSBoYWQgY3Jvc3NlZCBmYWN0b3JzDQoNCiMjIyBNb2RlbCBhc3N1bXB0aW9uDQoNClRoZSBhc3N1bXB0aW9ucyBhcmUgdGhlIHNhbWUgYXMgZm9yIG9uZSByYW5kb20gZmFjdG9yLiBCcmllZmx5LCBhc3N1bXB0aW9ucyAxIGFuZCA1IGNhbm5vdCBiZSBjaGVja2VkLCBidXQgY2FuIGJlIGVuc3VyZWQgYnkgdGFraW5nIHJhbmRvbSBzYW1wbGVzLCBhbmQgYXNzdW1wdGlvbiA2IGlzIG5vdCBjcnVjaWFsIGFuZCBkaWZmaWN1bHQgdG8gY2hlY2suIFRvIGNoZWNrIGFzc3VtcHRpb24gMiB3ZSBsb29rIGZvciBhIHN0cmFpZ2h0IGxpbmUgcmVsYXRpb25zaGlwIG9uIHRoZSBub3JtYWwgcXVhbnRpbGUgcGxvdC4gVG8gY2hlY2sgYXNzdW1wdGlvbnMgMywgYW5kIDQgd2UgbG9vayBmb3IgYSBmYW4gc2hhcGUgYW5kIFUgc2hhcGUgb24gdGhlIHJlc2lkdWFsIHZzLiBmaXR0ZWQgcGxvdC4NCg0KYGBge3J9DQpwYXIobWZyb3cgPSBjKDEsIDIpKQ0KcXFub3JtKHJlc2lkdWFscyhmaXQubW9kKSkNCnNjYXR0ZXIuc21vb3RoKHJlc2lkdWFscyhmaXQubW9kKSB+IGZpdHRlZChmaXQubW9kKSkgIyByZXNpZHVhbCBwbG90DQpgYGANCg0KVGhlIG5vcm1hbCBxdWFudGlsZSBwbG90IGxvb2tzIHJlYXNvbmFibGUsIGhvd2V2ZXIgd2Ugc2VlIGhlcmUgYSBkZWZpbml0ZSBmYW4gc2hhcGUgaW4gdGhlIHJlc2lkdWFsIHZzLiBmaXQgcGxvdC4gTGV04oCZcyB0cnkgdHJhbnNmb3JtaW5nIHRoZSByZXNwb25zZSBhbmQgc2VlIGlmIHdlIGRvIGJldHRlci4NCg0KYGBge3J9DQpmaXQubW9kIDwtIGxtZXIobG9nKFRvdGFsKSB+IE1vZGlmaWNhdGlvbiArICgxIHwgRXN0dWFyeSkgKyAoMSB8IFNpdGVXaXRoaW4pLCBkYXRhID0gRXN0dWFyaWVzKQ0KcGFyKG1mcm93ID0gYygxLCAyKSkNCnFxbm9ybShyZXNpZHVhbHMoZml0Lm1vZCkpDQpzY2F0dGVyLnNtb290aChyZXNpZHVhbHMoZml0Lm1vZCkgfiBmaXR0ZWQoZml0Lm1vZCkpICMgcmVzaWR1YWwgcGxvdA0KYGBgDQpUaGlzIHNjYXR0ZXJwbG90IGlzIG11Y2ggYmV0dGVyLCB0aGUgZmFuIHNoYXBlIGlzIGFsbCBidXQgZ29uZS4gVGhlIHNtb290aCBsaW5lIGlzIGJlbG93IHplcm8gb24gdGhlIGxlZnQsIGJ1dCB0aGVyZSBhcmUgcmVsYXRpdmVseSBmZXcgcG9pbnRzIHRoZXJlLCBzbyBpdOKAmXMgbm90IG9mIGdyZWF0IGNvbmNlcm4uDQoNCiMjIyBJbnRlcnByZXRpbmcNCg0KIyMjIyBIeXBvdGhlc2lzIHRlc3QgZm9yIHRoZSBmaXhlZCBlZmZlY3QNCg0KV2UgY2FuIHVzZSB0aGUgYGFub3ZhYCBhcyBiZWZvcmUgdG8gb2J0YWluIGFwcHJveGltYXRlIHAtdmFsdWVzIGZvciBmaXhlZCBlZmZlY3RzIChidXQgdGhpcyBhbHNvIHRoZSBgbG1lclRlc3RgIHBhY2thZ2UpLg0KDQpgYGB7cn0NCmZ0Lm1vZCA8LSBsbWVyKGxvZyhUb3RhbCkgfiBNb2RpZmljYXRpb24gKyAoMSB8IEVzdHVhcnkpICsgKDEgfCBTaXRlV2l0aGluKSwgZGF0YSA9IEVzdHVhcmllcywgUkVNTCA9IEYpDQpmdC5tb2QuMCA8LSBsbWVyKGxvZyhUb3RhbCkgfiAoMSB8IEVzdHVhcnkpICsgKDEgfCBTaXRlV2l0aGluKSwgZGF0YSA9IEVzdHVhcmllcywgUkVNTCA9IEYpDQphbm92YShmdC5tb2QuMCwgZnQubW9kKQ0KYGBgDQpXZSBmaW5kIG5vIGV2aWRlbmNlIG9mIGFuIGVmZmVjdCBvZiBNb2RpZmljYXRpb24gKHA9MC4wNTA0NykuDQoNCiMjIyMgSHlwb3RoZXNpcyB0ZXN0IGZvciByYW5kb20gZWZmZWN0cw0KDQpTaW1pbGFyIHRvIGJlZm9yZSwgd2UgY2FuIHVzZSBhIHBhcmFtZXRyaWMgYm9vdHN0cmFwcGluZyB0byB0ZXN0IHRoZSByYW5kb20gZWZmZWN0cy4gV2Ugd2lsbCB0ZXN0IGlmIHdlIG5lZWQgdG8gaGF2ZSBhIHJhbmRvbSBlZmZlY3QgZm9yIFNpdGUgZ2l2ZW4gd2UgaGF2ZSBhIHJhbmRvbSBlZmZlY3QgZm9yIEVzdHVhcnkgaW4gdGhlIG1vZGVsLiANCg0KYGBge3IsIG1lc3NhZ2U9Rn0NCm5Cb290IDwtIDEwMDANCmxyU3RhdCA8LSByZXAoTkEsIG5Cb290KQ0KZnQubnVsbCA8LSBsbWVyKGxvZyhUb3RhbCkgfiBNb2RpZmljYXRpb24gKyAoMSB8IEVzdHVhcnkpLCBFc3R1YXJpZXMsIFJFTUwgPSBGKSAjIG51bGwgbW9kZWwNCmZ0LmFsdCA8LSBsbWVyKGxvZyhUb3RhbCkgfiBNb2RpZmljYXRpb24gKyAoMSB8IEVzdHVhcnkpICsgKDEgfCBTaXRlV2l0aGluKSwgRXN0dWFyaWVzLCBSRU1MID0gRikgIyBhbHRlcm5hdGUgbW9kZWwNCmxyT2JzIDwtIDIgKiBsb2dMaWsoZnQuYWx0KSAtIDIgKiBsb2dMaWsoZnQubnVsbCkgIyBvYnNlcnZlZCB0ZXN0IHN0YXQNCmZvciAoaUJvb3QgaW4gMTpuQm9vdCkNCnsNCiAgRXN0dWFyaWVzJGxvZ1RvdGFsU2ltIDwtIHVubGlzdChzaW11bGF0ZShmdC5udWxsKSkgIyByZXNhbXBsZWQgZGF0YQ0KICBiTnVsbCA8LSBsbWVyKGxvZ1RvdGFsU2ltIH4gTW9kaWZpY2F0aW9uICsgKDEgfCBFc3R1YXJ5KSwgRXN0dWFyaWVzLCBSRU1MID0gRikgIyBudWxsIG1vZGVsDQogIGJBbHQgPC0gbG1lcihsb2dUb3RhbFNpbSB+IE1vZGlmaWNhdGlvbiArICgxIHwgRXN0dWFyeSkgKyAoMSB8IFNpdGVXaXRoaW4pLCBFc3R1YXJpZXMsIFJFTUwgPSBGKSAjIGFsdGVybmF0ZSBtb2RlbA0KICBsclN0YXRbaUJvb3RdIDwtIDIgKiBsb2dMaWsoYkFsdCkgLSAyICogbG9nTGlrKGJOdWxsKSAjIHJlc2FtcGxlZCB0ZXN0IHN0YXQNCn0NCm1lYW4obHJTdGF0ID4gbHJPYnMpICMgUC12YWx1ZSBmb3IgdGVzdCBvZiBFc3R1YXJ5IGVmZmVjdA0KYGBgDQoNClRoZSBwLXZhbHVlIGlzIDAsIHNvIHZlcnkgc21hbGwuIFdlIGhhdmUgc3Ryb25nIGV2aWRlbmNlIG9mIGFuIGVmZmVjdCBvZiBTaXRlIGFuZCBzaG91bGQga2VlcCBpdCBpbiB0aGUgbW9kZWwuDQoNCg0KIyMgR2VuZXJhbGlzZWQgbWl4ZWQgbW9kZWxzDQoNClRoaXMgYWxsb3dzIHRvIG1vZGVsIGRpc2NyZXRlIGRhdGEgKGUuZy4sIHByZXNlbmNlL2Fic2VuY2UpIHdpdGggcmFuZG9tIGVmZmVjdHMgdXNpbmcgZ2VuZXJhbGlzZWQgbGluZWFyIG1peGVkIG1vZGVscyAoR0xNTXMpLg0KDQojIyMgQXNzdW1wdGlvbnMNCg0KVGhlIGFzc3VtcHRpb25zIG9mIGdlbmVyYWxpc2VkIGxpbmVhciBtaXhlZCBtb2RlbHMgYXJlIGEgY29tYmluYXRpb24gb2YgdGhlIGFzc3VtcHRpb25zIG9mIEdMTXMgYW5kIG1peGVkIG1vZGVscy4NCg0KLSBUaGUgb2JzZXJ2ZWQgJHkkIGFyZSBpbmRlcGVuZGVudCwgY29uZGl0aW9uYWwgb24gc29tZSBwcmVkaWN0b3JzICR4JCANCi0gVGhlIHJlc3BvbnNlICR5JCBjb21lcyBmcm9tIGEga25vd24gZGlzdHJpYnV0aW9uIGZyb20gdGhlIGV4cG9uZW50aWFsIGZhbWlseSwgd2l0aCBhIGtub3duIG1lYW4gdmFyaWFuY2UgcmVsYXRpb25zaGlwDQotIFRoZXJlIGlzIGEgc3RyYWlnaHQgbGluZSByZWxhdGlvbnNoaXAgYmV0d2VlbiBzb21lIGtub3duIGZ1bmN0aW9uIChsaW5rKSBvZiB0aGUgbWVhbiBvZiAkeSQgYW5kIHRoZSBwcmVkaWN0b3JzICR4JCBhbmQgcmFuZG9tIGVmZmVjdHMgJHokDQotIFJhbmRvbSBlZmZlY3RzICR6JCBhcmUgaW5kZXBlbmRlbnQgb2YgJHkkDQotIFJhbmRvbSBlZmZlY3RzICR6JCBhcmUgbm9ybWFsbHkgZGlzdHJpYnV0ZWQNCg0KIyMjIFJ1bm5pbmcgdGhlIGFuYWx5c2lzDQoNClRoZSBwYWNrYWdlIGBsbWU0YCBhbGxvd3MgdXMgdG8gbW9kZWwgYm90aCBjb250aW51b3VzIGFuZCBkaXNjcmV0ZSBkYXRhIHdpdGggb25lIG9yIG1vcmUgcmFuZG9tIGVmZmVjdHMuIFRoZXJlIGFyZSBob3dldmVyIHNvbWUgbGltaXRhdGlvbnMgZm9yIGRpc2NyZXRlIGRhdGEuDQoNCioqV2hhdCBsbWU0IGNhbiBkbyoqIA0KLSBtb2RlbCBiaW5hcnkgZGF0YSAoZS5nLiwgcHJlc2VuY2UvYWJzZW5jZSkNCi0gbW9kZWwgY291bnRzIHdpdGggUG9pc3NvbiBkaXN0cmlidXRpb24NCg0KKipXaGF0IGxtZTQgY2FuJ3QgZG8qKiANCi0gbW9kZWwgb3ZlcmRpc3BlcnNlZCBjb3VudHMgKHVuZm9ydHVuYXRlbHkgdGhlc2UgYXJlIHJlYWxseSBjb21tb24gaW4gZWNvbG9neSkNCi0gcHJvdmlkZSBnb29kIHJlc2lkdWFsIHBsb3RzICh3ZSBuZWVkIHRoZXNlIGZvciBhc3N1bXB0aW9uIGNoZWNraW5nKQ0KDQpJbiB0aGlzIGV4YW1wbGUsIHdlIGhhdmUgYSAqKmZpeGVkIGVmZmVjdCoqIChNb2RpZmljYXRpb247IG1vZGlmaWVkIHZzIHByaXN0aW5lKSBhbmQgYSAqKnJhbmRvbSBlZmZlY3QqKiAoRXN0dWFyeSkuIFRvIHRlc3Qgd2hldGhlciB0aGVyZSBpcyBhbiBlZmZlY3Qgb2YgbW9kaWZpY2F0aW9uIG9uIGluZGl2aWR1YWwgKipzcGVjaWVzIGNvdW50cyoqIGFuZCAqKnByZXNlbmNlL2Fic2VuY2VzKiosIHdlIG5lZWQgdG8gdXNlIGdlbmVyYWxpc2VkIGxpbmVhciBtaXhlZCBtb2RlbHMgd2l0aCB0aGUgd2l0aCB0aGUgZ2xtZXIgZnVuY3Rpb24uDQoNCkNvbnNpZGVyIHRoZSBjb3VudHMgb2YgaHlkcm9pZHMgKHRoZSB2YXJpYWJsZSBIeWRyb2lkKS4NCg0KYGBge3J9DQpFc3R1YXJpZXMkSHlkcm9pZA0KYGBgDQpMb29raW5nIGF0IHRoZSBkYXRhLCB5b3UgY2FuIHNlZSB0aGUgY291bnRzIGFyZSBzbWFsbCwgd2l0aCBtYW55IHplcm9zLCBzbyB3ZSBkb27igJl0IHdhbnQgdG8gdHJlYXQgdGhlc2UgYXMgY29udGludW91cy4gV2Ugd2lsbCBtb2RlbCB0aGVtIGFzIGNvdW50cyB3aXRoIGEgUG9pc3NvbiBkaXN0cmlidXRpb24sIGFuZCBhbHNvIGFzIHByZXNlbmNlL2Fic2VuY2UgZGF0YS4NCg0KDQojIyMjIEJpbmFyeSBkYXRhDQoNClRvIG1vZGVsIHByZXNlbmNlL2Fic2VuY2UsIHdlIGZpcnN0IGNyZWF0ZSBhIHZhcmlhYmxlIEh5ZHJvaWRQcmVzIHdoaWNoIGlzIDEgKFRSVUUpIHdoZW4gSHlkcm9pZHMgYXJlIHByZXNlbnQgYW5kIDAgKEZBTFNFKSBvdGhlcndpc2UuDQoNCmBgYHtyfQ0KRXN0dWFyaWVzJEh5ZHJvaWRQcmVzIDwtIEVzdHVhcmllcyRIeWRyb2lkID4gMA0KYGBgDQoNClRvIGZpdCBhIG1vZGVsIGZvciB0aGUgcHJlc2VuY2Ugb3IgYWJzZW5jZSBvZiBoeWRyb2lkcywgd2Ugd291bGQgdXNlIGBnbG1lcmAgd2l0aCBgZmFtaWx5PWJpbm9taWFsYA0KDQpgYGB7cn0NCmZpdC5iaW4gPC0gZ2xtZXIoSHlkcm9pZFByZXMgfiBNb2RpZmljYXRpb24gKyAoMSB8IEVzdHVhcnkpLCBmYW1pbHkgPSBiaW5vbWlhbCwgZGF0YSA9IEVzdHVhcmllcykNCmBgYA0KDQpBcyB1c3VhbCwgd2UgY2FuIGV4YW1pbmUgcmVzaWR1YWwgcGxvdHMgdG8gY2hlY2sgYXNzdW1wdGlvbnMuDQoNCg0KYGBge3J9DQpwYXIobWZyb3cgPSBjKDEsIDIpKQ0KcGxvdChyZXNpZHVhbHMoZml0LmJpbikgfiBmaXR0ZWQoZml0LmJpbiksIG1haW4gPSAicmVzaWR1YWxzIHYucy4gRml0dGVkIikNCnFxbm9ybShyZXNpZHVhbHMoZml0LmJpbikpDQpgYGANCg0KQnJpZWZseSBsb29raW5nIGF0IG91ciBhc3N1bXB0aW9ucywgQXNzdW1wdGlvbnMgMSBhbmQgNCB3ZSBjYW7igJl0IGNoZWNrLCBidXQgd2lsbCBiZSB0cnVlIGlmIHdlIHNhbXBsZSByYW5kb21seS4gQXNzdW1wdGlvbiA1IGlzIGhhcmQgdG8gY2hlY2sgaW4gZ2VuZXJhbCBhbmQgbm90IGNydWNpYWwuIEFzc3VtcHRpb24gMiBhbmQgMyB3ZSBzaG91bGQgY2hlY2sgd2l0aCB0aGUgcmVzaWR1YWwgcGxvdHMuIFVuZm9ydHVuYXRlbHksIGZvciBiaW5hcnkgZGF0YSByZXNpZHVhbCBwbG90cyBhcmUgcXVpdGUgZGlmZmljdWx0IHRvIGludGVycHJldC4gSW4gdGhlIHJlc2lkdWFsIHYucy4gZml0dGVkIHBsb3QgYWxsIHRoZSAw4oCZcyBhcmUgaW4gYSBsaW5lIChsb3dlciBsZWZ0KSBhbmQgYWxsIHRoZSBvbmVzIGFyZSBpbiBhIGxpbmUgKHVwcGVyIHJpZ2h0KSBkdWUgdG8gdGhlIGRpc2NyZXRlbmVzcyBvZiB0aGUgZGF0YS4gICANCg0KKipIeXBvdGhlc2lzIHRlc3RpbmcqKg0KDQoNCi0gRml4ZWQgZWZmZWN0cw0KDQpGb3IgZ2VuZXJhbGlzZWQgbGluZWFyIG1peGVkIG1vZGVscyAoR0xNTXMpLCB5b3UgY2FuIHVzZSBgbG1lclRlc3RgIG9yIHVzZSB0aGUgcGFyYW1ldHJpYyBib290c3RyYXAgZm9yIGZpeGVkIGVmZmVjdHMgaW5mZXJlbmNlLiBUaGUgcC12YWx1ZXMgZnJvbSB0aGUgYGFub3ZhYCBmdW5jdGlvbiBhcmUgcXVpdGUgYXBwcm94aW1hdGUgZm9yIEdMTU1zIGV2ZW4gZm9yIGZpeGVkIGVmZmVjdHMuIFNvbWV0aW1lcyB0aGUgYGdsbWVyYCBmdW5jdGlvbiB3aWxsIGdpdmUgd2FybmluZ3Mgb3IgZXJyb3JzLg0KDQoNCmBgYHtyLCBtZXNzYWdlPUZ9DQpuQm9vdCA8LSAxMDAwDQpsclN0YXQgPC0gcmVwKE5BLCBuQm9vdCkNCmZ0Lm51bGwgPC0gZ2xtZXIoSHlkcm9pZFByZXMgfiAxICsgKDEgfCBFc3R1YXJ5KSwgZmFtaWx5ID0gYmlub21pYWwsIGRhdGEgPSBFc3R1YXJpZXMpICMgbnVsbCBtb2RlbA0KZnQuYWx0IDwtIGdsbWVyKEh5ZHJvaWRQcmVzIH4gTW9kaWZpY2F0aW9uICsgKDEgfCBFc3R1YXJ5KSwgZmFtaWx5ID0gYmlub21pYWwsIGRhdGEgPSBFc3R1YXJpZXMpICMgYWx0ZXJuYXRlIG1vZGVsDQoNCmxyT2JzIDwtIDIgKiBsb2dMaWsoZnQuYWx0KSAtIDIgKiBsb2dMaWsoZnQubnVsbCkgIyBvYnNlcnZlZCB0ZXN0IHN0YXQNCg0KZm9yIChpQm9vdCBpbiAxOm5Cb290KQ0Kew0KICBFc3R1YXJpZXMkSHlkcm9pZFByZXNTaW0gPC0gdW5saXN0KHNpbXVsYXRlKGZ0Lm51bGwpKSAjIHJlc2FtcGxlZCBkYXRhDQogIHRyeUNhdGNoKA0KICAgIHsgIyBzb21ldGltZXMgdGhlIGdsbWVyIGNvZGUgZG9lc24ndCBjb252ZXJnZQ0KDQogICAgICBiTnVsbCA8LSBnbG1lcihIeWRyb2lkUHJlc1NpbSB+IDEgKyAoMSB8IEVzdHVhcnkpLCBmYW1pbHkgPSBiaW5vbWlhbCwgZGF0YSA9IEVzdHVhcmllcykgIyBudWxsIG1vZGVsDQogICAgICBiQWx0IDwtIGdsbWVyKEh5ZHJvaWRQcmVzU2ltIH4gTW9kaWZpY2F0aW9uICsgKDEgfCBFc3R1YXJ5KSwgZmFtaWx5ID0gYmlub21pYWwsIGRhdGEgPSBFc3R1YXJpZXMpICMgYWx0ZXJuYXRlIG1vZGVsDQogICAgICBsclN0YXRbaUJvb3RdIDwtIDIgKiBsb2dMaWsoYkFsdCkgLSAyICogbG9nTGlrKGJOdWxsKSAjIHJlc2FtcGxlZCB0ZXN0IHN0YXQNCiAgICB9LA0KICAgIHdhcm5pbmcgPSBmdW5jdGlvbih3YXIpIHsNCiAgICAgIGxyU3RhdFtpQm9vdF0gPC0gTkENCiAgICB9LA0KICAgIGVycm9yID0gZnVuY3Rpb24oZXJyKSB7DQogICAgICBsclN0YXRbaUJvb3RdIDwtIE5BDQogICAgfQ0KICApICMgaWYgY29kZSBkb2Vzbid0IGNvbnZlcmdlIHNraXAgc2ltDQp9DQptZWFuKGxyU3RhdCA+IGxyT2JzLCBuYS5ybSA9IFQpICMgUC12YWx1ZSBmb3IgdGVzdCBvZiBFc3R1YXJ5IGVmZmVjdA0KYGBgDQoNCldlIGhhdmUgZXZpZGVuY2Ugb2YgYW4gZWZmZWN0IG9mIG1vZGlmaWNhdGlvbiBvbiB0aGUgcHJlc2VuY2Ugb2YgaHlkcm9pZHMuDQoNCi0gUmFuZG9tIGVmZmVjdHMNCg0KQXMgYmVmb3JlIHlvdSBjb3VsZCBydW4gaHlwb3RoZXNpcyB0ZXN0cyBvbiB0aGUgcmFuZG9tIGVmZmVjdHMgdXNpbmcgYSBwYXJhbWV0cmljIGJvb3RzdHJhcC4gDQoNCiMjIyMgQ291bnQgZGF0YQ0KDQpgbG1lNGAgY2FuIG1vZGVsIGNvdW50IGRhdGEgdGhhdCBoYXMgYSBQb2lzc29uIGRpc3RyaWJ1dGlvbi4gSWYgdGhlIGRhdGEgZG8gbm90IGZpdCB0aGUgUG9pc3NvbiBtZWFuL3ZhcmlhbmNlIHJlbGF0aW9uc2hpcCwgdGhlbiB0aGluZ3MgYmVjb21lIG11Y2ggbW9yZSBjb21wbGljYXRlZCwgYW5kIHdlIHdvbuKAmXQgY292ZXIgdGhhdCBzaXR1YXRpb24gaGVyZS4NCg0KVG8gbW9kZWwgdGhlIGNvdW50cyBvZiBoeWRyb2lkcywgd2Ugd291bGQgdXNlIHVzZSBgZ2xtZXJgIHdpdGggYGZhbWlseT1wb2lzc29uYC4NCg0KYGBge3J9DQpmaXQucG9pcyA8LSBnbG1lcihIeWRyb2lkIH4gTW9kaWZpY2F0aW9uICsgKDEgfCBFc3R1YXJ5KSwgZmFtaWx5ID0gcG9pc3NvbiwgZGF0YSA9IEVzdHVhcmllcykNCmBgYA0KDQpUbyBjaGVjayB0aGUgYXNzdW1wdGlvbnM6DQoNCmBgYHtyfQ0KcGFyKG1mcm93ID0gYygxLCAyKSkNCnBsb3QocmVzaWR1YWxzKGZpdC5wb2lzKSB+IGZpdHRlZChmaXQucG9pcyksIG1haW4gPSAiUmVzaWR1YWxzIHZzLiBGaXR0ZWQiKQ0KcXFub3JtKHJlc2lkdWFscyhmaXQucG9pcykpDQpgYGANCg0KT25jZSBhZ2FpbiwgdGhlIHJlc2lkdWFsIHBsb3RzIGFyZW7igJl0IHRoYXQgdXNlZnVsLCBidXQgd2UgYXQgbGVhc3QgZ2V0IGFuIGlkZWEgYWJvdXQgd2hldGhlciB0aGUgdmFyaWFuY2UgYXNzdW1wdGlvbiBpcyByZWFzb25hYmxlLiBUaGVyZSBpcyBubyBvYnZpb3VzIGZhbiBzaGFwZSwgc28gYSBQb2lzc29uIG1vZGVsIHNlZW1zIG9rYXkuDQoNCg0KLSBGaXhlZCBlZmZlY3RzDQoNCmBgYHtyLCBtZXNzYWdlPUZ9DQpuQm9vdCA8LSAxMDAwDQpsclN0YXQgPC0gcmVwKE5BLCBuQm9vdCkNCmZ0Lm51bGwgPC0gZ2xtZXIoSHlkcm9pZCB+IDEgKyAoMSB8IEVzdHVhcnkpLCBmYW1pbHkgPSBwb2lzc29uLCBkYXRhID0gRXN0dWFyaWVzKSAjIG51bGwgbW9kZWwNCmZ0LmFsdCA8LSBnbG1lcihIeWRyb2lkIH4gTW9kaWZpY2F0aW9uICsgKDEgfCBFc3R1YXJ5KSwgZmFtaWx5ID0gcG9pc3NvbiwgZGF0YSA9IEVzdHVhcmllcykgIyBhbHRlcm5hdGUgbW9kZWwNCg0KbHJPYnMgPC0gMiAqIGxvZ0xpayhmdC5hbHQpIC0gMiAqIGxvZ0xpayhmdC5udWxsKSAjIG9ic2VydmVkIHRlc3Qgc3RhdA0KZm9yIChpQm9vdCBpbiAxOm5Cb290KQ0Kew0KICBFc3R1YXJpZXMkSHlkcm9pZFNpbSA8LSB1bmxpc3Qoc2ltdWxhdGUoZnQubnVsbCkpICMgcmVzYW1wbGVkIGRhdGENCiAgdHJ5Q2F0Y2goDQogICAgew0KICAgICAgYk51bGwgPC0gZ2xtZXIoSHlkcm9pZFNpbSB+IDEgKyAoMSB8IEVzdHVhcnkpLCBmYW1pbHkgPSBwb2lzc29uLCBkYXRhID0gRXN0dWFyaWVzKSAjIG51bGwgbW9kZWwNCiAgICAgIGJBbHQgPC0gZ2xtZXIoSHlkcm9pZFNpbSB+IE1vZGlmaWNhdGlvbiArICgxIHwgRXN0dWFyeSksIGZhbWlseSA9IHBvaXNzb24sIGRhdGEgPSBFc3R1YXJpZXMpICMgYWx0ZXJuYXRlIG1vZGVsDQogICAgICBsclN0YXRbaUJvb3RdIDwtIDIgKiBsb2dMaWsoYkFsdCkgLSAyICogbG9nTGlrKGJOdWxsKSAjIHJlc2FtcGxlZCB0ZXN0IHN0YXQNCiAgICB9LA0KICAgIHdhcm5pbmcgPSBmdW5jdGlvbih3YXIpIHsNCiAgICAgIGxyU3RhdFtpQm9vdF0gPC0gTkENCiAgICB9LA0KICAgIGVycm9yID0gZnVuY3Rpb24oZXJyKSB7DQogICAgICBsclN0YXRbaUJvb3RdIDwtIE5BDQogICAgfQ0KICApICMgaWYgY29kZSBkb2Vzbid0IGNvbnZlcmdlIHNraXAgc2ltIyAgIGxyU3RhdFtpQm9vdF0NCn0NCmBgYA0KDQoNCi0gUmFuZG9tIGVmZmVjdHMNCg0KQXMgYmVmb3JlIHlvdSBjb3VsZCBydW4gaHlwb3RoZXNpcyB0ZXN0cyBvbiB0aGUgcmFuZG9tIGVmZmVjdHMgdXNpbmcgYSBwYXJhbWV0cmljIGJvb3RzdHJhcC4NCg0KDQoNCioqQSBub24gUG9pc3NvbiBleGFtcGxlKioNCg0KT2Z0ZW4sIGNvdW50IGRhdGEgd2lsbCBub3QgZml0IGEgUG9pc3NvbiBkaXN0cmlidXRpb24uIExvb2sgYXQgd2hhdCBoYXBwZW5zIGlmIHlvdSB0cnkgYW5kIG1vZGVsIHRoZSBjb3VudHMgb2YgdGhlIGJyeW96b2FuLCBTY2hpem9wb3JlbGxhIGVycmF0YSwgZnJvbSB0aGF0IHNhbWUgZGF0YSBzZXQuDQoNCmBgYHtyfQ0KZml0LnBvaXMyIDwtIGdsbWVyKFNjaGl6b3BvcmVsbGEuZXJyYXRhIH4gTW9kaWZpY2F0aW9uICsgKDEgfCBFc3R1YXJ5KSwgZmFtaWx5ID0gcG9pc3NvbiwgZGF0YSA9IEVzdHVhcmllcykNCnBhcihtZnJvdyA9IGMoMSwgMikpDQpwbG90KHJlc2lkdWFscyhmaXQucG9pcykgfiBmaXR0ZWQoZml0LnBvaXMpLCBtYWluID0gInJlc2lkdWFscyB2cy4gRml0dGVkIikNCnFxbm9ybShyZXNpZHVhbHMoZml0LnBvaXMpKQ0KYGBgDQoNCkhlcmUgd2UgY2FuIHNlZSBhIGRpc3RpbmN0IGZhbiBzaGFwZSBpbiB0aGUgcmVzaWR1YWwgdnMuIGZpdHRlZCBwbG90LiBVbmZvcnR1bmF0ZWx5IGBsbWU0YCBjYW7igJl0IGhhbmRsZSB0aGlzIHNpdHVhdGlvbiAob3ZlcmRpc3BlcnNpb24pLCBhbmQgdGhlcmUgaXMgbm8gZWFzeSB3YXkgdG8gbW9kZWwgdGhlc2UgZGF0YS4gSWYgdGhpcyBoYXBwZW5zIGluIHlvdXIgZGF0YSB0cnkgdGhlIGBnbG1tQURNQmAgcGFja2FnZS4NCg0KDQoNCmBgYHtyLCB3YXJuaW5nPUZ9DQpmaXQucG9pcyA8LSBnbG1lcihIeWRyb2lkIH4gTW9kaWZpY2F0aW9uICsgKDEgfCBFc3R1YXJ5KSwgZmFtaWx5ID0gcG9pc3NvbiwgZGF0YSA9IEVzdHVhcmllcykNCm1lYW5zIDwtIGZpdHRlZChmaXQucG9pcykgIyB0aGlzIHdpbGwgZ2l2ZSB0aGUgZXN0aW1hdGUgYXQgZWFjaCBkYXRhIHBvaW50DQpNb2RFc3QgPC0gdW5pcXVlKEVzdHVhcmllc1tjKCJFc3R1YXJ5IiwgIk1vZGlmaWNhdGlvbiIpXSkgIyBmaW5kIHdoaWNoIEVzdHVhcmllcyBhcmUgbW9kaWZpZWQNCmNvbHMgPC0gYXMubnVtZXJpYyhNb2RFc3Rbb3JkZXIoTW9kRXN0WywgMV0pLCAyXSkgKyAzICMgQXNzaWduIGNvbG91ciBieSBtb2RpZmljYXRpb24NCmJveHBsb3QoSHlkcm9pZCB+IEVzdHVhcnksIGRhdGEgPSBFc3R1YXJpZXMsIGNvbCA9IGNvbHMsIHhsYWIgPSAiRXN0dWFyeSIsIHlsYWIgPSAiQ291bnQgb2YgaHlkcm9pZHMiKQ0KbGVnZW5kKCJ0b3BsZWZ0IiwNCiAgaW5zZXQgPSAuMDIsDQogIGMoIk1vZGlmaWVkIiwgIlByaXN0aW5lIiksIGZpbGwgPSB1bmlxdWUoY29scyksIGhvcml6ID0gVFJVRSwgY2V4ID0gMC44DQopDQoNCkVzdC5tZWFucyA8LSBzdW1tYXJpemUobWVhbnMsIEVzdHVhcmllcyRFc3R1YXJ5LCBtZWFuKSRtZWFucyAjIGV4dHJhY3QgbWVhbnMgYnkgRXN0dWFyeQ0Kc3RyaXBjaGFydChFc3QubWVhbnMgfiBzb3J0KHVuaXF1ZShFc3R1YXJ5KSksIGRhdGEgPSBFc3R1YXJpZXMsIHBjaCA9IDE4LCBjb2wgPSAicmVkIiwgdmVydGljYWwgPSBUUlVFLCBhZGQgPSBUUlVFKSAjIHBsb3QgbWVhbnMgYnkgZXN0dWFyeQ0KYGBgDQo+ICpTb3VyY2U6IEdvcmRhbmEgUG9wb3ZpYyoNCg0KDQojIEdlbmVyYWxpc2VkIGFkZGl0aXZlIG1vZGVscyAoR0FNKQ0KDQpNYW55IGRhdGEgaW4gdGhlIGVudmlyb25tZW50YWwgc2NpZW5jZXMgZG8gbm90IGZpdCBzaW1wbGUgbGluZWFyIG1vZGVscyBhbmQgYXJlIGJlc3QgZGVzY3JpYmVkIGJ5IOKAnHdpZ2dseSBtb2RlbHPigJ0sIGFsc28ga25vd24gYXMgR2VuZXJhbGlzZWQgQWRkaXRpdmUgTW9kZWxzIChHQU1zKS4gTGV0J3Mgc3RhcnQgYnkgYSB0d2VldCBmcm9tIGZhbW91cyBCaW9zdGF0aXN0aWNpYW5zIEdhdmluIEwuIFNpbXBzb246DQoNCioxLiBHQU1zIGFyZSBqdXN0IEdMTXMqDQoqMi4gR0FNcyBmaXQgd2lnZ2x5IHRlcm1zKg0KKjMuIHVzZSBgKyBzKHgpYCBub3QgYHhgIGluIHlvdXIgc3ludGF4Kg0KKjQuIHVzZSBgbWV0aG9kID0gIlJFTUwiYCoNCio1LiBhbHdheXMgbG9vayBhdCBgZ2FtLmNoZWNrKClgKg0KDQpUaGlzIGlzIGJhc2ljYWxseSBhbGwgdGhlcmUgaXMgdG9vIGl0IC0gYW4gZXh0ZW5zaW9uIG9mIGdlbmVyYWxpc2VkIGxpbmVhciBtb2RlbHMgKEdMTXMpIHdpdGggYSAqKnNtb290aGluZyBmdW5jdGlvbioqLiBPZiBjb3Vyc2UsIHRoZXJlIG1heSBiZSBtYW55IHNvcGhpc3RpY2F0ZWQgdGhpbmdzIGdvaW5nIG9uIHdoZW4geW91IGZpdCBhIG1vZGVsIHdpdGggc21vb3RoIHRlcm1zLCBidXQgeW91IG9ubHkgbmVlZCB0byB1bmRlcnN0YW5kIHRoZSByYXRpb25hbGUgYW5kIHNvbWUgYmFzaWMgdGhlb3J5Lg0KDQojIyBHQU1zIGluIGEgbnV0c2hlbGxzIChleHRyYSkNCg0KTGV04oCZcyBzdGFydCB3aXRoIGFuIGVxdWF0aW9uIGZvciBhIEdhdXNzaWFuIGxpbmVhciBtb2RlbDoNCg0KJCR5ID0gXGJldGFfMCArIFxiZXRhXzEqeF8xICsgXGVwc2lsb24gXDssIFxlcHNpbG9uIFxzaW0gTigwLFxzaWdtYV4yKSQkDQpXaGF0IGNoYW5nZXMgaW4gYSBHQU0gaXMgdGhlIHByZXNlbmNlIG9mIGEgc21vb3RoaW5nIHRlcm06DQoNCiQkeSA9IFxiZXRhXzAgKyBmKHhfMSkgKyBcZXBzaWxvbiBcOywgXGVwc2lsb24gXHNpbSBOKDAsXHNpZ21hXjIpJCQNClRoaXMgc2ltcGx5IG1lYW5zIHRoYXQgdGhlIGNvbnRyaWJ1dGlvbiB0byB0aGUgbGluZWFyIHByZWRpY3RvciBpcyBub3cgc29tZSBmdW5jdGlvbiAkZiQuIFRoaXMgaXMgbm90IHRoYXQgZGlzc2ltaWxhciBjb25jZXB0dWFsbHkgdG8gdXNpbmcgYSBxdWFkcmF0aWMgKCR4XzFeMiQpIG9yIGN1YmljIHRlcm0gKCR4XzFeMyQpIGFzIHlvdXIgcHJlZGljdG9yLg0KDQpUaGUgZnVuY3Rpb24gJGYkIGNhbiBiZSBzb21ldGhpbmcgbW9yZSBmdW5reSBvciBraW5reSAtIGhlcmUsIHdl4oCZcmUgZ29pbmcgdG8gZm9jdXMgb24gc3BsaW5lcy4gWW91IGNhbiBoYXZlIGNvbWJpbmF0aW9ucyBvZiBsaW5lYXIgYW5kIHNtb290aCB0ZXJtcyBpbiB5b3VyIG1vZGVsLCBmb3IgZXhhbXBsZToNCg0KDQokJHkgPSBcYmV0YV8wICsgXGJldGFfMSp4XzEgK2YoeF8yKSArIFxlcHNpbG9uIFw7LCBcZXBzaWxvbiBcc2ltIE4oMCxcc2lnbWFeMikkJA0Kb3Igd2UgY2FuIGZpdCBnZW5lcmFsaXNlZCBkaXN0cmlidXRpb25zIGFuZCByYW5kb20gZWZmZWN0cywgZm9yIGV4YW1wbGU6IA0KDQokJGxuKHkpID0gXGJldGFfMCArIGYoeF8xKSArIFxlcHNpbG9uIFw7LCBcZXBzaWxvbiBcc2ltIFBvaXNzb24oXGxhbWJkYSkkJA0KJCRsbih5KSA9IFxiZXRhXzAgKyBmKHhfMSkgKyB6XzEgXGdhbW1hICsgXGVwc2lsb24gIFw7LCBcZXBzaWxvbiBcc2ltIFBvaXNzb24oXGxhbWJkYSlcOywgXGdhbW1hIFxzaW0gTigwLCBcU2lnbWEpJCQNCg0KIyMgQSBzaW1wbGUgZXhhbXBsZQ0KDQpMZXTigJlzIGNyZWF0ZSBhIGRhdGEgZnJhbWUgYW5kIGZpbGwgaXQgd2l0aCBzb21lIHNpbXVsYXRlZCBkYXRhIHdpdGggYW4gb2J2aW91cyBub24tbGluZWFyIHRyZW5kIGFuZCBjb21wYXJlIGhvdyB3ZWxsIHNvbWUgbW9kZWxzIGZpdCB0byB0aGF0IGRhdGEuDQoNCmBgYHtyfQ0KeCA8LSBzZXEoMCwgcGkgKiAyLCAwLjEpDQpzaW5feCA8LSBzaW4oeCkNCnkgPC0gc2luX3ggKyBybm9ybShuID0gbGVuZ3RoKHgpLCBtZWFuID0gMCwgc2QgPSBzZChzaW5feCAvIDIpKQ0KU2FtcGxlX2RhdGEgPC0gZGF0YS5mcmFtZSh5LCB4KQ0KZ2dwbG90KFNhbXBsZV9kYXRhLCBhZXMoeCwgeSkpICsNCiAgZ2VvbV9wb2ludCgpDQpgYGANCkxldCdzIGZpdCBhIG5vcm1hbCBsaW5lYXIgbW9kZWwgYW5kIGNoZWNrIHJlc2lkdWFsczoNCg0KYGBge3J9DQpsbV95IDwtIGxtKHkgfiB4LCBkYXRhID0gU2FtcGxlX2RhdGEpDQpnZ3Bsb3QoU2FtcGxlX2RhdGEsIGFlcyh4LCB5KSkgKw0KICBnZW9tX3BvaW50KCkgKw0KICBnZW9tX3Ntb290aChtZXRob2QgPSBsbSkNCnBsb3QobG1feSwgd2hpY2ggPSAxKQ0KYGBgDQoNCkNsZWFybHksIHRoZSByZXNpZHVhbHMgYXJlIG5vdCBldmVubHkgc3ByZWFkIGFjcm9zcyB2YWx1ZXMgb2YgJHgkLCB0aGF0J3MgY2FsbCBhIHBhdHRlcm4gaW4gdGhlIHJlc2lkdWFscy4gV2UgbmVlZCB0byBjb25zaWRlciBhIGJldHRlciBtb2RlbC4NCg0KVGhlIHBhY2thZ2UgYG1nY3ZgIGlzIHRoZSBwYWNrYWdlIG9mIGNob2ljZSBmb3IgcnVubmluZyBHQU1zIGluIFIuIFRvIHJ1biBhIEdBTSwgd2UgdXNlOg0KDQpgYGB7cn0NCmdhbV95IDwtIGdhbSh5IH4gcyh4KSwgbWV0aG9kID0gIlJFTUwiKQ0KYGBgDQoNClRvIGV4dHJhY3QgdGhlIGZpdHRlZCB2YWx1ZXMsIHdlIGNhbiB1c2UgYHByZWRpY3RgIGp1c3QgbGlrZSBub3JtYWw6DQoNCg0KYGBge3J9DQp4X25ldyA8LSBzZXEoMCwgbWF4KHgpLCBsZW5ndGgub3V0ID0gMTAwKQ0KeV9wcmVkIDwtIHByZWRpY3QoZ2FtX3ksIGRhdGEuZnJhbWUoeCA9IHhfbmV3KSkNCmBgYA0KDQoNCkJ1dCBmb3Igc2ltcGxlIG1vZGVscywgd2UgY2FuIGFsc28gdXRpbGlzZSB0aGUgYG1ldGhvZCA9YCBhcmd1bWVudCBpbiBgZ2VvbV9zbW9vdGhgLCBzcGVjaWZ5aW5nIHRoZSBtb2RlbCBmb3JtdWxhLg0KDQoNCmBgYHtyfQ0KZ2dwbG90KFNhbXBsZV9kYXRhLCBhZXMoeCwgeSkpICsNCiAgZ2VvbV9wb2ludCgpICsNCiAgZ2VvbV9zbW9vdGgobWV0aG9kID0gImdhbSIsIGZvcm11bGEgPSB5IH4gcyh4KSkNCmBgYA0KDQpZb3UgY2FuIHNlZSB0aGUgbW9kZWwgaXMgYmV0dGVyIGZpdCB0byB0aGUgZGF0YSwgYnV0IGFsd2F5cyBjaGVjayB0aGUgZGlhZ25vc3RpY3MuDQoNCmBjaGVjay5nYW1gIGlzIHF1aWNrIGFuZCBlYXN5IHRvIHZpZXcgdGhlIHJlc2lkdWFsIHBsb3RzLg0KDQoNCmBgYHtyfQ0KcGFyKG1mcm93ID0gYygyLCAyKSkNCmdhbS5jaGVjayhnYW1feSkNCmBgYA0KDQpVc2luZyBzdW1tYXJ5IHdpdGggdGhlIG1vZGVsIG9iamVjdCB3aWxsIGdpdmUgeW91IHRoZSBzaWduaWZpY2FuY2Ugb2YgdGhlIHNtb290aCB0ZXJtIChhbG9uZyB3aXRoIGFueSBwYXJhbWV0cmljIHRlcm1zLCBpZiB5b3XigJl2ZSBpbmNsdWRlZCB0aGVtKSwgYWxvbmcgd2l0aCB0aGUgdmFyaWFuY2UgZXhwbGFpbmVkLiBJbiB0aGlzIGV4YW1wbGUsIGEgcHJldHR5IGRlY2VudCBmaXQuIFRoZSDigJhlZGbigJkgaXMgdGhlIGVzdGltYXRlZCBkZWdyZWVzIG9mIGZyZWVkb20gLSBlc3NlbnRpYWxseSwgdGhlIGxhcmdlciB0aGUgbnVtYmVyLCB0aGUgbW9yZSB3aWdnbHkgdGhlIGZpdHRlZCBtb2RlbC4gVmFsdWVzIG9mIGFyb3VuZCAxIHRlbmQgdG8gYmUgY2xvc2UgdG8gYSBsaW5lYXIgdGVybS4gWW91IGNhbiByZWFkIGFib3V0IHBlbmFsaXNhdGlvbiBhbmQgc2hyaW5rYWdlIGZvciBtb3JlIG9uIHdoYXQgdGhlIGVkZiByZWZsZWN0cy4NCg0KDQpBcyBtZW50aW9uZWQgYWJvdmUsIHdlIGZvY3VzIG9uICoqc3BsaW5lcyoqLCBhcyB0aGV5IGFyZSB0aGUgKipzbW9vdGggZnVuY3Rpb25zKiogdGhhdCBhcmUgbW9zdCBjb21tb25seSBpbXBsZW1lbnRlZCAoYW5kIGFyZSBwcmV0dHkgcXVpY2sgYW5kIHN0YWJsZSkuIFRoaXMgaXMgd2hlcmUgd2Ugc2F5IHdlIHdhbnQgdG8gZml0ICR5JCBhcyBhIGxpbmVhciBmdW5jdGlvbiBvZiBzb21lIHNldCBvZiBmdW5jdGlvbnMgb2YgICR4JA0KLiBUaGUgZGVmYXVsdCBpbiBgbWdjdmAgaXMgYSAqKnRoaW4gcGxhdGUgcmVncmVzc2lvbiBzcGxpbmUqKiAtIHRoZSB0d28gY29tbW9uIG9uZXMgeW914oCZbGwgcHJvYmFibHkgc2VlIGFyZSB0aGVzZSwgYW5kICoqY3ViaWMgcmVncmVzc2lvbiBzcGxpbmVzKiouIEN1YmljIHJlZ3Jlc3Npb24gc3BsaW5lcyBoYXZlIHRoZSB0cmFkaXRpb25hbCBrbm90cyB0aGF0IHdlIHRoaW5rIG9mIHdoZW4gd2UgdGFsayBhYm91dCBzcGxpbmVzIC0gdGhleeKAmXJlIGV2ZW5seSBzcHJlYWQgYWNyb3NzIHRoZSBjb3ZhcmlhdGUgcmFuZ2UgaW4gdGhpcyBjYXNlLiANCg0KIyMgQSByZWFsIHdvcmxkIGV4YW1wbGUgKGV4dHJhKQ0KDQpXZeKAmXJlIGdvaW5nIHRvIGxvb2sgYXQgc29tZSBDTzIgZGF0YSBmcm9tIE1hbnVhIExvYSAoSGF3YWlpKS4gV2Ugd2lsbCBmaXQgYSBjb3VwbGUgR0FNcyB0byB0aGUgZGF0YSB0byB0cnkgYW5kIHBpY2sgYXBhcnQgdGhlIGludHJhLSBhbmQgaW50ZXItYW5udWFsIHRyZW5kcy4gV2Ugd2FudCB0byBsb29rIGF0IGludGVyLWFubnVhbCB0cmVuZCBmaXJzdCwgc28gbGV04oCZcyBjb252ZXJ0IHRoZSBkYXRlIGludG8gYSBjb250aW51b3VzIHRpbWUgdmFyaWFibGUgKHRha2UgYSBzdWJzZXQgZm9yIHZpc3VhbGlzYXRpb24pLg0KDQoNCmBgYHtyfQ0KQ08yIDwtIHJlYWQuY3N2KCJkYXRhL21hdW5hX2xvYV9jbzIuY3N2IikNCkNPMiR0aW1lIDwtIGFzLmludGVnZXIoYXMuRGF0ZShDTzIkRGF0ZSwgZm9ybWF0ID0gIiVkLyVtLyVZIikpDQpDTzJfZGF0IDwtIENPMg0KQ08yIDwtIENPMl9kYXRbQ08yX2RhdCR5ZWFyICVpbiUgKDIwMDA6MjAxMCksIF0NCmBgYA0KDQpPSywgc28gbGV04oCZcyBwbG90IGl0IGFuZCBsb29rIGF0IGEgc21vb3RoIHRlcm0gZm9yIHRpbWUuDQoNCmBgYHtyfQ0KZ2dwbG90KENPMl9kYXQsIGFlcyh0aW1lLCBjbzIpKSArDQogIGdlb21fbGluZSgpDQpgYGANCg0KJCR5ID0gXGJldGFfMCArIGZfe3RyZW5kfSh0aW1lKSArIFxlcHNpbG9uIFw7LCBcZXBzaWxvbiBcc2ltIE4oMCxcc2lnbWFeMikkJA0KV2UgY2FuIGZpdCBhIEdBTSBmb3IgdGhlc2UgZGF0YSB1c2luZzoNCg0KDQpgYGB7cn0NCkNPMl90aW1lIDwtIGdhbShjbzIgfiBzKHRpbWUpLCBkYXRhID0gQ08yLCBtZXRob2QgPSAiUkVNTCIpDQpgYGANCg0Kd2hpY2ggZml0cyBhIG1vZGVsIHdpdGggYSBzaW5nbGUgc21vb3RoIHRlcm0gZm9yIHRpbWUuIFdlIGNhbiBsb29rIGF0IHRoZSBwcmVkaWN0ZWQgdmFsdWVzIGZvciB0aGlzOg0KDQpgYGB7cn0NCnBsb3QoQ08yX3RpbWUpDQpgYGANCg0KTm90ZSBob3cgdGhlIHNtb290aCB0ZXJtIGFjdHVhbGx5IHJlZHVjZXMgdG8gYSDigJhub3JtYWzigJkgbGluZWFyIHRlcm0gaGVyZSAod2l0aCBhbiBlZGYgb2YgMSkgLSB0aGF04oCZcyB0aGUgbmljZSB0aGluZyBhYm91dCBwZW5hbGlzZWQgcmVncmVzc2lvbiBzcGxpbmVzLiBCdXQgaWYgd2UgY2hlY2sgdGhlIG1vZGVsLCB0aGVuIHdlIHNlZSBzb21ldGhpbmcgaXMgYW11Y2suDQoNCmBgYHtyfQ0KcGFyKG1mcm93ID0gYygyLCAyKSkNCmdhbS5jaGVjayhDTzJfdGltZSkNCmBgYA0KVGhlIHJlc2lkdWFsIHBsb3RzIGhhdmUgYSB2ZXJ5IG9kZCBsb29raW5nIHJpc2UtYW5kLWZhbGwgcGF0dGVybiAtIGNsZWFybHkgdGhlcmUgaXMgc29tZSBkZXBlbmRhbmNlIHN0cnVjdHVyZSAoYW5kIHdlIGNhbiBwcm9iYWJseSBndWVzcyBpdCBoYXMgc29tZXRoaW5nIHRvIGRvIHdpdGggaW50cmEtYW5udWFsIGZsdWN0dWF0aW9ucykuIExldOKAmXMgdHJ5IGFnYWluLCBhbmQgaW50cm9kdWNlIHNvbWV0aGluZyBjYWxsZWQgYSBjeWNsaWNhbCBzbW9vdGhlci4NCg0KDQokJHkgPSBcYmV0YV8wICtmX3tpbnRyYW5udWFsfShtb250aCkrIGZfe3RyZW5kfSh0aW1lKSArIFxlcHNpbG9uIFw7LCBcZXBzaWxvbiBcc2ltIE4oMCxcc2lnbWFeMikkJA0KDQpUaGUgY3ljbGljYWwgc21vb3RoIHRlcm0sICRmX3tpbnRyYW5udWFsfShtb250aCkkLCBpcyBjb21wcmlzZWQgb2YgYmFzaXMgZnVuY3Rpb25zIGp1c3QgdGhlIHNhbWUgYXMgd2UgaGF2ZSBzZWVuIGFscmVhZHksIGV4Y2VwdCB0aGF0IHRoZSBlbmQgcG9pbnRzIG9mIHRoZSBzcGxpbmUgYXJlIGNvbnN0cmFpbmVkIHRvIGJlIGVxdWFsIC0gd2hpY2ggbWFrZXMgc2Vuc2Ugd2hlbiB3ZeKAmXJlIG1vZGVsbGluZyBhIHZhcmlhYmxlIHRoYXQgaXMgKmN5Y2xpY2FsKiAoYWNyb3NzIG1vbnRocy95ZWFycykuDQoNCldl4oCZbGwgbm93IHNlZSB0aGUgYGJzID1gIGFyZ3VtZW50IHRvIGNob29zZSB0aGUgdHlwZSBvZiBzbW9vdGhlciwgYW5kIHRoZSBgayA9YCBhcmd1bWVudCB0byBjaG9vc2UgdGhlIG51bWJlciBvZiBrbm90cywgYmVjYXVzZSBjdWJpYyByZWdyZXNzaW9uIHNwbGluZXMgaGF2ZSBhIHNldCBudW1iZXIgb2Yga25vdHMuIFdlIHVzZSAxMiBrbm90cywgYmVjYXVzZSB0aGVyZSBhcmUgMTIgbW9udGhzLg0KDQpgYGB7cn0NCkNPMl9zZWFzb25fdGltZSA8LSBnYW0oY28yIH4gcyhtb250aCwgYnMgPSAiY2MiLCBrID0gMTIpICsgcyh0aW1lKSwgZGF0YSA9IENPMiwgbWV0aG9kID0gIlJFTUwiKQ0KYGBgDQoNCkxldOKAmXMgbG9vayBhdCB0aGUgZml0dGVkIHNtb290aCB0ZXJtczoNCg0KYGBge3J9DQpwYXIobWZyb3cgPSBjKDEsIDIpKQ0KcGxvdChDTzJfc2Vhc29uX3RpbWUpDQpgYGANCg0KTG9va2luZyBhdCBib3RoIHNtb290aCB0ZXJtcywgd2UgY2FuIHNlZSB0aGF0IHRoZSBtb250aGx5IHNtb290aGVyIGlzIHBpY2tpbmcgdXAgdGhhdCBtb250aGx5IHJpc2UgYW5kIGZhbGwgb2YgQ08yDQogLSBsb29raW5nIGF0IHRoZSByZWxhdGl2ZSBtYWduaXR1ZGVzIChpLmUuIG1vbnRobHkgZmx1Y3R1YXRpb24gdnMuIGxvbmctdGVybSB0cmVuZCksIHdlIGNhbiBzZWUgaG93IGltcG9ydGFudCBpdCBpcyB0byBkaXNpbnRhbmdsZSB0aGUgY29tcG9uZW50cyBvZiB0aGUgdGltZSBzZXJpZXMuIExldOKAmXMgc2VlIGhvdyB0aGUgbW9kZWwgZGlhZ25vc3RpY3MgbG9vayBub3c6DQoNCg0KYGBge3J9DQpwYXIobWZyb3cgPSBjKDIsIDIpKQ0KZ2FtLmNoZWNrKENPMl9zZWFzb25fdGltZSkNCmBgYA0KTXVjaCBiZXR0ZXIuIExldOKAmXMgbG9vayBhdCBob3cgdGhlIHNlYXNvbmFsIGNvbXBvbmVudCBzdGFja3MgdXAgYWdhaW5zdCB0aGUgZnVsbCBsb25nIHRlcm0gdHJlbmQuDQoNCmBgYHtyfQ0KQ08yX3NlYXNvbl90aW1lIDwtIGdhbShjbzIgfiBzKG1vbnRoLCBicyA9ICJjYyIsIGsgPSAxMikgKyBzKHRpbWUpLCBkYXRhID0gQ08yX2RhdCwgbWV0aG9kID0gIlJFTUwiKQ0KcGFyKG1mcm93ID0gYygxLCAyKSkNCnBsb3QoQ08yX3NlYXNvbl90aW1lKQ0KYGBgDQoNCg0KWW91IGNhbiBlc3NlbnRpYWxseSBwcmVzZW50IG1vZGVsIHJlc3VsdHMgZnJvbSBhIEdBTSBhcyBpZiBpdCB3ZXJlIGFueSBvdGhlciBsaW5lYXIgbW9kZWwsIHRoZSBtYWluIGRpZmZlcmVuY2UgYmVpbmcgdGhhdCBmb3IgdGhlIHNtb290aCB0ZXJtcywgdGhlcmUgaXMgbm8gc2luZ2xlIGNvZWZmaWNpZW50IHlvdSBjYW4gbWFrZSBpbmZlcmVuY2UgZnJvbSAoaS5lLiBuZWdhdGl2ZSwgcG9zaXRpdmUsIGVmZmVjdCBzaXplIGV0Yy4pLiBTbyB5b3UgbmVlZCB0byByZWx5IG9uIGVpdGhlciBpbnRlcnByZXR0aW5nIHRoZSBwYXJpdGFsIGVmZmVjdHMgb2YgdGhlIHNtb290aCB0ZXJtcyB2aXN1YWxseSAoZS5nLiBmcm9tIGEgY2FsbCB0byBgcGxvdChnYW1fbW9kZWwpYCkgb3IgbWFrZSBpbmZlcmVuY2UgZnJvbSB0aGUgcHJlZGljdGVkIHZhbHVlcy4gWW91IGNhbiBvZiBjb3Vyc2UgaW5jbHVkZSBub3JtYWwgbGluZWFyIHRlcm1zIGluIHRoZSBtb2RlbCAoZWl0aGVyIGNvbnRpbnVvdXMgb3IgY2F0ZWdvcmljYWwsIGFuZCBpbiBhbiBBTk9WQSB0eXBlIGZyYW1ld29yayBldmVuKSBhbmQgbWFrZSBpbmZlcmVuY2UgZnJvbSB0aGVtIGxpa2UgeW91IG5vcm1hbGx5IHdvdWxkLiBJbmRlZWQsIEdBTXMgYXJlIG9mdGVuIHVzZWZ1bCBmb3IgYWNjb3VudGluZyBmb3IgYSBub24tbGluZWFyIHBoZW5vbW9ub24gdGhhdCBpcyBub3QgZGlyZWN0bHkgb2YgaW50ZXJlc3QsIGJ1dCBuZWVkcyB0byBiZSBhY29jdW50ZWQgZm9yIHdoZW4gbWFraW5nIGluZmVyZWNlIGFib3V0IG90aGVyIHZhcmlhYmxlcy4NCg0KDQpgYGB7cn0NCkNPMl9wcmVkIDwtIGRhdGEuZnJhbWUoDQogIHRpbWUgPSBDTzJfZGF0JHRpbWUsDQogIGNvMiA9IENPMl9kYXQkY28yLA0KICBwcmVkaWN0ZWRfdmFsdWVzID0gcHJlZGljdChDTzJfc2Vhc29uX3RpbWUsIG5ld2RhdGEgPSBDTzJfZGF0KQ0KKQ0KZ2dwbG90KENPMl9wcmVkLCBhZXMoeCA9IHRpbWUpKSArDQogIGdlb21fcG9pbnQoYWVzKHkgPSBjbzIpLCBzaXplID0gMSwgYWxwaGEgPSAwLjUpICsNCiAgZ2VvbV9saW5lKGFlcyh5ID0gcHJlZGljdGVkX3ZhbHVlcyksIGNvbG91ciA9ICJyZWQiKQ0KDQpgYGANCg0KVGhlcmXigJlzIG1vcmUgdG8gdGhlIHN0b3J5IC0gcGVyaGFwcyBzcGF0aWFsIGF1dG9jb3JyZWxhdGlvbiBvZiBzb21lIGtpbmQgLSBidXQgd2Ugd2lsbCBlbmQgaXQgZm9yIHRvZGF5LiBBIGdyZWF0IGJsb2cgd2l0aCBsb3RzIG9mIHN0dWZmIG9uIEdBTXM6IGh0dHBzOi8vd3d3LmZyb210aGVib3R0b21vZnRoZWhlYXAubmV0Lw0KDQoNCj4gKlNvdXJjZTogTWl0Y2hlbGwgTHlvbnMqDQoNCg0KPiBSZWZlcmVuY2VzOg0KDQpCcnVjZSwgUC4sIEJydWNlLCBBLiAoMjAxNykuIFByYXRpY2FsIFN0YXRpc3RpY3MgZm9yIERhdGEgU2NpZW50aXN0cy4gTydSZWlsbHkgTWVkaWEsIEluYy4NCg0KUGXDsWEsIEUuIEEuLCAmIFNsYXRlLCBFLiBILiAoMjAwNikuIEdsb2JhbCB2YWxpZGF0aW9uIG9mIGxpbmVhciBtb2RlbCBhc3N1bXB0aW9ucy4gSm91cm5hbCBvZiB0aGUgQW1lcmljYW4gU3RhdGlzdGljYWwgQXNzb2NpYXRpb24sIDEwMSg0NzMpLCAzNDEtMzU0Lg0K" download="stat_2.Rmd">Download stat_2.Rmd</a>
<a href="data:text/plain;base64,eGFyaW5nYW5FeHRyYTo6dXNlX2NsaXBib2FyZCgpDQoNCg0KDQoNCg0KDQoNCg0KDQoNCg0KDQoNCg0KDQoNCg0KbGlicmFyeShndmxtYSkNCmxpYnJhcnkoSG1pc2MpDQpsaWJyYXJ5KGNvcnJwbG90KQ0KbGlicmFyeShtdmFidW5kKQ0KbGlicmFyeShnZ3Bsb3QyKQ0KbGlicmFyeSAobG1lNCkNCmxpYnJhcnkobWdjdikNCg0Ka25pdHI6OmluY2x1ZGVfZ3JhcGhpY3MoImlsbHVzdHJhdGlvbnMvbGluZWFyLXJlZ3Jlc3Npb24ucG5nIikNCg0KUGxhbnRfaGVpZ2h0IDwtIHJlYWQuY3N2KGZpbGUgPSAiRGF0YS9QbGFudF9oZWlnaHQuY3N2IiwgaGVhZGVyID0gVFJVRSkNCg0KbW9kMV9wbGFudDwtIGxtKGxvZ2h0IH4gdGVtcCwgZGF0YSA9IFBsYW50X2hlaWdodCkNCg0KbW9kMV9wbGFudCRjb2VmZmljaWVudHMNCg0Kc3VtbWFyeShtb2QxX3BsYW50KQ0KDQpjb25maW50KG1vZDFfcGxhbnQpDQoNCnNpZ21hKG1vZDFfcGxhbnQpKjEwMC9tZWFuKFBsYW50X2hlaWdodCRsb2dodCkNCg0KIyMgZml0dGVkKG1vZDFfcGxhbnQpICMgcHJlZGljdGVkIHZhbHVlcw0KIyMgcmVzaWR1YWxzKG1vZDFfcGxhbnQpICMgcmVzaWR1YWxzDQojIyBhbm92YShtb2QxX3BsYW50KSAjIGFub3ZhIHRhYmxlDQojIyB2Y292KG1vZDFfcGxhbnQpICMgY292YXJpYW5jZSBtYXRyaXggZm9yIG1vZGVsIHBhcmFtZXRlcnMNCiMjIGluZmx1ZW5jZShtb2QxX3BsYW50KSAjIHJlZ3Jlc3Npb24gZGlhZ25vc3RpY3MNCg0KcGxvdChtb2QxX3BsYW50LCB3aGljaCA9IDEpDQoNCnBhcihtZnJvdyA9IGMoMSwgMikpICMgVGhpcyBjb2RlIHB1dCB0d28gcGxvdHMgaW4gdGhlIHNhbWUgd2luZG93DQpoaXN0KG1vZDFfcGxhbnQkcmVzaWR1YWxzKSAjIEhpc3RvZ3JhbSBvZiByZXNpZHVhbHMNCnBsb3QobW9kMV9wbGFudCwgd2hpY2ggPSAyKSAjIFF1YW50aWxlIHBsb3QNCg0KZ3Ztb2RlbCA8LSBndmxtYShtb2QxX3BsYW50KQ0Kc3VtbWFyeShndm1vZGVsKQ0KDQptb2QyX3BsYW50PC0gbG0obG9naHQgfiB0ZW1wICsgYWx0ICsgcmFpbiwgZGF0YSA9IFBsYW50X2hlaWdodCkNCg0KDQpwbGFudF9wcmVkaWN0b3I8LWRhdGEuZnJhbWUoUGxhbnRfaGVpZ2h0JHRlbXAsUGxhbnRfaGVpZ2h0JGFsdCxQbGFudF9oZWlnaHQkcmFpbikNCmNvcnI8LWNvcihwbGFudF9wcmVkaWN0b3IpDQpwLnZhbDwtcmNvcnIoYXMubWF0cml4KHBsYW50X3ByZWRpY3RvcikpJFANCmNvcnJwbG90KGNvcnIsdHlwZT0ndXBwZXInLG1ldGhvZD0nY29sb3InLCBhZGRDb2VmLmNvbCA9ICJibGFjayIsICBwLm1hdD1hcy5tYXRyaXgocC52YWwpLCBzaWcubGV2ZWwgPSAwLjA1LGRpYWc9RikNCg0KIyBFdmFsdWF0ZSBDb2xsaW5lYXJpdHkNCmNhcjo6dmlmKG1vZDJfcGxhbnQpICMgdmFyaWFuY2UgaW5mbGF0aW9uIGZhY3RvcnMNCnNxcnQoY2FyOjp2aWYobW9kMl9wbGFudCkpID4gMiAjIHByb2JsZW0/DQoNCnN1bW1hcnkobW9kMl9wbGFudCkNCnBhcihtZnJvdyA9IGMoMiwgMikpDQpwbG90KG1vZDJfcGxhbnQpDQoNCg0KbW9kM19wbGFudDwtbG0oZm9ybXVsYSA9IGxvZ2h0IH4gdGVtcCArIHJhaW4sIGRhdGEgPSBQbGFudF9oZWlnaHQpDQpCSUMobW9kMV9wbGFudCk7IEJJQyhtb2QyX3BsYW50KTsgQklDKG1vZDNfcGxhbnQpDQpBSUMobW9kMV9wbGFudCk7IEFJQyhtb2QyX3BsYW50KTsgQUlDKG1vZDNfcGxhbnQpDQoNCnR1cnRsZXMgPC0gcmVhZC5jc3YoZmlsZSA9ICJkYXRhL3R1cnRsZXMuY3N2IiwgaGVhZGVyID0gVFJVRSkNCnN0cih0dXJ0bGVzKQ0KDQp0dXJ0bGVzJFRlbXBlcmF0dXJlIDwtIGZhY3Rvcih0dXJ0bGVzJFRlbXBlcmF0dXJlKQ0KYm94cGxvdChEYXlzIH4gVGVtcGVyYXR1cmUsIGRhdGEgPSB0dXJ0bGVzLCB5bGFiID0gIkhhdGNoaW5nIHRpbWUgKGRheXMpIiwgeGxhYiA9ICJUZW1wZXJhdHVyZSAoQykiKQ0KDQp0dXJ0bGVzLmFvdiA8LSBhb3YoRGF5cyB+IFRlbXBlcmF0dXJlLCBkYXRhID0gdHVydGxlcykNCnN1bW1hcnkodHVydGxlcy5hb3YpDQoNCnR1cnRsZXMubG0gPC0gbG0oRGF5cyB+IFRlbXBlcmF0dXJlLCBkYXRhID0gdHVydGxlcykNCmFub3ZhKHR1cnRsZXMubG0pIA0KDQpzdW1tYXJ5KHR1cnRsZXMubG0pDQoNClR1a2V5SFNEKHR1cnRsZXMuYW92KQ0KDQpwYXIobWZyb3cgPSBjKDEsIDMpKSAjIFRoaXMgY29kZSBwdXQgdHdvIHBsb3RzIGluIHRoZSBzYW1lIHdpbmRvdw0KaGlzdCh0dXJ0bGVzLmFvdiRyZXNpZHVhbHMpDQpwbG90KHR1cnRsZXMuYW92LCB3aGljaCA9IDIpDQpwbG90KHR1cnRsZXMuYW92LCB3aGljaCA9IDEpDQoNCnNlc3NpbGUgPC0gcmVhZC5jc3YoZmlsZSA9ICJkYXRhL3Nlc3NpbGUuY3N2IiwgaGVhZGVyID0gVFJVRSkNCiMgY2hlY2sgeW91ciBwcmVkaWN0b3JzIHdpdGggYHN0cmANCmJveHBsb3QoUmljaG5lc3MgfiBDb3BwZXIgKiBPcmllbnRhdGlvbiwgZGF0YSA9IHNlc3NpbGUsIG5hbWVzID0gYygiSGlnaC5IIiwgIkxvdy5IIiwgIk5vbmUuSCIsICJIaWdoLlYiLCAiTG93LlYiLCAiTm9uZS5WIiksIHlsYWIgPSAiU3BlY2llcyByaWNobmVzcyIsIHhsYWIgPSAiQ29wcGVyL09yaWVudGF0aW9uIiwgeWxpbSA9IGMoMCwgODApKQ0KDQpzZXNzaWxlLmFvdiA8LSBhb3YoUmljaG5lc3MgfiBDb3BwZXIgKiBPcmllbnRhdGlvbiwgZGF0YSA9IHNlc3NpbGUpDQojIHNhbWUgYXM6DQpzZXNzaWxlLmFvdiA8LSBhb3YoUmljaG5lc3MgfiBDb3BwZXIgKyBPcmllbnRhdGlvbiArIENvcHBlcjpPcmllbnRhdGlvbiwgZGF0YSA9IHNlc3NpbGUpDQpzdW1tYXJ5KHNlc3NpbGUuYW92KQ0KDQojIHNhbWUgYXM6DQpzZXNzaWxlLmxtIDwtIGxtKFJpY2huZXNzIH4gQ29wcGVyICogT3JpZW50YXRpb24sIGRhdGEgPSBzZXNzaWxlKQ0KYW5vdmEoc2Vzc2lsZS5sbSkNCg0KaW50ZXJhY3Rpb24ucGxvdChzZXNzaWxlJENvcHBlciwgc2Vzc2lsZSRPcmllbnRhdGlvbiwgc2Vzc2lsZSRSaWNobmVzcykNCg0KIyBJbnB1dCBkYXRhIGZpbGUgYW5kIGNoZWNrIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGRhdGENCm1pbmsgPC0gcmVhZC5jc3YoZmlsZSA9ICJkYXRhL21pbmsuY3N2IiwgaGVhZGVyID0gVFJVRSkNCiMgZ3JvdXBlZCBib3hwbG90DQpnZ3Bsb3QobWluaywgYWVzKHg9VHJlYXRtZW50LCB5PVZvbGVzLCBmaWxsPUFyZWEpKSArIA0KICAgIGdlb21fYm94cGxvdCgpDQoNCk1pbmsubmVzdGVkIDwtIGFvdihWb2xlcyB+IFRyZWF0bWVudCArIEFyZWEgJWluJSBUcmVhdG1lbnQsIGRhdGEgPSBtaW5rKQ0Kc3VtbWFyeShNaW5rLm5lc3RlZCkNCg0KQ3JhYl9QQSA8LSByZWFkLmNzdigiZGF0YS9jcmFicy5jc3YiLCBoZWFkZXIgPSBUKQ0KaGVhZChDcmFiX1BBKQ0KDQpmdC5jcmFiIDwtIGdsbShDcmFiUHJlcyB+IFRpbWUgKiBEaXN0LCBmYW1pbHkgPSBiaW5vbWlhbCwgZGF0YSA9IENyYWJfUEEpDQoNCnBsb3QoZnQuY3JhYiwgd2hpY2ggPSAxKQ0KDQpmdC5jcmFiLm1hbnkgPC0gbWFueWdsbShDcmFiUHJlcyB+IFRpbWUgKiBEaXN0LCBmYW1pbHkgPSAiYmlub21pYWwiLCBkYXRhID0gQ3JhYl9QQSkNCnBsb3QoZnQuY3JhYi5tYW55KQ0KDQphbm92YShmdC5jcmFiLCB0ZXN0ID0gIkNoaXNxIikNCg0KYW5vdmEoZnQuY3JhYi5tYW55KQ0KDQpzdW1tYXJ5KGZ0LmNyYWIpDQoNClJldmVnIDwtIHJlYWQuY3N2KCJkYXRhL3JldmVnZXRhdGlvbi5jc3YiLCBoZWFkZXIgPSBUKQ0KaGVhZChSZXZlZykNCg0KaGlzdChSZXZlZyRTb2xlb2xpZmVyYSkNCg0KZnQuc29sLnBvaXMgPC0gbWFueWdsbShTb2xlb2xpZmVyYSB+IFRyZWF0bWVudCwgZmFtaWx5ID0gInBvaXNzb24iLCBkYXRhID0gUmV2ZWcpDQoNCnBsb3QoZnQuc29sLnBvaXMpDQoNCmZ0LnNvbC5uYiA8LSBtYW55Z2xtKFNvbGVvbGlmZXJhIH4gVHJlYXRtZW50LCBmYW1pbHkgPSAibmVnYXRpdmUgYmlub21pYWxlIiwgZGF0YSA9IFJldmVnKQ0KDQpwbG90KGZ0LnNvbC5uYikNCg0KYW5vdmEoZnQuc29sLm5iKQ0Kc3VtbWFyeShmdC5zb2wubmIpDQoNCmZ0LnNvbC5uYiRjb2VmZmljaWVudHMNCg0KYm94cGxvdChTb2xlb2xpZmVyYSB+IFRyZWF0bWVudCwgeWxhYiA9ICJDb3VudCIsIHhsYWIgPSAiVHJlYXRtZW50IiwgZGF0YSA9IFJldmVnKQ0KDQpFc3R1YXJpZXMgPC0gcmVhZC5jc3YoImRhdGEvZXN0dWFyaWVzLmNzdiIsIGhlYWRlciA9IFQpDQoNCmZ0LmVzdHUgPC0gbG1lcihUb3RhbCB+IE1vZGlmaWNhdGlvbiArICgxIHwgRXN0dWFyeSksIGRhdGEgPSBFc3R1YXJpZXMsIFJFTUwgPSBUKQ0KDQpxcW5vcm0ocmVzaWR1YWxzKGZ0LmVzdHUpKQ0KDQpzY2F0dGVyLnNtb290aChyZXNpZHVhbHMoZnQuZXN0dSkgfiBmaXR0ZWQoZnQuZXN0dSkpDQoNCmZ0LmVzdHUgPC0gbG1lcihUb3RhbCB+IE1vZGlmaWNhdGlvbiArICgxIHwgRXN0dWFyeSksIGRhdGEgPSBFc3R1YXJpZXMsIFJFTUwgPSBGKQ0KZnQuZXN0dS4wIDwtIGxtZXIoVG90YWwgfiAoMSB8IEVzdHVhcnkpLCBkYXRhID0gRXN0dWFyaWVzLCBSRU1MID0gRikNCg0KYW5vdmEoZnQuZXN0dS4wLCBmdC5lc3R1KQ0KDQpjb25maW50KGZ0LmVzdHUpDQoNCm5Cb290IDwtIDEwMDANCmxyU3RhdCA8LSByZXAoTkEsIG5Cb290KQ0KZnQubnVsbCA8LSBsbShUb3RhbCB+IE1vZGlmaWNhdGlvbiwgZGF0YSA9IEVzdHVhcmllcykgIyBudWxsIG1vZGVsDQpmdC5hbHQgPC0gbG1lcihUb3RhbCB+IE1vZGlmaWNhdGlvbiArICgxIHwgRXN0dWFyeSksIGRhdGEgPSBFc3R1YXJpZXMsIFJFTUwgPSBGKSAjIGFsdGVybmF0ZSBtb2RlbA0KbHJPYnMgPC0gMiAqIGxvZ0xpayhmdC5hbHQpIC0gMiAqIGxvZ0xpayhmdC5udWxsKSAjIG9ic2VydmVkIHRlc3Qgc3RhdA0KZm9yIChpQm9vdCBpbiAxOm5Cb290KQ0Kew0KICBFc3R1YXJpZXMkVG90YWxTaW0gPC0gdW5saXN0KHNpbXVsYXRlKGZ0Lm51bGwpKSAjIHJlc2FtcGxlZCBkYXRhDQogIGJOdWxsIDwtIGxtKFRvdGFsU2ltIH4gTW9kaWZpY2F0aW9uLCBkYXRhID0gRXN0dWFyaWVzKSAjIG51bGwgbW9kZWwNCiAgYkFsdCA8LSBsbWVyKFRvdGFsU2ltIH4gTW9kaWZpY2F0aW9uICsgKDEgfCBFc3R1YXJ5KSwgZGF0YSA9IEVzdHVhcmllcywgUkVNTCA9IEYpICMgYWx0ZXJuYXRlIG1vZGVsDQogIGxyU3RhdFtpQm9vdF0gPC0gMiAqIGxvZ0xpayhiQWx0KSAtIDIgKiBsb2dMaWsoYk51bGwpICMgcmVzYW1wbGVkIHRlc3Qgc3RhdA0KfQ0KbWVhbihsclN0YXQgPiBsck9icykgIyBQLXZhbHVlIGZvciB0ZXN0IG9mIEVzdHVhcnkgZWZmZWN0DQoNCk1vZEVzdCA8LSB1bmlxdWUoRXN0dWFyaWVzW2MoIkVzdHVhcnkiLCAiTW9kaWZpY2F0aW9uIildKSAjIGZpbmQgd2hpY2ggRXN0dWFyaWVzIGFyZSBtb2RpZmllZA0KDQojIFByZXBhcmUgYSB2ZWN0b3Igb2YgY29sb3JzIHdpdGggc3BlY2lmaWMgY29sb3IgYnkgbW9kaWZpY2F0aW9uIGxldmVscw0KbXlDb2xvcnMgPC0gaWZlbHNlKHVuaXF1ZShNb2RFc3QkTW9kaWZpY2F0aW9uKSA9PSAiTW9kaWZpZWQiLCByZ2IoMC4xLCAwLjEsIDAuNywgMC41KSwNCiAgaWZlbHNlKHVuaXF1ZShNb2RFc3QkTW9kaWZpY2F0aW9uKSA9PSAiUHJpc3RpbmUiLCByZ2IoMC44LCAwLjEsIDAuMywgMC42KSwNCiAgICAiZ3JleTkwIg0KICApDQopDQoNCmJveHBsb3QoVG90YWwgfiBFc3R1YXJ5LCBkYXRhID0gRXN0dWFyaWVzLCBjb2wgPSBteUNvbG9ycywgeGxhYiA9ICJFc3R1YXJ5IiwgeWxhYiA9ICJUb3RhbCBpbnZlcnRlYnJhdGVzIikNCmxlZ2VuZCgiYm90dG9tbGVmdCIsDQogIGluc2V0ID0gLjAyLA0KICBjKCIgTW9kaWZpZWQgIiwgIiBQcmlzdGluZSAiKSwgZmlsbCA9IHVuaXF1ZShteUNvbG9ycyksIGhvcml6ID0gVFJVRSwgY2V4ID0gMC44DQopDQoNCiMgMCBpZiBNb2RpZmllZCwgMSBpZiBQcmlzdGluZQ0KaXMubW9kIDwtIGlmZWxzZSh1bmlxdWUoTW9kRXN0JE1vZGlmaWNhdGlvbikgPT0gIk1vZGlmaWVkIiwgMCwNCiAgaWZlbHNlKHVuaXF1ZShNb2RFc3QkTW9kaWZpY2F0aW9uKSA9PSAiUHJpc3RpbmUiLCAxLCBOQSkNCikNCg0KRXN0Lm1lYW5zIDwtIGNvZWYoZnQuZXN0dSkkRXN0dWFyeVssIDFdICsgY29lZihmdC5lc3R1KSRFc3R1YXJ5WywgMl0gKiBpcy5tb2QgIyBNb2RlbCBtZWFucw0KDQpzdHJpcGNoYXJ0KEVzdC5tZWFucyB+IHNvcnQodW5pcXVlKEVzdHVhcnkpKSwgZGF0YSA9IEVzdHVhcmllcywgcGNoID0gMTgsIGNvbCA9ICJyZWQiLCB2ZXJ0aWNhbCA9IFRSVUUsIGFkZCA9IFRSVUUpDQoNCkVzdHVhcmllc1sxOjEwLCBdDQp4dGFicyh+IEVzdHVhcnkgKyBTaXRlLCBFc3R1YXJpZXMsIHNwYXJzZSA9IFRSVUUpDQoNCkVzdHVhcmllcyRTaXRlIDwtIGFzLmZhY3RvcihFc3R1YXJpZXMkU2l0ZSkNCkVzdHVhcmllcyRTaXRlV2l0aGluIDwtIHBhc3RlMChFc3R1YXJpZXMkRXN0dWFyeSwgIl8iLCBFc3R1YXJpZXMkU2l0ZSkNCg0KeHRhYnMofiBFc3R1YXJ5ICsgU2l0ZVdpdGhpbiwgRXN0dWFyaWVzLCBzcGFyc2UgPSBUUlVFKQ0KDQpmaXQubW9kIDwtIGxtZXIoVG90YWwgfiBNb2RpZmljYXRpb24gKyAoMSB8IEVzdHVhcnkpICsgKDEgfCBTaXRlV2l0aGluKSwgZGF0YSA9IEVzdHVhcmllcykNCiMgc2FtZSBhczogbG1lcihUb3RhbCB+IE1vZGlmaWNhdGlvbiArICgxIHwgRXN0dWFyeS9TaXRlV2l0aGluKSwgZGF0YSA9IEVzdHVhcmllcykNCnN1bW1hcnkoZml0Lm1vZCkNCg0KZml0Lndyb25nIDwtIGxtZXIoVG90YWwgfiBNb2RpZmljYXRpb24gKyAoMSB8IEVzdHVhcnkpICsgKDEgfCBTaXRlKSwgZGF0YSA9IEVzdHVhcmllcykNCnN1bW1hcnkoZml0Lndyb25nKQ0KDQpwYXIobWZyb3cgPSBjKDEsIDIpKQ0KcXFub3JtKHJlc2lkdWFscyhmaXQubW9kKSkNCnNjYXR0ZXIuc21vb3RoKHJlc2lkdWFscyhmaXQubW9kKSB+IGZpdHRlZChmaXQubW9kKSkgIyByZXNpZHVhbCBwbG90DQoNCmZpdC5tb2QgPC0gbG1lcihsb2coVG90YWwpIH4gTW9kaWZpY2F0aW9uICsgKDEgfCBFc3R1YXJ5KSArICgxIHwgU2l0ZVdpdGhpbiksIGRhdGEgPSBFc3R1YXJpZXMpDQpwYXIobWZyb3cgPSBjKDEsIDIpKQ0KcXFub3JtKHJlc2lkdWFscyhmaXQubW9kKSkNCnNjYXR0ZXIuc21vb3RoKHJlc2lkdWFscyhmaXQubW9kKSB+IGZpdHRlZChmaXQubW9kKSkgIyByZXNpZHVhbCBwbG90DQoNCmZ0Lm1vZCA8LSBsbWVyKGxvZyhUb3RhbCkgfiBNb2RpZmljYXRpb24gKyAoMSB8IEVzdHVhcnkpICsgKDEgfCBTaXRlV2l0aGluKSwgZGF0YSA9IEVzdHVhcmllcywgUkVNTCA9IEYpDQpmdC5tb2QuMCA8LSBsbWVyKGxvZyhUb3RhbCkgfiAoMSB8IEVzdHVhcnkpICsgKDEgfCBTaXRlV2l0aGluKSwgZGF0YSA9IEVzdHVhcmllcywgUkVNTCA9IEYpDQphbm92YShmdC5tb2QuMCwgZnQubW9kKQ0KDQpuQm9vdCA8LSAxMDAwDQpsclN0YXQgPC0gcmVwKE5BLCBuQm9vdCkNCmZ0Lm51bGwgPC0gbG1lcihsb2coVG90YWwpIH4gTW9kaWZpY2F0aW9uICsgKDEgfCBFc3R1YXJ5KSwgRXN0dWFyaWVzLCBSRU1MID0gRikgIyBudWxsIG1vZGVsDQpmdC5hbHQgPC0gbG1lcihsb2coVG90YWwpIH4gTW9kaWZpY2F0aW9uICsgKDEgfCBFc3R1YXJ5KSArICgxIHwgU2l0ZVdpdGhpbiksIEVzdHVhcmllcywgUkVNTCA9IEYpICMgYWx0ZXJuYXRlIG1vZGVsDQpsck9icyA8LSAyICogbG9nTGlrKGZ0LmFsdCkgLSAyICogbG9nTGlrKGZ0Lm51bGwpICMgb2JzZXJ2ZWQgdGVzdCBzdGF0DQpmb3IgKGlCb290IGluIDE6bkJvb3QpDQp7DQogIEVzdHVhcmllcyRsb2dUb3RhbFNpbSA8LSB1bmxpc3Qoc2ltdWxhdGUoZnQubnVsbCkpICMgcmVzYW1wbGVkIGRhdGENCiAgYk51bGwgPC0gbG1lcihsb2dUb3RhbFNpbSB+IE1vZGlmaWNhdGlvbiArICgxIHwgRXN0dWFyeSksIEVzdHVhcmllcywgUkVNTCA9IEYpICMgbnVsbCBtb2RlbA0KICBiQWx0IDwtIGxtZXIobG9nVG90YWxTaW0gfiBNb2RpZmljYXRpb24gKyAoMSB8IEVzdHVhcnkpICsgKDEgfCBTaXRlV2l0aGluKSwgRXN0dWFyaWVzLCBSRU1MID0gRikgIyBhbHRlcm5hdGUgbW9kZWwNCiAgbHJTdGF0W2lCb290XSA8LSAyICogbG9nTGlrKGJBbHQpIC0gMiAqIGxvZ0xpayhiTnVsbCkgIyByZXNhbXBsZWQgdGVzdCBzdGF0DQp9DQptZWFuKGxyU3RhdCA+IGxyT2JzKSAjIFAtdmFsdWUgZm9yIHRlc3Qgb2YgRXN0dWFyeSBlZmZlY3QNCg0KRXN0dWFyaWVzJEh5ZHJvaWQNCg0KRXN0dWFyaWVzJEh5ZHJvaWRQcmVzIDwtIEVzdHVhcmllcyRIeWRyb2lkID4gMA0KDQpmaXQuYmluIDwtIGdsbWVyKEh5ZHJvaWRQcmVzIH4gTW9kaWZpY2F0aW9uICsgKDEgfCBFc3R1YXJ5KSwgZmFtaWx5ID0gYmlub21pYWwsIGRhdGEgPSBFc3R1YXJpZXMpDQoNCnBhcihtZnJvdyA9IGMoMSwgMikpDQpwbG90KHJlc2lkdWFscyhmaXQuYmluKSB+IGZpdHRlZChmaXQuYmluKSwgbWFpbiA9ICJyZXNpZHVhbHMgdi5zLiBGaXR0ZWQiKQ0KcXFub3JtKHJlc2lkdWFscyhmaXQuYmluKSkNCg0KbkJvb3QgPC0gMTAwMA0KbHJTdGF0IDwtIHJlcChOQSwgbkJvb3QpDQpmdC5udWxsIDwtIGdsbWVyKEh5ZHJvaWRQcmVzIH4gMSArICgxIHwgRXN0dWFyeSksIGZhbWlseSA9IGJpbm9taWFsLCBkYXRhID0gRXN0dWFyaWVzKSAjIG51bGwgbW9kZWwNCmZ0LmFsdCA8LSBnbG1lcihIeWRyb2lkUHJlcyB+IE1vZGlmaWNhdGlvbiArICgxIHwgRXN0dWFyeSksIGZhbWlseSA9IGJpbm9taWFsLCBkYXRhID0gRXN0dWFyaWVzKSAjIGFsdGVybmF0ZSBtb2RlbA0KDQpsck9icyA8LSAyICogbG9nTGlrKGZ0LmFsdCkgLSAyICogbG9nTGlrKGZ0Lm51bGwpICMgb2JzZXJ2ZWQgdGVzdCBzdGF0DQoNCmZvciAoaUJvb3QgaW4gMTpuQm9vdCkNCnsNCiAgRXN0dWFyaWVzJEh5ZHJvaWRQcmVzU2ltIDwtIHVubGlzdChzaW11bGF0ZShmdC5udWxsKSkgIyByZXNhbXBsZWQgZGF0YQ0KICB0cnlDYXRjaCgNCiAgICB7ICMgc29tZXRpbWVzIHRoZSBnbG1lciBjb2RlIGRvZXNuJ3QgY29udmVyZ2UNCg0KICAgICAgYk51bGwgPC0gZ2xtZXIoSHlkcm9pZFByZXNTaW0gfiAxICsgKDEgfCBFc3R1YXJ5KSwgZmFtaWx5ID0gYmlub21pYWwsIGRhdGEgPSBFc3R1YXJpZXMpICMgbnVsbCBtb2RlbA0KICAgICAgYkFsdCA8LSBnbG1lcihIeWRyb2lkUHJlc1NpbSB+IE1vZGlmaWNhdGlvbiArICgxIHwgRXN0dWFyeSksIGZhbWlseSA9IGJpbm9taWFsLCBkYXRhID0gRXN0dWFyaWVzKSAjIGFsdGVybmF0ZSBtb2RlbA0KICAgICAgbHJTdGF0W2lCb290XSA8LSAyICogbG9nTGlrKGJBbHQpIC0gMiAqIGxvZ0xpayhiTnVsbCkgIyByZXNhbXBsZWQgdGVzdCBzdGF0DQogICAgfSwNCiAgICB3YXJuaW5nID0gZnVuY3Rpb24od2FyKSB7DQogICAgICBsclN0YXRbaUJvb3RdIDwtIE5BDQogICAgfSwNCiAgICBlcnJvciA9IGZ1bmN0aW9uKGVycikgew0KICAgICAgbHJTdGF0W2lCb290XSA8LSBOQQ0KICAgIH0NCiAgKSAjIGlmIGNvZGUgZG9lc24ndCBjb252ZXJnZSBza2lwIHNpbQ0KfQ0KbWVhbihsclN0YXQgPiBsck9icywgbmEucm0gPSBUKSAjIFAtdmFsdWUgZm9yIHRlc3Qgb2YgRXN0dWFyeSBlZmZlY3QNCg0KZml0LnBvaXMgPC0gZ2xtZXIoSHlkcm9pZCB+IE1vZGlmaWNhdGlvbiArICgxIHwgRXN0dWFyeSksIGZhbWlseSA9IHBvaXNzb24sIGRhdGEgPSBFc3R1YXJpZXMpDQoNCnBhcihtZnJvdyA9IGMoMSwgMikpDQpwbG90KHJlc2lkdWFscyhmaXQucG9pcykgfiBmaXR0ZWQoZml0LnBvaXMpLCBtYWluID0gIlJlc2lkdWFscyB2cy4gRml0dGVkIikNCnFxbm9ybShyZXNpZHVhbHMoZml0LnBvaXMpKQ0KDQpuQm9vdCA8LSAxMDAwDQpsclN0YXQgPC0gcmVwKE5BLCBuQm9vdCkNCmZ0Lm51bGwgPC0gZ2xtZXIoSHlkcm9pZCB+IDEgKyAoMSB8IEVzdHVhcnkpLCBmYW1pbHkgPSBwb2lzc29uLCBkYXRhID0gRXN0dWFyaWVzKSAjIG51bGwgbW9kZWwNCmZ0LmFsdCA8LSBnbG1lcihIeWRyb2lkIH4gTW9kaWZpY2F0aW9uICsgKDEgfCBFc3R1YXJ5KSwgZmFtaWx5ID0gcG9pc3NvbiwgZGF0YSA9IEVzdHVhcmllcykgIyBhbHRlcm5hdGUgbW9kZWwNCg0KbHJPYnMgPC0gMiAqIGxvZ0xpayhmdC5hbHQpIC0gMiAqIGxvZ0xpayhmdC5udWxsKSAjIG9ic2VydmVkIHRlc3Qgc3RhdA0KZm9yIChpQm9vdCBpbiAxOm5Cb290KQ0Kew0KICBFc3R1YXJpZXMkSHlkcm9pZFNpbSA8LSB1bmxpc3Qoc2ltdWxhdGUoZnQubnVsbCkpICMgcmVzYW1wbGVkIGRhdGENCiAgdHJ5Q2F0Y2goDQogICAgew0KICAgICAgYk51bGwgPC0gZ2xtZXIoSHlkcm9pZFNpbSB+IDEgKyAoMSB8IEVzdHVhcnkpLCBmYW1pbHkgPSBwb2lzc29uLCBkYXRhID0gRXN0dWFyaWVzKSAjIG51bGwgbW9kZWwNCiAgICAgIGJBbHQgPC0gZ2xtZXIoSHlkcm9pZFNpbSB+IE1vZGlmaWNhdGlvbiArICgxIHwgRXN0dWFyeSksIGZhbWlseSA9IHBvaXNzb24sIGRhdGEgPSBFc3R1YXJpZXMpICMgYWx0ZXJuYXRlIG1vZGVsDQogICAgICBsclN0YXRbaUJvb3RdIDwtIDIgKiBsb2dMaWsoYkFsdCkgLSAyICogbG9nTGlrKGJOdWxsKSAjIHJlc2FtcGxlZCB0ZXN0IHN0YXQNCiAgICB9LA0KICAgIHdhcm5pbmcgPSBmdW5jdGlvbih3YXIpIHsNCiAgICAgIGxyU3RhdFtpQm9vdF0gPC0gTkENCiAgICB9LA0KICAgIGVycm9yID0gZnVuY3Rpb24oZXJyKSB7DQogICAgICBsclN0YXRbaUJvb3RdIDwtIE5BDQogICAgfQ0KICApICMgaWYgY29kZSBkb2Vzbid0IGNvbnZlcmdlIHNraXAgc2ltIyAgIGxyU3RhdFtpQm9vdF0NCn0NCg0KZml0LnBvaXMyIDwtIGdsbWVyKFNjaGl6b3BvcmVsbGEuZXJyYXRhIH4gTW9kaWZpY2F0aW9uICsgKDEgfCBFc3R1YXJ5KSwgZmFtaWx5ID0gcG9pc3NvbiwgZGF0YSA9IEVzdHVhcmllcykNCnBhcihtZnJvdyA9IGMoMSwgMikpDQpwbG90KHJlc2lkdWFscyhmaXQucG9pcykgfiBmaXR0ZWQoZml0LnBvaXMpLCBtYWluID0gInJlc2lkdWFscyB2cy4gRml0dGVkIikNCnFxbm9ybShyZXNpZHVhbHMoZml0LnBvaXMpKQ0KDQpmaXQucG9pcyA8LSBnbG1lcihIeWRyb2lkIH4gTW9kaWZpY2F0aW9uICsgKDEgfCBFc3R1YXJ5KSwgZmFtaWx5ID0gcG9pc3NvbiwgZGF0YSA9IEVzdHVhcmllcykNCm1lYW5zIDwtIGZpdHRlZChmaXQucG9pcykgIyB0aGlzIHdpbGwgZ2l2ZSB0aGUgZXN0aW1hdGUgYXQgZWFjaCBkYXRhIHBvaW50DQpNb2RFc3QgPC0gdW5pcXVlKEVzdHVhcmllc1tjKCJFc3R1YXJ5IiwgIk1vZGlmaWNhdGlvbiIpXSkgIyBmaW5kIHdoaWNoIEVzdHVhcmllcyBhcmUgbW9kaWZpZWQNCmNvbHMgPC0gYXMubnVtZXJpYyhNb2RFc3Rbb3JkZXIoTW9kRXN0WywgMV0pLCAyXSkgKyAzICMgQXNzaWduIGNvbG91ciBieSBtb2RpZmljYXRpb24NCmJveHBsb3QoSHlkcm9pZCB+IEVzdHVhcnksIGRhdGEgPSBFc3R1YXJpZXMsIGNvbCA9IGNvbHMsIHhsYWIgPSAiRXN0dWFyeSIsIHlsYWIgPSAiQ291bnQgb2YgaHlkcm9pZHMiKQ0KbGVnZW5kKCJ0b3BsZWZ0IiwNCiAgaW5zZXQgPSAuMDIsDQogIGMoIk1vZGlmaWVkIiwgIlByaXN0aW5lIiksIGZpbGwgPSB1bmlxdWUoY29scyksIGhvcml6ID0gVFJVRSwgY2V4ID0gMC44DQopDQoNCkVzdC5tZWFucyA8LSBzdW1tYXJpemUobWVhbnMsIEVzdHVhcmllcyRFc3R1YXJ5LCBtZWFuKSRtZWFucyAjIGV4dHJhY3QgbWVhbnMgYnkgRXN0dWFyeQ0Kc3RyaXBjaGFydChFc3QubWVhbnMgfiBzb3J0KHVuaXF1ZShFc3R1YXJ5KSksIGRhdGEgPSBFc3R1YXJpZXMsIHBjaCA9IDE4LCBjb2wgPSAicmVkIiwgdmVydGljYWwgPSBUUlVFLCBhZGQgPSBUUlVFKSAjIHBsb3QgbWVhbnMgYnkgZXN0dWFyeQ0KDQp4IDwtIHNlcSgwLCBwaSAqIDIsIDAuMSkNCnNpbl94IDwtIHNpbih4KQ0KeSA8LSBzaW5feCArIHJub3JtKG4gPSBsZW5ndGgoeCksIG1lYW4gPSAwLCBzZCA9IHNkKHNpbl94IC8gMikpDQpTYW1wbGVfZGF0YSA8LSBkYXRhLmZyYW1lKHksIHgpDQpnZ3Bsb3QoU2FtcGxlX2RhdGEsIGFlcyh4LCB5KSkgKw0KICBnZW9tX3BvaW50KCkNCg0KbG1feSA8LSBsbSh5IH4geCwgZGF0YSA9IFNhbXBsZV9kYXRhKQ0KZ2dwbG90KFNhbXBsZV9kYXRhLCBhZXMoeCwgeSkpICsNCiAgZ2VvbV9wb2ludCgpICsNCiAgZ2VvbV9zbW9vdGgobWV0aG9kID0gbG0pDQpwbG90KGxtX3ksIHdoaWNoID0gMSkNCg0KZ2FtX3kgPC0gZ2FtKHkgfiBzKHgpLCBtZXRob2QgPSAiUkVNTCIpDQoNCnhfbmV3IDwtIHNlcSgwLCBtYXgoeCksIGxlbmd0aC5vdXQgPSAxMDApDQp5X3ByZWQgPC0gcHJlZGljdChnYW1feSwgZGF0YS5mcmFtZSh4ID0geF9uZXcpKQ0KDQpnZ3Bsb3QoU2FtcGxlX2RhdGEsIGFlcyh4LCB5KSkgKw0KICBnZW9tX3BvaW50KCkgKw0KICBnZW9tX3Ntb290aChtZXRob2QgPSAiZ2FtIiwgZm9ybXVsYSA9IHkgfiBzKHgpKQ0KDQpwYXIobWZyb3cgPSBjKDIsIDIpKQ0KZ2FtLmNoZWNrKGdhbV95KQ0KDQpDTzIgPC0gcmVhZC5jc3YoImRhdGEvbWF1bmFfbG9hX2NvMi5jc3YiKQ0KQ08yJHRpbWUgPC0gYXMuaW50ZWdlcihhcy5EYXRlKENPMiREYXRlLCBmb3JtYXQgPSAiJWQvJW0vJVkiKSkNCkNPMl9kYXQgPC0gQ08yDQpDTzIgPC0gQ08yX2RhdFtDTzJfZGF0JHllYXIgJWluJSAoMjAwMDoyMDEwKSwgXQ0KDQpnZ3Bsb3QoQ08yX2RhdCwgYWVzKHRpbWUsIGNvMikpICsNCiAgZ2VvbV9saW5lKCkNCg0KQ08yX3RpbWUgPC0gZ2FtKGNvMiB+IHModGltZSksIGRhdGEgPSBDTzIsIG1ldGhvZCA9ICJSRU1MIikNCg0KcGxvdChDTzJfdGltZSkNCg0KcGFyKG1mcm93ID0gYygyLCAyKSkNCmdhbS5jaGVjayhDTzJfdGltZSkNCg0KQ08yX3NlYXNvbl90aW1lIDwtIGdhbShjbzIgfiBzKG1vbnRoLCBicyA9ICJjYyIsIGsgPSAxMikgKyBzKHRpbWUpLCBkYXRhID0gQ08yLCBtZXRob2QgPSAiUkVNTCIpDQoNCnBhcihtZnJvdyA9IGMoMSwgMikpDQpwbG90KENPMl9zZWFzb25fdGltZSkNCg0KcGFyKG1mcm93ID0gYygyLCAyKSkNCmdhbS5jaGVjayhDTzJfc2Vhc29uX3RpbWUpDQoNCkNPMl9zZWFzb25fdGltZSA8LSBnYW0oY28yIH4gcyhtb250aCwgYnMgPSAiY2MiLCBrID0gMTIpICsgcyh0aW1lKSwgZGF0YSA9IENPMl9kYXQsIG1ldGhvZCA9ICJSRU1MIikNCnBhcihtZnJvdyA9IGMoMSwgMikpDQpwbG90KENPMl9zZWFzb25fdGltZSkNCg0KQ08yX3ByZWQgPC0gZGF0YS5mcmFtZSgNCiAgdGltZSA9IENPMl9kYXQkdGltZSwNCiAgY28yID0gQ08yX2RhdCRjbzIsDQogIHByZWRpY3RlZF92YWx1ZXMgPSBwcmVkaWN0KENPMl9zZWFzb25fdGltZSwgbmV3ZGF0YSA9IENPMl9kYXQpDQopDQpnZ3Bsb3QoQ08yX3ByZWQsIGFlcyh4ID0gdGltZSkpICsNCiAgZ2VvbV9wb2ludChhZXMoeSA9IGNvMiksIHNpemUgPSAxLCBhbHBoYSA9IDAuNSkgKw0KICBnZW9tX2xpbmUoYWVzKHkgPSBwcmVkaWN0ZWRfdmFsdWVzKSwgY29sb3VyID0gInJlZCIpDQoNCg==" download="stat_2.R">Download stat_2.R</a>
<a href="data:text/csv;base64,InNvcnRfbnVtYmVyIiwic2l0ZSIsIkdlbnVzX3NwZWNpZXMiLCJGYW1pbHkiLCJncm93dGhmb3JtIiwiaGVpZ2h0IiwibG9naHQiLCJDb3VudHJ5IiwiU2l0ZSIsImxhdCIsImxvbmciLCJlbnRlcmVkLmJ5IiwiYWx0IiwidGVtcCIsImRpdXJuLnRlbXAiLCJpc290aGVybSIsInRlbXAuc2VhcyIsInRlbXAubWF4Lndhcm0iLCJ0ZW1wLm1pbi5jb2xkIiwidGVtcC5hbm4ucmFuZ2UiLCJ0ZW1wLm1lYW4ud2V0cXIiLCJ0ZW1wLm1lYW4uZHJ5cXIiLCJ0ZW1wLm1lYW4ud2FybXFyIiwidGVtcC5tZWFuLmNvbGRxciIsInJhaW4iLCJyYWluLndldG0iLCJyYWluLmRyeW0iLCJyYWluLnNlYXMiLCJyYWluLndldHFyIiwicmFpbi5kcnlxciIsInJhaW4ud2FybXFyIiwicmFpbi5jb2xkcXIiLCJMQUkiLCJOUFAiLCJoZW1pc3BoZXJlIg0KMTQwMiwxOTMsIkFjZXJfbWFjcnlvcGh5bGx1bSIsIlNhcGluZGFjZWFlIiwiVHJlZSIsMjgsMS40NDcxNTgwMzEsIlVTQSIsIk9yZWdvbiAtIE1jRHVuIiw0NC42LC0xMjMuMzM0LCJBbmdlbGEiLDE3OSwxMC44LDExLjgsNC40LDUuMiwyNywwLjMsMjYuNyw0LjksMTcuNCwxNy42LDQuNSwxMjA4LDIxNywxMyw2OSw2MDEsNjgsNzUsNTYwLDIuNTEsNTcyLDENCjI1MjQ2LDEwMywiUXVhcmFyaWJlYV9jb3JkYXRhIiwiTWFsdmFjZWFlIiwiVHJlZSIsMjYuNiwxLjQyNDg4MTYzNywiUGVydSIsIk1hbnUiLDEyLjE4MywtNzAuNTUsIkFuZ2VsYSIsMzg2LDI0LjUsMTAuOCw3LjQsMC45LDMxLjIsMTYuNywxNC41LDI1LjEsMjMuMiwyNS4zLDIzLjEsMzAxNSw0MTYsOTksNDUsMTE3NywzNDAsOTI4LDM1OSw0LjI2LDE0MDUsLTENCjExNjQ4LDU0LCJFcmFncm9zdGlzX2RpZWxzaWkiLCJQb2FjZWFlIiwiSGVyYiIsMC4zLC0wLjUyMjg3ODc0NSwiQXVzdHJhbGlhIiwiQ2VudHJhbCBBdXN0cmFsaWEiLDIzLjgsMTMzLjgzMywiTWljaGVsbGUiLDU1MywyMC45LDE2LjMsNC44LDYsMzcsMy42LDMzLjQsMjguMSwxNC44LDI4LjEsMTIuOCwyNzgsMzcsOSw0MiwxMDksMzUsMTA5LDQyLDEuMzIsNzU2LC0xDQo4MTY4LDE0NCwiQ2lzdHVzX3NhbHZpZm9saXVzIiwiQ2lzdGFjZWFlIiwiU2hydWIiLDEuNiwwLjIwNDExOTk4MywiSXNyYWVsIiwiSGFuYWRpdiIsMzIuNTU1LDM0LjkzOCwiQW5nZWxhIiwxMTUsMTkuOSw5LjcsNC40LDQuOSwzMC43LDguNywyMiwxMy42LDI1LjMsMjUuNywxMy42LDU5OCwxNTksMCwxMTUsNDA4LDAsMiw0MDgsMS4wMSwzNTksMQ0KMjI0MjIsMTc4LCJQaGxveF9iaWZpZGEiLCJQb2xlbW9uaWFjZWFlIiwiSGVyYiIsMC4yLC0wLjY5ODk3MDAwNCwiVVNBIiwiSW5kaWFuYSBEdW5lcyIsNDEuNjE3LC04Ni45NSwiTWljaGVsbGUiLDIwMCw5LjcsMTAuNywyLjgsOS43LDI4LjYsLTkuNSwzOC4xLDIxLjYsLTMuMywyMS42LC0zLjMsOTc2LDEwNCw0NCwyMywyOTksMTY1LDI5OSwxNjUsMy4yNiwxMTMxLDENCjE1OTI1LDU5LCJIb21hbGl1bV9iZXR1bGlmb2xpdW0iLCJTYWxpY2FjZWFlIiwiU2hydWIiLDEuNywwLjIzMDQ0ODkyMSwiTmV3IENhbGVkb25pYSIsTkEsMjEuNSwxNjUuNSwiTGF1cmEiLDk1LDIyLjYsNy40LDUuNCwyLjIsMjksMTUuNSwxMy41LDI1LjQsMjAuNCwyNS40LDE5LjcsMTM4NywyMTYsNTksNDYsNjAwLDE4Niw2MDAsMjEyLDYuOTksMTU1MiwtMQ0KMjUxNTEsMjcsIlB1bHRlbmFlYV9taWNyb3BoeWxsYSIsIkZhYmFjZWFlIC0gUCIsIlNocnViIiwwLjUsLTAuMzAxMDI5OTk2LCJBdXN0cmFsaWEiLCJLdXJpbmdhaSBDaGFzZSwgU3lkbmV5IiwzMy42NSwxNTEuMiwiTWljaGVsbGUiLDE1NywxNi44LDEwLDQuOCwzLjksMjYuMSw1LjUsMjAuNiwyMS4yLDEyLjMsMjEuNCwxMS41LDEyODMsMTU3LDYzLDI5LDQ1MCwyMDgsMzg1LDI3OSw0LjE0LDE1NjMsLTENCjI2MDA3LDExOCwiUmhpem9waG9yYV9tdWNyb25hdGEiLCJSaGl6b3Bob3JhY2VhZSIsIlRyZWUiLDEwLDEsTkEsIk1hcnNoYWxsIElzbGFuZHMiLDksMTY4LCJMYXVyYSIsMiwyNy43LDQuOCw4LjgsMC4yLDMwLjYsMjUuMiw1LjQsMjcuOSwyNy41LDI3LjksMjcuNSwyNTg1LDMwMCw4MiwzNCw4NzAsMzA1LDg1NSw0MDUsTkEsTkEsMQ0KNjU5NywxNTQsIkNhcnlhX292YXRhIiwiSnVnbGFuZGFjZWFlIiwiVHJlZSIsNDAsMS42MDIwNTk5OTEsIlVTQSIsIkNvbG9yYWRvIiwzNS44LC04OS45LCJBbmdlbGEiLDcxLDE1LjUsMTEuNCwzLjIsOC42LDMyLjksLTIuNiwzNS41LDE1LjYsMjEuNSwyNi4xLDMuOCwxMjYyLDEyOSw2NiwxOCwzODIsMjQ5LDI2OCwzMjUsMy4xNCwxMjY2LDENCjE2OTA4LDEwNiwiSXNjaGFlbXVtX25hdGl2aXRhdGlzIiwiUG9hY2VhZSIsIkhlcmIiLDAuNSwtMC4zMDEwMjk5OTYsIkF1c3RyYWxpYSIsIkNocmlzdG1hcyBJc2xhbmQiLDEwLjQxNywxMDUuNjY3LCJMYXVyYSIsMiwyNi40LDUsNy40LDAuNiwyOS45LDIzLjIsNi43LDI2LjgsMjUuNywyNy4xLDI1LjUsMTcwNCwzMDksMTYsNjYsODA2LDkyLDY1OSwxMzUsNC41MSwyMjk2LC0xDQo0NjEwLDIwMSwiQmV0dWxhX25hbmEiLCJCZXR1bGFjZWFlIiwiU2hydWIiLDAuNTUsLTAuMjU5NjM3MzExLCJFc3RvbmlhIixOQSw1OC41LDI1LCJBbmdlbGEiLDI4LDUuNCw2LjYsMi4xLDguMywyMS4yLC05LDMwLjIsNi41LC0xLjYsMTYuMSwtNSw2NjQsNzcsMzEsMjgsMjIwLDEwNiwxOTEsMTM3LDMuMDcsNTM2LDENCjE1OTMsODYsIkFjbWVuYV9ncmF2ZW9sZW5zIiwiTXlydGFjZWFlIiwiVHJlZSIsMzIsMS41MDUxNDk5NzgsIkF1c3RyYWxpYSIsIkNhaXJucyAtIERhaW50cmVlIGNhbm9weSBjcmFuZSIsMTYuMTAzLDE0NS40NDYsIkFuZ2VsYSIsMjYzLDI1LjIsOC4zLDUuOCwyLjEsMzEuOSwxNy44LDE0LjEsMjcuMiwyMi44LDI3LjUsMjIuMywyMDg3LDQ1OSwyNiw5MywxMjk0LDkyLDEwMzEsMTA4LDQuMDQsOTA4LC0xDQoyMjM1OSw2OSwiUGhhbGVyaWFfaXhvcm9pZGVzIiwiVGh5bWVsYWVhY2VhZSIsIlRyZWUiLDUsMC42OTg5NzAwMDQsIkZpamkiLCJWaXRpIExldnUiLDE3LjgsMTc4LCJMYXVyYSIsMTEwOCwxOS4zLDYuMyw1LjgsMS41LDI1LjMsMTQuNiwxMC43LDIxLjEsMTcuNCwyMS4xLDE3LjMsMzE5MSw0MTIsMTYwLDMxLDExMzYsNTIxLDExMzYsNTIzLDQuMjYsMTc5NSwtMQ0KMjQ0OTMsMTIzLCJQcmVtbmFfc2VycmF0aWZvbGlhIiwiTGFtaWFjZWFlIiwiU2hydWIvVHJlZSIsNywwLjg0NTA5ODA0LCJNaWNyb25lc2lhIiwiWWFwIiw5LjUsMTM4LjE2NywiTGF1cmEiLDE1LDI3LjIsNi44LDkuMSwwLjIsMzEuMSwyMy43LDcuNCwyNy4yLDI3LjIsMjcuNSwyNi45LDMwMzEsMzY4LDE0NCwzMSwxMDU1LDQzNiw2ODksNDg5LE5BLE5BLDENCjI1MTI5LDcyLCJQdWxsZWFfcGVycnlhbmEiLCJDdW5vbmlhY2VhZSIsIlRyZWUiLDEyLDEuMDc5MTgxMjQ2LCJGaWppIiwiYW8iLDE3Ljc0MiwxNzguMzkyLCJMYXVyYSIsNDcsMjQuOCw2LjMsNi4zLDEuMywzMCwyMC4xLDkuOSwyNi4xLDIzLDI2LjMsMjMsMjc3MCwzODEsMTE4LDM3LDEwMDYsMzkxLDEwMDUsMzkxLDQuNTEsMTg2NCwtMQ0KMjU5MjEsMTYxLCJSZXRhbWFfc3BoYWVyb2NhcnBhIiwiRmFiYWNlYWUgLSBQIiwiU2hydWIiLDEuNjgsMC4yMjUzMDkyODIsIlNwYWluIixOQSwzNy4xMzMsLTIuMzY3LCJBbmdlbGEiLDY0OCwxNS4zLDEwLjEsMy44LDUuNywzMC4xLDMuNiwyNi41LDEyLjMsMjIuOCwyMy4xLDguNiwzNTUsNDMsNSw0NCwxMjEsMjcsMzMsMTE0LDIuNzksOTkxLDENCjMwMzk2LDQ2LCJUaGVtZWRhX3RyaWFuZHJhIiwiUG9hY2VhZSIsIkhlcmIiLDAuNywtMC4xNTQ5MDE5NiwiU291dGggQWZyaWNhIiwiWnVsdWxhbmQgLSBsZWR1YmUiLDI4LjIzNCwzMi4wMTcsIkFuZ2VsYSIsMjg5LDIwLjUsMTAuMiw1LjgsMi40LDI4LjUsMTEsMTcuNSwyMy40LDE3LjIsMjMuNCwxNy4yLDkyNiwxMjksMzIsNDMsMzQ3LDEwNCwzNDQsMTA0LDMuMzUsNTI1LC0xDQoxOTI5OCw2MywiTWFlc2FfdG9uZ2Vuc2lzIiwiTWFlc2FjZWFlIiwiU2hydWIvVHJlZSIsNCwwLjYwMjA1OTk5MSwiRmlqaSIsImZ1bGFuZ2EiLDE5LjEzMywtMTc4LjU2NywiTGF1cmEiLDAsMjQuOSw2LjIsNiwxLjQsMzAuMywyMC4xLDEwLjIsMjYuNSwyMy4yLDI2LjUsMjMsMTgzMSwyNzgsNzYsNDEsNzI0LDI1Nyw3MjQsMjcwLDQuNSwxODAwLC0xDQoxMTMwNSw3MywiRWxldXNpbmVfYWVneXB0aWNhIiwiUG9hY2VhZSIsIkhlcmIiLDAuNiwtMC4yMjE4NDg3NSwiRmlqaSIsImFiIiwxNy42NjcsMTc4LjE2NywiTGF1cmEiLDMxMiwyMy41LDYuMyw2LjIsMS4zLDI4LjksMTguOCwxMC4xLDI1LjEsMjEuNywyNS4xLDIxLjcsMjgxNCwzNzksMTI2LDM1LDEwMjcsNDEzLDEwMjcsNDEzLDQuMjYsMTc5NSwtMQ0KMTc5ODIsMTY0LCJMZXBlY2hpbmlhX2NhbHljaW5hIiwiTGFtaWFjZWFlIiwiU2hydWIiLDEuNiwwLjIwNDExOTk4MywiVVNBIiwiSmFzcGVyIFJpZGdlIC0gQ2hhcGFycmFsIiwzNy40LC0xMjIuMjMzLCJBbmdlbGEiLDE1MCwxMy44LDExLjMsNS41LDMuMywyNC4yLDQsMjAuMiw5LjYsMTcuNywxOC4xLDkuNiw1OTgsMTIwLDIsODcsMzExLDksMTMsMzExLDEuNTEsMjIzLDENCjE5NTY5LDExNywiTWFyYW50aGVzX2dsYWJyYSIsIkNocnlzb2JhbGFuYWNlYWUiLCJUcmVlIiwzMiwxLjUwNTE0OTk3OCwiTGliZXJpYSIsTkEsNS41LC03LjUsIk5hdGUiLDE1MiwyNiw4LjgsNy41LDAuOSwzMi41LDIwLjgsMTEuNywyNS45LDI2LjQsMjcuMiwyNC44LDIxMTAsMjg3LDQ5LDQ1LDczNSwyMTcsNDU4LDU0Miw0LjUxLDE4NTcsMQ0KMjQ4OTMsMTg5LCJQc2V1ZG90c3VnYV9tZW56aWVzaWkiLCJQaW5hY2VhZSIsIlRyZWUiLDYxLDEuNzg1MzI5ODM1LCJVU0EiLCJPcmVnb24iLDQ0LC0xMjIsIkFuZ2VsYSIsMTQ0Niw1LDEyLjgsNC4xLDYuMSwyMy41LC03LjMsMzAuOCwtMS41LDEzLjEsMTMuMSwtMi4xLDE0MjcsMjQ2LDIzLDY1LDY5MiwxMDYsMTA2LDY0MiwyLjA3LDQ3OCwxDQozMTU2LDExMywiQXBvcnVzYV9nbG9iaWZlcmEiLCJQaHlsbGFudGhhY2VhZSIsTkEsMTQuOCwxLjE3MDI2MTcxNSwiTWFsYXlzaWEiLE5BLDMsMTAyLjMzMywiQW5nZWxhIiwyMjgsMjUuOCw5LjUsOC41LDAuNSwzMS41LDIwLjQsMTEuMSwyNS40LDI1LjksMjYuNCwyNS4xLDIwMTIsMjU1LDEwMiwzMCw3MTksMzI3LDQ4Niw2NTIsNC41MSwyMjcwLDENCjIzODIxLDQwLCJQb2x5Z29udW1fbGFwYXRoaWZvbGl1bSIsIlBvbHlnb25hY2VhZSIsIkhlcmIiLDEsMCwiQXVzdHJhbGlhIixOQSwzMC41MTcsMTQ1LjEzMywiTWljaGVsbGUiLDEwNiwxOS45LDEzLjgsNC41LDUuOSwzNS4yLDUsMzAuMiwyNi43LDEzLjYsMjcuMywxMi4xLDMzOCw0NCwxNiwyOCwxMTYsNjcsMTAwLDY4LDIuMDcsNDkwLC0xDQoxMDY5Miw3MSwiRGlvc3B5cm9zX2dpbGxlc3BpZWkiLCJFYmVuYWNlYWUiLCJUcmVlIiwxNSwxLjE3NjA5MTI1OSwiRmlqaSIsImFia28iLDE3Ljc1OCwxNzguNTc3LCJMYXVyYSIsMTMsMjQuOSw2LjMsNi4zLDEuMywzMC4xLDIwLjEsMTAsMjYuNSwyMy4zLDI2LjUsMjMuMiwyNzY3LDM5MCwxMTMsMzgsMTAxMiwzNzksMTAxMiwzODEsNC41MSwxODY0LC0xDQoxNTcxNCwxMDcsIkhpYmlzY3VzX3RpbGlhY2V1cyIsIk1hbHZhY2VhZSIsIlRyZWUiLDcsMC44NDUwOTgwNCwiUGFwdWEgTmV3IEd1aW5lYSIsIk1vdHVwb3JlIElzbGFuZCIsOS41LDE0Ny4yNjcsIkxhdXJhIiwzMCwyNi44LDguMyw3LjYsMC44LDMyLjUsMjEuNiwxMC45LDI3LjUsMjUuNywyNy43LDI1LjYsMTE4NCwyMDEsMzMsNjAsNTU2LDExNyw0ODYsMTIzLDMuMjYsOTA3LC0xDQoyMDU4NSw3OCwiTXlyaXN0aWNhX21hY3JhbnRoYSIsIk15cmlzdGljYWNlYWUiLCJUcmVlIiwyMCwxLjMwMTAyOTk5NiwiRmlqaSIsImFibyIsMTcuMzU2LDE3OC42NzUsIkxhdXJhIiwzLDI1LDYuMyw2LjQsMS4yLDMwLjIsMjAuNCw5LjgsMjYuNSwyMy40LDI2LjUsMjMuNCwyNjY0LDM4NCwxMDMsNDAsMTAxMSwzNDksMTAxMSwzNDksNC41MSwxODY0LC0xDQozMjIzNyw4MSwiV2Vpbm1hbm5pYV9yaWNoaWkiLCJDdW5vbmlhY2VhZSIsIlNocnViL1RyZWUiLDcsMC44NDUwOTgwNCwiRmlqaSIsImFidCIsMTcuMDgxLDE3OS4wNjksIkxhdXJhIiwyLDI1LjQsNi4yLDYuNSwxLjEsMzAuNCwyMC45LDkuNSwyNi44LDIzLjksMjYuOCwyMy45LDI0OTQsMzYyLDg4LDQ0LDEwMDMsMjk4LDEwMDMsMjk4LDQuMjYsMTg4NiwtMQ0KMTYxMDcsMTIyLCJIeWJhbnRodXNfcHJ1bmlmb2xpdXMiLCJWaW9sYWNlYWUiLCJTaHJ1YiIsMi45LDAuNDYyMzk3OTk4LCJQYW5hbWEiLCJCQ0kiLDkuMTY3LC03OS44NSwiQW5nZWxhIiw5NCwyNi4zLDYuNyw3LjMsMC43LDMxLjIsMjIuMSw5LjEsMjUuNywyNi40LDI3LjMsMjUuNSwyNjA3LDM5MCwyOSw1NiwxMDI2LDEzOCw0MDcsNzA1LDQuNTEsMjE0NiwxDQoxOTM5NSwxNDAsIk1hbGxvdHVzX2phcG9uaWN1cyIsIkV1cGhvcmJpYWNlYWUiLCJUcmVlIiw5LjY3LDAuOTg1NDI2NDc0LCJKYXBhbiIsTkEsMzAuMzMzLDEzMC40LCJBbmdlbGEiLDUzMCwxOC4yLDYuMywyLjgsNS41LDI5LjEsNy4zLDIxLjgsMjIuNSwxMS4yLDI1LjQsMTEuMiwzMDQyLDUyMSwxMzcsMzksMTExNyw0OTUsODM3LDQ5NSw0LjI2LDEzMzUsMQ0KMTk4NDksNjQsIk1lbG9jaGlhX2xvbmdlcGV0aW9sYXRhIiwiTWFsdmFjZWFlIiwiVHJlZSIsOCwwLjkwMzA4OTk4NywiRmlqaSIsImsiLDE4Ljk2NywxNzguMjgzLCJMYXVyYSIsNzIsMjQuMSw2LjQsNS45LDEuNSwyOS44LDE5LjEsMTAuNywyNS43LDIyLjMsMjYsMjIuMiwyMzE0LDMxNiwxMTksMzQsODM2LDM3Miw4MzQsMzg0LDQuNTEsMTg2NCwtMQ0KMTE3MjMsNTMsIkVyZW1vcGhpbGFfZm9ycmVzdGlpIiwiU2Nyb3BodWxhcmlhY2VhZSIsIlNocnViIiwyLDAuMzAxMDI5OTk2LCJBdXN0cmFsaWEiLCJXQSIsMjQuNjUsMTEzLjcsIkFuZ2VsYSIsNywyMi4zLDEwLjcsNC42LDQuMSwzMy44LDEwLjgsMjMsMTguMiwyMy4xLDI3LjYsMTcsMjE2LDUwLDAsODMsMTI3LDUsNTQsMTA4LDEuNTEsNDY0LC0xDQoxODE3NSwyNiwiTGV1Y2FkZW5kcm9uX3NwIiwiUHJvdGVhY2VhZSIsIlNocnViIiwwLjYsLTAuMjIxODQ4NzUsIlNvdXRoIEFmcmljYSIsIlN0ZWxsZW5ib3NjaCAtIGZ5bmJvcyIsMzMuOTkyLDE4Ljk3NSwiQW5nZWxhIiwzODcsMTUuNywxMS4yLDUuMywzLjUsMjcuMyw2LjMsMjEsMTIuMiwyMC4yLDIwLjMsMTEuNSwxMDUyLDE2MCwyOSw1OSw0NjgsOTUsOTgsNDU5LDIuMDEsNTE3LC0xDQoxNDk1NCwxOCwiSGFrZWFfcm9zdHJhdGEiLCJQcm90ZWFjZWFlIiwiU2hydWIiLDEuNywwLjIzMDQ0ODkyMSwiQXVzdHJhbGlhIixOQSwzNi45MTcsMTQyLjQxNywiQW5nZWxhIiwzNjYsMTMsMTIuNSw0LjksNC40LDI3LjcsMi42LDI1LjEsNy41LDE4LjYsMTguNiw3LjUsNzIzLDkyLDMyLDM2LDI1OSwxMDIsMTAyLDI1OSwyLjI2LDY5OCwtMQ0KMzI2OTcsMzgsIkFkZW5hbnRob3NfY3lnbm9ydW0iLCJQcm90ZWFjZWFlIiwiVHJlZSIsNywwLjg0NTA5ODA0LCJBdXN0cmFsaWEiLCJQZXJ0aCAtIE1lbGFsZXVjYSBQYXJrIiwzMS42ODksMTE1Ljg4NiwiQW5nZWxhIiw2MCwxOC4zLDExLjUsNC45LDQuMSwzMS43LDguNSwyMy4yLDEzLjUsMjMuNSwyMy45LDEzLjUsNzYyLDE2MCw4LDg0LDQyNiwzMywzOSw0MjYsMS41MSw1NzUsLTENCjY4NTEsMjIyLCJDYXNzaW9wZV90ZXRyYWdvbmEiLCJFcmljYWNlYWUiLCJTaHJ1YiIsMC4wOCwtMS4wOTY5MTAwMTMsIkdyZWVubGFuZCIsIlphY2tlbmJlcmcgLSBoaWxsIiw3NC40NzYsLTIwLjYyOSwiQW5nZWxhIiw4MywtMTEuMSw3LDIuMSw5LjMsNiwtMjYuNSwzMi41LC00LjMsLTcuNCwxLjcsLTIxLjQsMjUyLDI3LDExLDIyLDc2LDQwLDYwLDY4LDIuNiw0LDENCjMwMzQ1LDE1NiwiVGhhbGljdHJ1bV90aGFsaWN0cm9pZGVzIiwiUmFudW5jdWxhY2VhZSIsIkhlcmIiLDAuMiwtMC42OTg5NzAwMDQsIlVTQSIsIkR1a2UgRm9yZXN0LCBEdXJoYW0sIE5DIiwzNS45NjcsLTc5LCJBbmdlbGEiLDk5LDE0LjksMTMuNCwzLjksNy42LDMxLjgsLTIuNCwzNC4yLDI0LjYsMTAuMiwyNC42LDQuOCwxMTUwLDExMyw4MSwxMiwzMjUsMjUyLDMyNSwyNzcsMy4yNiwxMjc0LDENCjI2NjczLDIwOSwiUnVtZXhfYWNldG9zYSIsIlBvbHlnb25hY2VhZSIsIkhlcmIiLDAuNzA3LC0wLjE1MDU4MDU4NiwiRmlubGFuZCIsTkEsNjIsMjcsIkFuZ2VsYSIsMTE0LDMuNCw3LjMsMi4xLDksMjEuMiwtMTIuMiwzMy40LDEzLjUsLTMuNiwxNS4yLC04LjEsNjM3LDg0LDMzLDI5LDIyMSwxMDQsMjA5LDEyOSwyLjc2LDQ3NywxDQo2Nzg3LDEzNywiQ2FzaW1pcm9hX2dyZWdnaWkiLCJSdXRhY2VhZSIsIlNocnViIiw3LDAuODQ1MDk4MDQsIk1leGljbyIsIkxpbmFyZXMgLSBQdWVudGEgVmllam8iLDI0Ljc0OSwtOTkuNzk5LCJBbmdlbGEiLDczNiwyMC43LDE0LjMsNS41LDQsMzIuOSw3LjIsMjUuNywyMy41LDE1LjIsMjUuNCwxNS4yLDcwMywxNDksMTQsNzEsMzI1LDU0LDI2OCw1NCwyLjI2LDg0NCwxDQo0MTc1LDEwLCJCYWNjaGFyaXNfZGl2YXJpY2F0YSIsIkFzdGVyYWNlYWUiLCJTaHJ1YiIsMC41LC0wLjMwMTAyOTk5NiwiQXJnZW50aW5hIiwiUHVlcnRvIE1hZHJ5biAtIGR1bmUiLDQyLjc2OSwtNjQuMTAxLCJBbmdlbGEiLDY2LDEzLDEwLjMsNC43LDQuMiwyNC41LDIuNywyMS44LDEzLjcsMTcsMTguMyw3LjQsMjE0LDI4LDksMzUsNzcsMzYsMzcsNTUsMS4wMSw0MDQsLTENCjE1ODY0LDEyMSwiSGlydGVsbGFfdHJpYW5kcmEiLCJDaHJ5c29iYWxhbmFjZWFlIiwiVHJlZSIsMjMuNSwxLjM3MTA2Nzg2MiwiUGFuYW1hIiwiUGFuYW1hIC0gQkNJIiw5LjE1LC03OS44NDksIkFuZ2VsYSIsMTY1LDI2LjUsNi44LDcuMywwLjcsMzEuNCwyMi4yLDkuMiwyNS44LDI2LjYsMjcuNSwyNS42LDI1NDIsMzgzLDI3LDU2LDEwMDQsMTMyLDM5Nyw5NzUsNC41MSwyMTQ2LDENCjIwMzY3LDEzOSwiTW9ydXNfYm9uaW5lbnNpcyIsIk1vcmFjZWFlIiwiVHJlZSIsMTYsMS4yMDQxMTk5ODMsIkphcGFuIixOQSwyNi42NSwxNDIuMTMzLCJBbmdlbGEiLDIzMCwyMy40LDQuNiwzLjEsMy42LDMwLjEsMTUuNywxNC40LDI3LjIsMTguNSwyNy43LDE4LjUsMTMxNSwxNTEsNTIsMjcsNDE0LDE5NSwzOTQsMTk1LE5BLE5BLDENCjMxNzUsMTczLCJBcXVpbGVnaWFfY2FlcnVsZWEiLCJSYW51bmN1bGFjZWFlIiwiSGVyYiIsMC4yMzMsLTAuNjMyNjQ0MDc5LCJVU0EiLCJSb2NraWVzIiwzOC45NjYsLTEwNi45ODcsIkFuZ2VsYSIsMjk2NiwwLjIsMTYuOSw0LDguNiwyMS4zLC0yMC44LDQyLjEsMTAuNSw0LDExLC0xMC44LDUyNiw1MywzMCwxNiwxNDgsMTA1LDEzNCwxNDQsMi4yNCwzMzksMQ0KMjE3NDcsMTE2LCJQYXJhc2hvcmVhX21hbGFhbm9uYW4iLCJEaXB0ZXJvY2FycGFjZWFlIiwiVHJlZSIsMzQsMS41MzE0Nzg5MTcsTkEsTkEsNC45NjcsMTE3LjgsIkFuZ2VsYSIsMjE0LDI1LjksNy43LDguOSwwLjMsMzAuNSwyMS45LDguNiwyNS42LDI1LjcsMjYuMywyNS40LDIzMTUsMjUzLDE0NywxNCw2OTIsNTEyLDUxNSw2NzAsNC41MSwyMjQ2LDENCjUwMDMsODIsIkJyYWNrZW5yaWRnZWFfbml0aWRhIiwiT2NobmFjZWFlIiwiU2hydWIvVHJlZSIsMTUsMS4xNzYwOTEyNTksIkZpamkiLCJhYnJhbWJpIiwxNi45NTYsMTc5LjA2OSwiTGF1cmEiLDUsMjUuNSw2LjIsNi42LDEuMSwzMC40LDIxLjEsOS4zLDI2LjgsMjQsMjYuOCwyNCwyNDYyLDM1Niw4Myw0NSwxMDA3LDI4NCwxMDA3LDI4NCw0LjI2LDE4ODYsLTENCjI2MjA1LDc3LCJSaWNoZWxsYV9tb25vc3Blcm1hIiwiQW5ub25hY2VhZSIsIlRyZWUiLDE1LDEuMTc2MDkxMjU5LCJGaWppIiwiYW90IiwxNy40NDcsMTc4LjkxNywiTGF1cmEiLDk3LDI0LjYsNi4yLDYuMywxLjIsMjkuOCwyMC4xLDkuNywyNi4xLDIzLDI2LjEsMjMsMjY2MCwzODIsMTAzLDQxLDEwMjMsMzQ1LDEwMjMsMzQ1LDQuNSwxODAwLC0xDQozMjMxMywzNywiWGFudGhvcnJob2VhX3ByZWlzc2lpIiwiWGFudGhvcnJob2VhY2VhZSIsIlNocnViIiwxLjUsMC4xNzYwOTEyNTksIkF1c3RyYWxpYSIsIlBlcnRoIC0gRGFybGluZyBTY2FycCIsMzIuMDIsMTE2LjA0NCwiQW5nZWxhIiwyMDksMTcsMTEuMiw0LjYsNC41LDMxLjIsNy4yLDI0LDExLjcsMjIuNywyMy4xLDExLjcsMTAwMywyMTMsMTMsODUsNTY2LDUwLDU0LDU2NiwxLjkzLDcwOCwtMQ0KMjEwMTMsMTI2LCJPY290ZWFfbWV6aWFuYSIsIkxhdXJhY2VhZSIsIlRyZWUiLDE2LDEuMjA0MTE5OTgzLCJDb3N0YSBSaWNhIixOQSwxMC40MzMsLTgzLjk4MywiQW5nZWxhIiw1MCwyNiw4LjgsNy42LDAuOCwzMi4yLDIwLjcsMTEuNSwyNi4yLDI2LjgsMjcuMSwyNS4xLDM5OTEsNDgxLDE2MiwzMCwxMjgxLDU4MSw3NDEsMTIwNiw0LjUxLDIxMzIsMQ0KMTgxMDQsMjEsIkxlcHRvc3Blcm11bV9jb250aW5lbnRhbGUiLCJNeXJ0YWNlYWUiLCJTaHJ1YiIsMi44LDAuNDQ3MTU4MDMxLCJBdXN0cmFsaWEiLCJBZGVsYWlkZSAtIGZlcnJpZXMiLDM1LjIzNSwxMzkuMTMyLCJBbmdlbGEiLDUyLDE1LjYsMTEuNyw1LjMsMy43LDI3LjgsNS44LDIyLDEwLjksMjAuMiwyMC4zLDEwLjksMzg0LDQ1LDE4LDI5LDEyNyw1OSw2MCwxMjcsMi4xNyw2NjEsLTENCjI3MjAsMTI5LCJBbXBlbG9jZXJhX2hvdHRsZWkiLCJVbG1hY2VhZSIsIlRyZWUiLDI1LDEuMzk3OTQwMDA5LCJNZXhpY28iLCJDaGFqdWwiLDE2LjEwNiwtOTAuOTg3LCJBbmdlbGEiLDQxLDI1LjksMTEuMyw2LjksMS41LDM0LDE3LjgsMTYuMiwyNi42LDI1LjgsMjcuNSwyMy43LDMwNDgsNTE1LDU3LDY4LDE0MjIsMTk1LDY4MCwzMDQsNC41MSwxODA5LDENCjEyMDMxLDk5LCJFdWNhbHlwdHVzX21pbmlhdGEiLCJNeXJ0YWNlYWUiLCJUcmVlIiwyMCwxLjMwMTAyOTk5NiwiQXVzdHJhbGlhIiwiSG93YXJkIFNwcmluZ3MsIERhcndpbiIsMTIuNDk0LDEzMS4xMDgsIkFuZ2VsYSIsMjYsMjcuMywxMC41LDYsMS43LDM0LjYsMTcuMiwxNy40LDI4LjEsMjQuNywyOS4yLDI0LjcsMTUwNSwzNzEsMSwxMDQsOTcwLDcsNDA4LDcsNC4wNyw5NTYsLTENCjE1NjUxLDYxLCJIZXRlcm9wb2dvbl90cml0aWNldXMiLCJQb2FjZWFlIiwiSGVyYiIsMC40LC0wLjM5Nzk0MDAwOSwiQXVzdHJhbGlhIiwiVG93bnN2aWxsZSBzYXZhbm5hIiwxOS4zMzcsMTQ2Ljc1NSwiQW5nZWxhIiw3OSwyMy45LDkuOSw1LjIsMy4xLDMxLjcsMTIuOSwxOC44LDI3LjEsMjAuMywyNy4zLDE5LjQsMTAyNywyNTEsOSwxMDEsNjY4LDMzLDYyNiw0Miw0LjE0LDEwMTIsLTENCjg3MzYsMTMsIkNvcHJvc21hX3JvYnVzdGEiLCJSdWJpYWNlYWUiLCJTaHJ1YiIsNiwwLjc3ODE1MTI1LCJOZXcgWmVhbGFuZCIsIk5lbHNvbiIsNDIsMTczLCJBbmdlbGEiLDE2NTAsNC4yLDguNSw0LjQsMy43LDE0LjgsLTQuNCwxOS4yLC0wLjEsOC45LDguOSwtMC43LDIwNDMsMjA0LDEwNSwxNiw1ODIsMzg4LDM4OCw1ODAsNC4yNiwxMTAyLC0xDQoyMTkzMCwyMjAsIlBlZGljdWxhcmlzX2xhcHBvbmljYSIsIk9yb2JhbmNoYWNlYWUiLCJIZXJiIiwwLjIsLTAuNjk4OTcwMDA0LCJHcmVlbmxhbmQiLCJkaXNrbyBpc2xhbmQiLDY5LjI1LC01My42LCJBbmdlbGEiLDE1MCwtNS43LDUuNSwxLjgsOCw4LjMsLTIwLjcsMjksMS4yLC0xNi4yLDQuMywtMTYuMiwzMDUsMzgsMTYsMzAsMTA2LDUyLDg3LDUyLDEuMDEsMzIsMQ0KMjUyNzQsMTUxLCJRdWVyY3VzX2NhbGxpcHJpbm9zIiwiRmFnYWNlYWUiLCJTaHJ1YiIsMy41LDAuNTQ0MDY4MDQ0LCJJc3JhZWwiLCJBZHVsYW0iLDM0LjkzNSwzNC45MzUsIkFuZ2VsYSIsMzU4LDQuOCw3LjEsMi4yLDguNywyMS44LC0xMC4yLDMyLDEwLjYsLTUuNywxNi4xLC02LjMsNTk5LDc3LDI2LDM0LDIxNyw5MCwxODUsMTA1LDEuMDEsMzg2LDENCjI5ODg4LDMwLCJTeW5jYXJwaWFfZ2xvbXVsaWZlcmEiLCJNeXJ0YWNlYWUiLCJUcmVlIiwyNSwxLjM5Nzk0MDAwOSwiQXVzdHJhbGlhIiwiS3VyaW5nYWkgLSBEaWF0cmVtZSIsMzMuNTc4LDE1MS4yOTIsIkFuZ2VsYSIsMTg4LDE3LDkuNyw0LjgsMy44LDI2LjEsNS45LDIwLjIsMjEuNCwxMi42LDIxLjUsMTEuOSwxMzA3LDE1OSw2NCwyOSw0NTUsMjEyLDM5MSwyODAsNC41MSwxNDM1LC0xDQo4OSwxNTgsIkFiaWVzX3ZlaXRjaGlpIiwiUGluYWNlYWUiLCJUcmVlIiwxOCwxLjI1NTI3MjUwNSwiSmFwYW4iLE5BLDM2LjA4MywxMzguMzUsIkFuZ2VsYSIsMjA5MCwyLjQsOC43LDIuNiw4LjYsMTksLTE0LjIsMzMuMiwxMy4zLC04LjYsMTMuMywtOC42LDIxNDIsMzAzLDYzLDUxLDg4NSwyMDQsODg1LDIwNCwzLjI2LDc1MSwxDQoxMjA5MCwyMywiRXVjYWx5cHR1c19zcDQiLCJNeXJ0YWNlYWUiLCJUcmVlIiwxMCwxLCJBdXN0cmFsaWEiLCJBZGVsYWlkZSAtIEJyb29rZmllbGQgQ2hlbm9wb2QiLDM0LjM0NywxMzkuNTE3LCJBbmdlbGEiLDk5LDE2LjIsMTMuNCw1LjEsNC41LDMwLjcsNC44LDI1LjksMTEuMSwyMS44LDIyLDEwLjQsMjc2LDMxLDE1LDIzLDg0LDQ5LDUxLDgwLDIuMTQsNzczLC0xDQozNjQ2LDc5LCJBc2NhcmluYV9zd2FteWFuYSIsIkNobG9yYW50aGFjZWFlIiwiVHJlZSIsMTAsMSwiRmlqaSIsImF0IiwxNy4zMjksMTc4Ljk4MywiTGF1cmEiLDIsMjUuMiw2LjIsNi40LDEuMiwzMC4yLDIwLjYsOS42LDI2LjYsMjMuNiwyNi42LDIzLjYsMjU3NiwzNzUsOTYsNDIsMTAwMywzMjUsMTAwMywzMjUsNC41LDE4MDAsLTENCjI1MDY4LDM0LCJQdGVyb25pYV9wYWxsZW5zIiwiQXN0ZXJhY2VhZSIsTkEsMC41LC0wLjMwMTAyOTk5NiwiU291dGggQWZyaWNhIixOQSwzMy4xNjcsMjIuMjgzLCJBbmdlbGEiLDczMiwxNS43LDE1LDUuNiw0LDI5LjUsMi45LDI2LjYsMTguOCwxMC42LDIwLjcsMTAuNiwyODEsMzYsMTcsMjIsOTIsNTUsNzEsNTUsMS4yNiwyNTUsLTENCjI5MTU2LDk0LCJTb3JvY2VhX3BpbGVhdGEiLCJNb3JhY2VhZSIsIlRyZWUiLDE5LDEuMjc4NzUzNjAxLCJQZXJ1IiwiTG9zIEFtaWdvcyBmbG9vZHBsYWluIiwxMi41NjcsLTcwLjA5MywiQW5nZWxhIiwyMTcsMjQuOSwxMC41LDcuNCwxLDMxLjUsMTcuNCwxNC4xLDI1LjYsMjMuMywyNS43LDIzLjMsMzI3Myw0NzEsMTEzLDQ2LDEzMTAsMzgxLDEwMDEsMzgxLDQuMjYsMTQ3NSwtMQ0KOTY0MSw2NSwiQ3lhdGhvY2FseXhfaW5zdWxhcmlzIiwiQW5ub25hY2VhZSIsIlRyZWUiLDIwLDEuMzAxMDI5OTk2LCJGaWppIiwiYWsiLDE4LjM4MywxNzguMTQyLCJMYXVyYSIsMzAsMjQuNiw2LjMsNi4xLDEuNCwzMCwxOS43LDEwLjMsMjYsMjIuOSwyNi4zLDIyLjcsMjY3NCwzNDUsMTMyLDMyLDk0Myw0MTQsOTI1LDQzMSw0LjI2LDE3OTUsLTENCjE4MTc2LDMxLCJMZXVjYWRlbmRyb25fY29yeW1ib3N1bSIsIlByb3RlYWNlYWUiLCJTaHJ1YiIsMywwLjQ3NzEyMTI1NSwiU291dGggQWZyaWNhIiwiU3RlbGxlbmJvc2NoIC0gcmVub3N0ZXJ2ZWxkIiwzMy40NDgsMTkuMDQ4LCJBbmdlbGEiLDg5LDE3LjksMTMuNSw1LjMsNC4zLDMxLDUuNywyNS4zLDEzLjIsMjMuMiwyMy4yLDEyLjQsNTgzLDk0LDExLDYzLDI3MSw0OCw0OCwyNjYsMS41MSw2MzMsLTENCjE4MzkyLDE2NSwiTGluYW50aHVzX3NwIiwiUG9sZW1vbmlhY2VhZSIsIkhlcmIiLDAuMTEsLTAuOTU4NjA3MzE1LCJVU0EiLCJKYXNwZXIgUmlkZ2UgLSBTZXJwZW50aW5lIiwzNy40LC0xMjIuMjI0LCJBbmdlbGEiLDE3OSwxMy43LDExLjQsNS41LDMuMywyNC40LDQsMjAuNCw5LjYsMTcuNywxOCw5LjYsNjMwLDEyNywyLDg2LDMyOCw5LDEzLDMyOCwxLjUxLDIyMywxDQozMjY5NCwxMzQsIlBpcmFuaGVhX3NwIiwiUGljcm9kZW5kcmFjZWFlIiwiVHJlZSIsMTIuNSwxLjA5NjkxMDAxMywiTWV4aWNvIiwiQ2hhbWVsYSIsMTkuNSwtMTA1LjA0MywiQW5nZWxhIiwzNTcsMjYuMiwxMi44LDcuMiwxLjYsMzMuNiwxNiwxNy42LDI3LjcsMjUuMiwyOCwyMy45LDc5MCwyMTUsMSwxMTAsNTQ2LDEyLDQwMywyOSw0LjA3LDg1NSwxDQo5MjQ0LDI4LCJDcmFzc3VsYV9ydXBlc3RyaXMiLCJDcmFzc3VsYWNlYWUiLCJTaHJ1YiIsMC42LC0wLjIyMTg0ODc1LCJTb3V0aCBBZnJpY2EiLCJTdGVsbGVuYm9zY2ggLSBLYXJvbyIsMzMuNjA5LDE5LjQ1NywiQW5nZWxhIiwzOTQsMTYuNSwxMy44LDUuNCw0LDI5LjYsNC40LDI1LjIsMTEuMywyMS40LDIxLjQsMTEuMyw1NDYsODcsMTQsNjAsMjUzLDQ4LDQ4LDI1MywxLjUxLDU1NywtMQ0KMjQxMjksMjE1LCJQb3RlbnRpbGxhX25pdmVhIiwiUm9zYWNlYWUiLCJIZXJiIiwwLjA1LC0xLjMwMTAyOTk5NiwiR3JlZW5sYW5kIiwiS2FuZ2VybHVzc3VhcSAtIGRyeSIsNjYuOTczLC01MC41NjgsIkFuZ2VsYSIsNzUsLTUuMSw4LjIsMi4zLDEwLDE0LjEsLTIxLjIsMzUuMyw2LjMsLTEzLjcsOC4xLC0xNi42LDI1NywzMSwxMSwzMyw5Miw0MCw4NCw0NSwxLjI5LDY1LDENCjcwNTQsMTMyLCJDZWNyb3BpYV9vYnR1c2lmb2xpYSIsIlVydGljYWNlYWUiLCJUcmVlIiwzMCwxLjQ3NzEyMTI1NSxOQSxOQSwxOC41ODMsLTk1LjExNywiQW5nZWxhIiw1NTAsMjIuNyw4LjcsNS43LDIsMzAuNiwxNS40LDE1LjIsMjMuNSwyMy45LDI0LjksMjAsMjcyNiw1MDYsNTYsNjYsMTI0OCwxOTgsNDYzLDM3MSw0LjE0LDk5MSwxDQo0NTgzLDExMSwiQmVybGluaWFfZ3JhbmRpZmxvcmEiLCJGYWJhY2VhZSAtIEMiLCJUcmVlIiwzNSwxLjU0NDA2ODA0NCwiUmVwdWJsaWMgb2YgQ29uZ28iLCJDb25nbyAtIGJhaSIsMi4xNiwxNi4xNTMsIkFuZ2VsYSIsNDAzLDI0LjgsMTAuNSw4LDAuNiwzMS42LDE4LjUsMTMuMSwyNC40LDI0LjgsMjUuNiwyNC4xLDE2NDksMjI0LDQzLDQwLDYwMywxNzcsMzUyLDUwNCw0LjI2LDE2NDgsMQ0KMTAxODksODUsIkRlY2FzcGVybXVtX2NyeXB0YW50aHVtIiwiTXlydGFjZWFlIiwiU2hydWIiLDMsMC40NzcxMjEyNTUsIkZpamkiLCJiIiwxNi41ODMsMTc5LjI0MiwiTGF1cmEiLDYxMSwyMi41LDYuMSw2LjQsMS4xLDI3LjcsMTguMyw5LjQsMjMuOCwyMSwyMy44LDIxLDI4NjUsMzgzLDExMSw0MCwxMTEwLDM3NCwxMTEwLDM3NCw0LjUsMTgwMCwtMQ0KODkyNywyMTgsIkNvcm51c19zcCIsIkNvcm5hY2VhZSIsIkhlcmIiLDAuMiwtMC42OTg5NzAwMDQsIk5vcndheSIsIk5vcndheSIsNjguNjA2LDE3LjYwNiwiQW5nZWxhIiw0NCwxLjIsNi4zLDIuNiw2LjIsMTQuNSwtOS41LDI0LDYsLTAuNiw5LjYsLTYuMiw3ODgsOTUsNDEsMjUsMjYwLDEzMiwyMTMsMTkzLDEuNTEsMTIxLDENCjMxOTQ1LDMsIlZpb2xhX21hZ2VsbGFuaWNhIiwiVmlvbGFjZWFlIiwiSGVyYiIsMC4wNSwtMS4zMDEwMjk5OTYsIkFyZ2VudGluYSIsIlJpbyBUdXJiaW8gLSBOb3Rob2ZhZ3VzIiw1MS41NzgsLTcyLjMxNSwiQW5nZWxhIiw3MDIsMy43LDkuNyw0LjksMy42LDE0LC01LjYsMTkuNiwzLjUsNC4yLDgsLTEuMiw1MDAsNTcsMzQsMTUsMTUyLDEwNiwxMjAsMTIyLDEuMjYsMzAsLTENCjM4NzYsMTQyLCJBc3RyYWdhbHVzX2NydWNpYXR1cyIsIkZhYmFjZWFlIC0gUCIsIkhlcmIiLDAuMDMyMiwtMS40OTIxNDQxMjgsTkEsTkEsMzEuNSwzNS4xLCJBbmdlbGEiLDg2MCwxNi44LDExLjYsNC41LDUuMywzMC4zLDQuOSwyNS40LDkuOCwyMi45LDIyLjksOS44LDQyMCwxMDMsMCwxMDYsMjY1LDAsMCwyNjUsMS4yNiwzMDUsMQ0KMTMyODYsODcsIkdhcmRlbmlhX2FjdGlub2NhcnBhIiwiUnViaWFjZWFlIiwiU2hydWIvVHJlZSIsMy41LDAuNTQ0MDY4MDQ0LCJBdXN0cmFsaWEiLCJRdWVlbnNsYW5kIiwxNi4xLDE0NS4zNjcsIkFuZ2VsYSIsODQwLDIxLjIsOS40LDUuOSwyLjMsMjguOSwxMywxNS45LDIzLjQsMjAsMjMuNywxNy45LDE3NDEsMzY1LDI3LDg2LDEwMzEsOTIsODY4LDExNiw0LjA0LDkwOCwtMQ0KMzk0Myw4MCwiQXN0cm9uaWRpdW1fcGFydmlmbG9ydW0iLCJNZWxhc3RvbWF0YWNlYWUiLCJTaHJ1Yi9UcmVlIiwxMiwxLjA3OTE4MTI0NiwiRmlqaSIsImFib3QiLDE3LjIzMSwxNzguOTk4LCJMYXVyYSIsMiwyNS40LDYuMiw2LjUsMS4xLDMwLjQsMjAuOSw5LjUsMjYuOCwyMy45LDI2LjgsMjMuOSwyNDk0LDM2Miw4OCw0NCwxMDAzLDI5OCwxMDAzLDI5OCw0LjI2LDE4ODYsLTENCjI2MzkxLDIxMiwiUm9zYV9hY2ljdWxhcmlzIiwiUm9zYWNlYWUiLCJTaHJ1YiIsMC44LC0wLjA5NjkxMDAxMywiVVNBIiwiQWxhc2thIGNhbXB1cyIsNjQuODYsLTE0Ny44NjIsIkFuZ2VsYSIsNjg4LC0yLjksMTAuOSwyLjIsMTQuMSwyMi40LC0yNi43LDQ5LjEsMTQuNywtMTAuNSwxNC43LC0yMSwzMDEsNTQsOCw1NywxNDQsMzEsMTQ0LDQ3LDIuNTEsMzE3LDENCjE3NjIsMTYzLCJBZXNjdWx1c19jYWxpZm9ybmljYSIsIlNhcGluZGFjZWFlIiwiVHJlZSIsMTYsMS4yMDQxMTk5ODMsIlVTQSIsIkphc3BlciBSaWRnZSAtIE9hayBmb3Jlc3QiLDM3LjQsLTEyMi4yMzYsIkFuZ2VsYSIsODQsMTMuOCwxMS4yLDUuNSwzLjMsMjQuMSw0LDIwLjEsOS42LDE3LjcsMTgsOS42LDYwMywxMjEsMiw4NiwzMTMsOSwxMywzMTMsMS41MSwyMjMsMQ0KMjE3NDMsNjIsIlBhcmFzZXJpYW50aGVzX3Rvb25hIiwiRmFiYWNlYWUgLSBNIiwiVHJlZSIsMTYsMS4yMDQxMTk5ODMsIkF1c3RyYWxpYSIsIlRvd25zdmlsbGUgVmluZSBUaGlja2V0IiwxOS4zMzIsMTQ2Ljc3MywiQW5nZWxhIiw5OSwyMy45LDkuOSw1LjIsMy4xLDMxLjYsMTIuOCwxOC44LDI3LDIwLjIsMjcuMiwxOS4zLDEwMzYsMjUzLDksMTAxLDY3NCwzMyw2MzEsNDMsNC4xNCwxMDEyLC0xDQozMjY5OSw0OSwiQ29yeW1iaWFfbWFjdWxhdGEiLCJNeXJ0YWNlYWUiLCJUcmVlIiwzMCwxLjQ3NzEyMTI1NSwiQXVzdHJhbGlhIiwiVG9vd29vbWJhIiwyOC4wODUsMTUxLjcyOSwiQW5nZWxhIiw2NDMsMTcsMTMuNyw1LjEsNC44LDI5LjUsMi44LDI2LjcsMjIuNiwxMC41LDIyLjYsMTAuNSw3MDYsOTIsMzIsMzUsMjU4LDExMSwyNTgsMTExLDIuNTEsMTExOSwtMQ0KMzAwNzUsMTA1LCJUYWNoaWdhbGlfc3AiLCJGYWJhY2VhZSAtIEMiLCJUcmVlIiwzMCwxLjQ3NzEyMTI1NSxOQSxOQSwxMC45ODMsLTY1LjcxNywiQW5nZWxhIiwxNjUsMjYuNSwxMS4xLDcsMC43LDM0LjQsMTguNywxNS43LDI2LjUsMjUuNywyNy40LDI1LjcsMTY2MSwyNjEsMTQsNjYsNzU5LDY0LDM3NSwxMjAsNC4wNywxMjI1LC0xDQoxMDY4NCwxMTUsIkRpb3NweXJvc19ib3JuZWVuc2lzIiwiRWJlbmFjZWFlIiwiVHJlZSIsMTguMSwxLjI1NzY3ODU3NSwiQnJ1bmVpIixOQSw0LjUsMTE1LjE2NywiTmF0ZSIsMjgwLDI2LDYuNyw5LDAuMiwyOS45LDIyLjUsNy40LDI1LjksMjYsMjYuMywyNS43LDM2MTIsMzU2LDIzOCwxNCwxMDUwLDc2MSw4ODEsODM4LDQuNTEsMjMzNywxDQo5MDc4LDIwMywiQ29yeWx1c19hdmVsbGFuYSIsIkJldHVsYWNlYWUiLCJUcmVlIiwxMCwxLCJTd2VkZW4iLCJTdG9ja2hvbG0iLDU4Ljk1MywxNy42MSwiQW5nZWxhIiwxMCw3LDYuNSwyLjQsNy4xLDIxLjgsLTQuOCwyNi42LDE1LjMsMSwxNi40LC0xLjcsNTA4LDYxLDI0LDI4LDE3Miw4MSwxNjIsMTEyLDIuNzksNTMzLDENCjMyNjg4LDIwLCJBbGxvY2FzdWFyaW5hX3NwIiwiQ2FzdWFyaW5hY2VhZSIsIlNocnViIiwzLDAuNDc3MTIxMjU1LCJBdXN0cmFsaWEiLCJBZGVsYWlkZSAtIENveCdzIHNjcnViIiwzNS4zNDEsMTM4Ljc0LCJBbmdlbGEiLDE3NywxNC45LDEwLDUuMSwzLjUsMjUuOSw2LjQsMTkuNSwxMC41LDE5LjMsMTkuMywxMC41LDY4Miw5NiwyMiw0NywyNzIsNzUsNzUsMjcyLDIuMTQsNjk1LC0xDQoxMTQ3Nyw1MCwiRW5nbGVyb3BoeXR1bV9uYXRhbGVuc2UiLCJTYXBvdGFjZWFlIiwiVHJlZSIsNywwLjg0NTA5ODA0LCJTb3V0aCBBZnJpY2EiLCJadWx1bGFuZCAtIGZvcmVzdCIsMjguMDcyLDMyLjAzOSwiQW5nZWxhIiwyNjcsMTkuNCwxMC4yLDYsMi4zLDI3LjIsMTAuMywxNi45LDIyLjEsMTYuNSwyMi4xLDE2LjIsOTY0LDEzOSwyOCw0OSwzNzIsOTcsMzcxLDk3LDMuMzUsNTI1LC0xDQoyMTczLDk1LCJBbGNob3JuZWFfY2FzdGFuZWFlZm9saWEiLCJFdXBob3JiaWFjZWFlIiwiU2hydWIiLDQsMC42MDIwNTk5OTEsIlBlcnUiLCJMb3MgQW1pZ29zIC0gc3VjY2Vzc2lvbmFsIiwxMi41NjYsLTcwLjEwNSwiQW5nZWxhIiwyMTcsMjQuOCwxMC41LDcuMywxLDMxLjQsMTcuMiwxNC4yLDI1LjUsMjMuMiwyNS42LDIzLjIsMzI4Myw0NzIsMTEzLDQ1LDEzMTMsMzgzLDEwMDQsMzgzLDQuMjYsMTQ3NSwtMQ0KMTEzNzYsMjE2LCJFbXBldHJ1bV9uaWdydW0iLCJFcmljYWNlYWUiLCJTaHJ1YiIsMC4wOCwtMS4wOTY5MTAwMTMsIlN3ZWRlbiIsIkFiaXNrbyAtIFBhZGR1cyIsNjguMzI0LDE4Ljg0MywiQW5nZWxhIiw1NTQsLTEsNywyLjQsNy41LDE0LjYsLTE0LjEsMjguNyw4LjEsLTYuNyw5LjEsLTEwLjEsNDM2LDY2LDE5LDM4LDE3Miw2NSwxNjIsODksMS4yNCw2MSwxDQoyNjAyNSwxOTIsIlJob2RvZGVuZHJvbl9tYWNyb3BoeWxsdW0iLCJFcmljYWNlYWUiLCJTaHJ1YiIsNSwwLjY5ODk3MDAwNCwiV2VzdGVybiBPcmVnb24iLE5BLDQ0LjIxNywtMTIyLjIzMywiQW5nZWxhIiwxNDQ2LDUsMTIuOCw0LjEsNi4xLDIzLjUsLTcuMywzMC44LC0xLjUsMTMuMSwxMy4xLC0yLjEsMTQyNywyNDYsMjMsNjUsNjkyLDEwNiwxMDYsNjQyLDIuMDcsNDc4LDENCjE4MDczLDgzLCJMZXBpcm9uaWFfYXJ0aWN1bGF0YSIsIkN5cGVyYWNlYWUiLCJIZXJiIiwyLjUsMC4zOTc5NDAwMDksIkZpamkiLCJ0IiwxNi44NTgsMTc5Ljk2NywiTGF1cmEiLDI2NSwyNC4zLDYuMSw2LjUsMS4xLDI5LjMsMjAsOS4zLDI1LjYsMjIuOCwyNS42LDIyLjgsMjU2NywzNTEsOTUsNDIsMTAwOSwzMjQsMTAwOSwzMjQsNC41LDE4MDAsLTENCjE3NzU1LDE4MCwiTGFyaXhfb2xnZW5zaXMiLCJQaW5hY2VhZSIsIlRyZWUiLDMyLDEuNTA1MTQ5OTc4LCJDaGluYSIsTkEsNDIuMzMzLDEzNS41LCJBbmdlbGEiLDMsMjMsNC42LDMuMSwzLjgsMzAsMTUuMiwxNC44LDI3LjEsMTgsMjcuNiwxOCwxMzI3LDE1MSw1MywyNiw0MDksMTk2LDM4MiwxOTYsTkEsTkEsMQ0KMTIwOTQsOCwiRXVjYWx5cHR1c19vYmxvbmdpZm9saWEiLCJNeXJ0YWNlYWUiLCJUcmVlIiwzMCwxLjQ3NzEyMTI1NSwiQXVzdHJhbGlhIiwiSHVvbiBSZCwgVGFzbWFuaWEiLDQyLjkyMSwxNDcuMjc1LCJBbmdlbGEiLDM0Niw5LjksOC44LDUsMywxOS42LDIuMiwxNy40LDYuNSwxMy44LDEzLjgsNS45LDEwMzcsMTE1LDYzLDE3LDMxMSwyMDUsMjA1LDI5NiwyLjgyLDc0MywtMQ0KMjMzOTAsMTA0LCJQbGFuY2hvbmlhX2NhcmV5YSIsIkxlY3l0aGlkYWNlYWUiLE5BLDEwLDEsTkEsIk1lbHZpbGxlIElzbGFuZCIsMTEuNSwxMzAuOTY3LCJBbmdlbGEiLDQ0LDI3LjEsOS40LDYuMywxLjQsMzMuMiwxOC41LDE0LjcsMjcuNywyNC44LDI4LjUsMjQuOCwxNjY0LDM1NSwyLDEwMCwxMDMyLDEyLDQ1MywxMiw0LjA0LDk2OSwtMQ0KODEyMiwyMDAsIkNpcnNpdW1fdnVsZ2FyZSIsIkFzdGVyYWNlYWUiLCJIZXJiIiwyLDAuMzAxMDI5OTk2LCJOZXRoZXJsYW5kcyIsTkEsNTIuOCw0LjMzMywiQW5nZWxhIiwxNyw5LDUuNCwyLjcsNS4zLDE5LjksMC4xLDE5LjgsMTAuNiw5LjksMTUuNywyLjksNzgxLDg4LDQyLDI1LDI1NiwxMzksMjAwLDE4NCwzLjQ2LDczMywxDQoxMjUzOSwxNTIsIkZhZ3VzX2NyZW5hdGEiLCJGYWdhY2VhZSIsIlRyZWUiLDI5LjMsMS40NjY4Njc2MiwiSmFwYW4iLE5BLDM1LjM1LDEzMy41NSwiQW5nZWxhIiw4NjcsOS40LDguMywyLjYsOC4zLDI1LjgsLTUuNywzMS41LDE5LjksMS40LDIwLjEsLTEuMiwxOTc1LDI4OCwxMDIsMzcsNzIxLDMzMSw3MDYsMzQ5LDQuMTQsMTEwNiwxDQo2NzgxLDg0LCJDYXNlYXJpYV9zdGVub3BoeWxsYSIsIlNhbGljYWNlYWUiLCJTaHJ1Yi9UcmVlIiw0LDAuNjAyMDU5OTkxLCJGaWppIiwiYnQiLDE2LjcyMSwxNzkuNjA0LCJMYXVyYSIsNzQsMjUuMyw2LjIsNi43LDEsMzAuMiwyMSw5LjIsMjYuNSwyMy44LDI2LjUsMjMuOCwyNDQ0LDM0Myw4NCw0NCw5ODksMjg4LDk4OSwyODgsNC41LDE4MDAsLTENCjU0NzgsMjE0LCJDYWxhbWFncm9zdGlzX3N0cmljdGEiLCJQb2FjZWFlIiwiSGVyYiIsMC4yMiwtMC42NTc1NzczMTksIkdyZWVubGFuZCIsIkthbmdlcmx1c3N1YXEgLSB3ZXQiLDY2Ljk3MywtNTAuNTY5LCJBbmdlbGEiLDY1LC01LjEsOC4yLDIuMywxMCwxNC4xLC0yMS4yLDM1LjMsNi4zLC0xMy43LDguMSwtMTYuNiwyNTcsMzEsMTEsMzMsOTIsNDAsODQsNDUsMS4yOSw2NSwxDQoyMjg4OSwxOTYsIlBpbnVzX3BvbmRlcm9zYSIsIlBpbmFjZWFlIiwiVHJlZSIsNDEsMS42MTI3ODM4NTcsTkEsTkEsNDUuODE3LC0xMjEuOTUsIkFuZ2VsYSIsMzU1LDkuNSwxMC42LDMuOSw1LjcsMjUuNCwtMS42LDI3LDIuOSwxNi44LDE2LjksMi40LDI1NjEsNDU4LDIxLDcxLDEyNzgsMTI1LDE0MiwxMjE0LDEuNzYsNTc5LDENCjIyNjU3LDU2LCJQaHlsbG9zdHlsb25fcmhhbW5vaWRlcyIsIlVsbWFjZWFlIiwiVHJlZSIsMjQsMS4zODAyMTEyNDIsIkFyZ2VudGluYSIsIlR1Y3VtYW4gLSBZdW5nYXMgTm9ydGgiLDIzLjc0NywtNjQuODU0LCJBbmdlbGEiLDczNywxOS44LDEyLjksNS4yLDMuOSwzMC43LDYuMiwyNC41LDIzLjQsMTQuNCwyNC4yLDE0LjQsNzkzLDE2Miw0LDg5LDQ1NSwyMCw0MzksMjAsMi40Miw0NzYsLTENCjExMjI0LDc1LCJFbGF0b3N0ZW1hX25lbW9yb3N1bSIsIlVydGljYWNlYWUiLCJIZXJiIiwyLDAuMzAxMDI5OTk2LCJGaWppIiwiYWJrdCIsMTcuNTUyLDE3OC44NzMsIkxhdXJhIiw2LDI1LDYuMiw2LjMsMS4yLDMwLjIsMjAuNCw5LjgsMjYuNSwyMy4zLDI2LjUsMjMuMywyNjYyLDM4NiwxMDMsNDAsMTAwOCwzNTAsMTAwOCwzNTAsNC41LDE4MDAsLTENCjI0OTg3LDUxLCJQc3ljaG90cmlhX2NhcnRoYWdlbmVuc2lzIiwiUnViaWFjZWFlIiwiU2hydWIiLDQuNSwwLjY1MzIxMjUxNCwiQXJnZW50aW5hIiwiVHVjdW1hbiAtIFl1bmdhcyBTb3V0aCIsMjYuNzYzLC02NS4zMzMsIkFuZ2VsYSIsOTM1LDE4LjYsMTEuNSw0LjgsNC4yLDI5LjgsNiwyMy44LDIzLjYsMTQuNiwyMy42LDEyLjksODgyLDE4NCwxMCw4Miw0NzIsMzMsNDcyLDM0LDEuNTEsNTk2LC0xDQoyMjEwMywyOSwiUGVyc29vbmlhX2xhbmNlb2xhdGEiLCJQcm90ZWFjZWFlIiwiU2hydWIiLDIuNCwwLjM4MDIxMTI0MiwiQXVzdHJhbGlhIiwiS3VyaW5nYWkgLSBDaGFsbGVuZ2VyIiwzMy41OTUsMTUxLjI3NiwiQW5nZWxhIiwxNTEsMTYuOSw5LjgsNC44LDMuOCwyNiw1LjcsMjAuMywyMS4zLDEyLjQsMjEuNCwxMS43LDEzMTMsMTYwLDY1LDI5LDQ1OCwyMTMsMzkyLDI4Myw0LjUxLDE0MzUsLTENCjIzNTYsMTAwLCJBbGxvdGVyb3BzaXNfc2VtaWFsYXRhIiwiUG9hY2VhZSIsIkhlcmIiLDIsMC4zMDEwMjk5OTYsIkF1c3RyYWxpYSIsIkhvd2FyZCBTcHJpbmdzLCBEYXJ3aW4iLDEyLjQ5NCwxMzEuMTA4LCJBbmdlbGEiLDI2LDI3LjMsMTAuNSw2LDEuNywzNC42LDE3LjIsMTcuNCwyOC4xLDI0LjcsMjkuMiwyNC43LDE1MDUsMzcxLDEsMTA0LDk3MCw3LDQwOCw3LDQuMDcsOTU2LC0xDQoxMTc3NSwxOTQsIkVyaWdlcm9uX2dsYXVjdXMiLCJBc3RlcmFjZWFlIiwiSGVyYiIsMC4wNCwtMS4zOTc5NDAwMDksIlVTQSIsIk9yZWdvbiAtIFlhcXVpbmEgSGVhZCIsNDQuNjY3LC0xMjQuMDcyLCJBbmdlbGEiLDMyNCwxMC42LDcuNyw1LDIuOCwxOC45LDMuNSwxNS40LDcuNiwxNCwxNC40LDcuMiwxOTM2LDMxNSwyNyw2Miw5MDAsMTMzLDEzNCw4NDgsMi41MSw1NzIsMQ0KMjQyMzksOTcsIlBvdXJvdW1hX21pbm9yIiwiVXJ0aWNhY2VhZSIsIlRyZWUiLDI4LDEuNDQ3MTU4MDMxLCJQZXJ1IiwiTG9zIEFtaWdvcyAtdGVycmFjZSIsMTIuNTUyLC03MC4xMTEsIkFuZ2VsYSIsMjM3LDI0LjgsMTAuNSw3LjMsMSwzMS40LDE3LjIsMTQuMiwyNS40LDIzLjIsMjUuNiwyMy4yLDMyODMsNDcxLDExMyw0NSwxMzEyLDM4MywxMDA0LDM4Myw0LjI2LDE0NzUsLTENCjMxNDMyLDIxMywiVmFjY2luaXVtX3ZpdGlzLWlkYWVhIiwiRXJpY2FjZWFlIiwiU2hydWIiLDAuMDcsLTEuMTU0OTAxOTYsIlVTQSIsIkFsYXNrYSAtIDEyIE1pbGUiLDY1LjM5MSwtMTQ1Ljg1NCwiQW5nZWxhIiw5NjYsLTYuNCwxMS4yLDIuMSwxNS4xLDIwLjYsLTMxLjQsNTIsMTIuNywtMTUsMTIuNywtMjUuNSwyNDQsNDUsNyw1OSwxMjIsMjgsMTIyLDM4LDIuMDcsMTkyLDENCjExODg0LDE4MywiRXJ1Y2FzdHJ1bV9nYWxsaWN1bSIsIkJyYXNzaWNhY2VhZSIsIkhlcmIiLDAuMjgsLTAuNTUyODQxOTY5LCJVU0EiLE5BLDQzLC03Ni4xNSwiQW5nZWxhIiwxMzQsOC41LDEwLjgsMi45LDkuMywyNy42LC05LjUsMzcuMSwxMC4zLC0zLDIwLjIsLTMuOSw5OTYsOTYsNjIsMTMsMjc1LDIwMCwyNzEsMjEzLDMuMTQsOTcyLDENCjE4MjI2LDcwLCJMZXVjb3BvZ29uX3NlcHRlbnRyaW9uYWxpcyIsIkVyaWNhY2VhZSIsIlNocnViL1RyZWUiLDUsMC42OTg5NzAwMDQsIkZpamkiLCJhYmsiLDE3Ljc4MywxNzguNTA4LCJMYXVyYSIsMzAsMjQuOCw2LjMsNi4zLDEuMywzMC4xLDIwLjEsMTAsMjYuMiwyMy4yLDI2LjQsMjMsMjgwMywzOTAsMTE3LDM3LDEwMTcsMzg5LDEwMTMsMzkzLDQuNTEsMTg2NCwtMQ0KMjE2MDUsOTMsIlBhbmljdW1fc3AiLCJQb2FjZWFlIiwiSGVyYiIsMC41LC0wLjMwMTAyOTk5NiwiWmFtYmlhIiwiWmFtYmlhIC0gbWlvbWJvIiwxMy4yNDksMzAuMjgsIkFuZ2VsYSIsMTUwNiwxOC42LDEyLjQsNS42LDIuNCwyOS4zLDcuNSwyMS44LDIwLjIsMTUsMjAuOSwxNSwxMDk5LDI3MCwwLDExOCw3OTAsMCwzODMsMCwyLjUxLDY4NCwtMQ0KNDYxOSwyMTcsIkJldHVsYV9uYW5hIiwiQmV0dWxhY2VhZSIsIlNocnViIiwwLjgsLTAuMDk2OTEwMDEzLCJTd2VkZW4iLCJBYmlza28gLSBmb3Jlc3QiLDY4LjMyOSwxOC44MzYsIkFuZ2VsYSIsNTIxLC0wLjcsNywyLjQsNy40LDE0LjgsLTEzLjcsMjguNSw4LjMsLTYuNCw5LjMsLTkuNyw0MjIsNjQsMTgsMzksMTY4LDYyLDE1OCw4NSwxLjI0LDYxLDENCjQxMDEsMTQsIkF1c3Ryb2NlZHJ1c19jaGlsZW5zaXMiLCJDdXByZXNzYWNlYWUiLCJUcmVlIiwzNSwxLjU0NDA2ODA0NCwiQXJnZW50aW5hIiwiQmFyaWxvY2hlIiw0MS4yNDIsLTcxLjQyNSwiQW5nZWxhIiwxMDM5LDcsMTEuNyw1LjEsNC4yLDIwLjMsLTIuNiwyMi45LDEuNywxMi40LDEyLjQsMS43LDk3MiwxNzUsMjgsNTYsNDQzLDEwNiwxMDYsNDQzLDQuMTQsNjkxLC0xDQozMDAwOCw2NiwiU3l6eWdpdW1fYnJhY2tlbnJpZGdlaSIsIk15cnRhY2VhZSIsIlRyZWUiLDIwLDEuMzAxMDI5OTk2LCJGaWppIiwiYWtvIiwxOC4xNSwxNzguMzU2LCJMYXVyYSIsMTMsMjQuOCw2LjMsNi4xLDEuNCwzMC4yLDE5LjksMTAuMywyNi4xLDIzLjEsMjYuNCwyMi45LDI5OTMsMzcyLDE1MCwzMCwxMDI1LDQ2OCw5NjksNDgzLDQuNTEsMTg2NCwtMQ0KMjUwMTcsMTUsIlB0ZXJpZGl1bV9lc2N1bGVudHVtIiwiRGVubnN0YWVkdGlhY2VhZSIsIkZlcm4iLDEuOCwwLjI1NTI3MjUwNSwiQXVzdHJhbGlhIiwiR3JlZW4ncyBCdXNoIC0gTWVsYm91cm5lIiwzOC40MywxNDQuOTIyLCJBbmdlbGEiLDE2NSwxMy41LDcuNSw0LjUsMy4yLDIyLjgsNi4yLDE2LjYsMTAuMiwxNy42LDE3LjYsOS41LDkxNSwxMDEsNDUsMjUsMjg5LDE1MCwxNTAsMjg3LDQuMDQsMTAyMywtMQ0KMjY2MSwxNTksIkFtZWxhbmNoaWVyX2FyYm9yZWEiLCJSb3NhY2VhZSIsIlRyZWUiLDE5LDEuMjc4NzUzNjAxLCJVU0EiLCJUd2luIHNwcmluZ3MsIFZpcmdpbmlhIiwzNi44MTcsLTgyLjQ2NCwiQW5nZWxhIiw1MDEsMTIuNywxMywzLjgsNy44LDI5LjYsLTQuNSwzNC4xLDIwLjYsMTMuNCwyMi40LDIuMywxMTIxLDExNyw3MSwxMiwzMjIsMjQwLDMxMCwyNjUsNC4wNywxMzI1LDENCjI5NjA4LDE5LCJTdGlwYV9zcCIsIlBvYWNlYWUiLCJIZXJiIiwwLjM1LC0wLjQ1NTkzMTk1NiwiQXJnZW50aW5hIiwiTWVuZG96YSAtIFBheXVuaWEiLDM2LjI1LC02OC44MjQsIkFuZ2VsYSIsMTUwMiwxMC45LDE2LjMsNS4yLDUuNSwyNy43LC0zLjYsMzEuMywxNy4zLDYuOSwxOCwzLjgsMjA4LDIzLDEzLDE3LDY1LDQ0LDYxLDQ3LDEuODksNTIyLC0xDQoyOTYwOSw5LCJTdGlwYV9zcGVjaW9zYSIsIlBvYWNlYWUiLCJIZXJiIiwwLjI1LC0wLjYwMjA1OTk5MSwiQXJnZW50aW5hIiwiUHVlcnRvIE1hZHJ5biAtIHN0ZXBwZSIsNDIuNzksLTY0LjA5MiwiQW5nZWxhIiw3NiwxMywxMC4yLDQuNiw0LjMsMjQuNCwyLjYsMjEuOCwxMy43LDE3LDE4LjMsNy40LDIxNCwyOCw5LDM1LDc3LDM2LDM3LDU1LDEuMDEsNDA0LC0xDQozOTcxLDExLCJBdGhlcm9zcGVybWFfbW9zY2hhdHVtIiwiQXRoZXJvc3Blcm1hdGFjZWFlIiwiVHJlZSIsMzAsMS40NzcxMjEyNTUsIkF1c3RyYWxpYSIsIlRhc21hbmlhIiw0Mi42ODMsMTQ2LjM1LCJBbmdlbGEiLDc0MCw3LjUsOC40LDQuOCwzLDE3LjUsMC4xLDE3LjQsNCwxMS40LDExLjQsMy42LDE3MjAsMTgyLDcyLDIzLDUzMCwyODAsMjgwLDQ5NSwyLjk2LDY0MywtMQ0KMTA3OTYsNjAsIkRvbWJleWFfY2lsaWF0YSIsIk1hbHZhY2VhZSIsTkEsMTUsMS4xNzYwOTEyNTksIkZyYW5jZT8iLCJSZXVuaW9uIElzbGFuZCIsMjEsNTUuNjUsIkFuZ2VsYSIsMTkxLDIyLjcsNi4zLDUuMiwyLjEsMjguNywxNi44LDExLjksMjUuMywyMC40LDI1LjMsMjAsMTM5NywyMzUsMzcsNTcsNjUwLDEzNyw2NTAsMTcyLE5BLE5BLC0xDQoxOTc5Nyw3NCwiTWVsaWN5dHVzX2Zhc2NpZ2VyIiwiVmlvbGFjZWFlIiwiU2hydWIvVHJlZSIsMTAsMSwiRmlqaSIsImF0bmdhdSIsMTcuNTY0LDE3OS4wODksIkxhdXJhIiwxLDI1LjEsNi4zLDYuNCwxLjIsMzAuMiwyMC41LDkuNywyNi42LDIzLjUsMjYuNiwyMy41LDI1OTgsMzc4LDEwMCw0MSw5OTQsMzM5LDk5NCwzMzksNC41LDE4MDAsLTENCjcwMzksMTQ4LCJDZWFub3RodXNfZ3JlZ2dpaSIsIlJoYW1uYWNlYWUiLCJTaHJ1YiIsMywwLjQ3NzEyMTI1NSwiVVNBIiwiQ2FsaWZvcm5pYSIsMzMuMzgzLC0xMTYsIkFuZ2VsYSIsLTcxLDIyLjksMTcuNCw0LjYsNy4xLDQxLjcsNC41LDM3LjIsMTUuNSwyNS43LDMxLjksMTMuOSw3MywxMiwwLDUxLDMxLDQsMTAsMzAsMS41MSw0MTUsMQ0KMTA5ODYsMTE0LCJEdWd1ZXRpYV9zdXJpbmFtZW5zaXMiLCJBbm5vbmFjZWFlIiwiVHJlZSIsMzAsMS40NzcxMjEyNTUsTkEsTkEsNC4wODMsLTUyLjY2NywiQW5nZWxhIiwxNzQsMjQuOSw4LjgsNy40LDAuNCwzMS40LDE5LjYsMTEuOCwyNC44LDI1LjQsMjUuNCwyNC4zLDMzMjksNTAzLDc4LDQ3LDEyNDUsMzA0LDMyOCwxMDU0LDQuNTEsMTg5NiwxDQoyMTkzMSwyMjEsIlBlZGljdWxhcmlzX2hpcnN1dGEiLCJPcm9iYW5jaGFjZWFlIiwiSGVyYiIsMC4wOCwtMS4wOTY5MTAwMTMsIkdyZWVubGFuZCIsIlphY2tlbmJlcmcgLSBzYWxpeCIsNzQuNDc0LC0yMC41MzYsIkFuZ2VsYSIsMzcsLTEwLjUsNywyLjEsOS4zLDYuNSwtMjUuOCwzMi4zLC0zLjcsLTYuOCwyLjMsLTIwLjcsMjM2LDI2LDEwLDI0LDczLDM2LDU3LDYzLDIuNiw0LDENCjQzMzAsNDQsIkJhbmtzaWFfaG9va2VyaWFuYSIsIlByb3RlYWNlYWUiLCJTaHJ1YiIsMi4wMiwwLjMwNTM1MTM2OSwiQXVzdHJhbGlhIixOQSwyOS41NjcsMTE1LjIzMywiQW5nZWxhIiw5NCwyMC4yLDEzLjUsNSw0LjcsMzUuMiw4LjcsMjYuNSwxNS43LDI0LDI2LjUsMTQuNSw0NzUsMTA4LDcsODQsMjY3LDI3LDMyLDI2NywxLjk5LDQxMSwtMQ0KODM0MSwxMzAsIkNsaWRlbWlhX3NlcmljZWEiLCJNZWxhc3RvbWF0YWNlYWUiLE5BLDAuOCwtMC4wOTY5MTAwMTMsTkEsTkEsMTcsLTg5LCJBbmdlbGEiLDM3MSwyMy45LDguNSw1LjksMS44LDMwLjcsMTYuNCwxNC4zLDIzLjksMjMuMywyNS45LDIxLjQsMTU0NSwyMTQsNTQsNDYsNjE2LDE2MywzMTksMjU2LDQuNTEsMTc2MSwxDQozMjI5NiwxNjcsIlhhbnRoaXVtX29jY2lkZW50YWxlIiwiQXN0ZXJhY2VhZSIsIkhlcmIiLDEuMTUsMC4wNjA2OTc4NCwiSmFwYW4iLE5BLDM4LjIxNywxNDAuODMzLCJBbmdlbGEiLDM4LDEyLjQsOCwyLjUsOC4xLDI4LjQsLTIuNCwzMC44LDIyLjksMi4zLDIyLjksMi4zLDEyNjMsMTgxLDUwLDQzLDUwNiwxNjIsNTA2LDE2MiwzLjU3LDkzMiwxDQoyNzQwNSwxNDEsIlNhcmNvcG90ZXJpdW1fc3Bpbm9zdW0iLCJSb3NhY2VhZSIsIlNocnViIiwwLjQ1LC0wLjM0Njc4NzQ4NiwiSXNyYWVsIiwiTGVoYXZpbSIsMzEuMzU2LDM0LjgzNSwiQW5nZWxhIiwzNzksMTguOSwxMiw0LjcsNSwzMS44LDYuNCwyNS40LDEyLjEsMjQuNywyNC43LDEyLjEsMjkzLDY5LDAsMTA2LDE4NiwwLDAsMTg2LDEuMjYsMzA1LDENCjQyOTcsOTYsIkJhbWJ1c2Ffd2ViZXJiYXVlcmkiLCJQb2FjZWFlIiwiU2hydWIiLDYsMC43NzgxNTEyNSwiUGVydSIsIkxvcyBBbWlnb3MgLSBCYW1ib28iLDEyLjU2NiwtNzAuMDk5LCJBbmdlbGEiLDI1NiwyNC44LDEwLjUsNy4zLDEsMzEuNCwxNy4yLDE0LjIsMjUuNiwyMy4zLDI1LjcsMjMuMywzMjY5LDQ3MCwxMTIsNDUsMTMwOCwzODAsMTAwMSwzOTcsNC4yNiwxNDc1LC0xDQozMDk3MSwyMDcsIlRyaWdsb2NoaW5fcGFsdXN0cmUiLCJKdW5jYWdpbmFjZWFlIiwiSGVyYiIsMC4xNSwtMC44MjM5MDg3NDEsIlVTQSIsIkFsYXNrYSwgWXVrb24gZGVsdGEiLDYxLjI1LC0xNjUuNSwiQW5nZWxhIiwxLC0xLjIsNi44LDIuMyw4LjMsMTMuOCwtMTUuMywyOS4xLDkuMSwtOC43LDkuNiwtMTEuMSw2NTcsMTMzLDI0LDYxLDMxMyw4NSwyNTYsOTAsMi4xNSwyMDQsMQ0KNDYxNCwyMDIsIkJldHVsYV9wZW5kdWxhIiwiQmV0dWxhY2VhZSIsIlNocnViIiwxLjU4NDg5MzE5MiwwLjIsTkEsTkEsNTguODY3LDI1LCJBbmdlbGEiLDc1LDUuMSw2LjYsMi4xLDguMiwyMC45LC05LjIsMzAuMSw2LjEsLTEuOCwxNS43LC01LjEsNjkxLDc4LDM0LDI4LDIyNSwxMTIsMjAyLDE0NCwyLjc2LDQ3NCwxDQoxMjYyMSw0LCJGZXN0dWNhX2dyYWNpbGxpbWEiLCJQb2FjZWFlIiwiSGVyYiIsMC4xNCwtMC44NTM4NzE5NjQsIkFyZ2VudGluYSIsIlJpbyBUdXJiaW8gLSBoZWF0aCIsNTEuNTc1LC03Mi4zMTIsIkFuZ2VsYSIsNzQ3LDMuNyw5LjcsNC45LDMuNiwxNCwtNS42LDE5LjYsMy41LDQuMiw4LC0xLjIsNTAwLDU3LDM0LDE1LDE1MiwxMDYsMTIwLDEyMiwxLjI2LDMwLC0xDQoxMjA0Myw1NSwiRXVjYWx5cHR1c19naWxsZW5paSIsIk15cnRhY2VhZSIsIlNocnViIiw1LDAuNjk4OTcwMDA0LCJBdXN0cmFsaWEiLCJBbGljZSAtIHRoZSBnYXAiLDIzLjc5NSwxMzMuODYzLCJBbmdlbGEiLDcwMSwyMC45LDE2LjMsNC44LDYsMzcsMy42LDMzLjQsMjguMSwxNC44LDI4LjEsMTIuNywyNzgsMzcsOSw0MiwxMDksMzUsMTA5LDQyLDEuMzIsNzU2LC0xDQozMjY3NSwxMDIsIl84MzI0IixOQSxOQSwyLjUsMC4zOTc5NDAwMDksIlBlcnUiLCJNYW51IiwxMi4xODMsLTcwLjkxNywiQW5nZWxhIiwzNTAsMjQuOCwxMC44LDcuNiwwLjgsMzEuNCwxNy4zLDE0LjEsMjUuMiwyMy42LDI1LjYsMjMuNiwyOTIwLDM5Nyw5OSw0MywxMTI1LDMzNiw4OTEsMzUwLDQuMjYsMTQ2MSwtMQ0KNTIyNiwyNSwiQnJ1bmlhX2FsYmlmb3JhIiwiQnJ1bmlhY2VhZSIsTkEsMywwLjQ3NzEyMTI1NSwiU291dGggQWZyaWNhIixOQSwzNC4zMTcsMTkuOTE3LCJBbmdlbGEiLDIyNywxNi40LDEwLjksNS4zLDMuNCwyNi43LDYuMiwyMC41LDEyLDIwLjUsMjAuNSwxMiw1MDEsNjMsMjQsMjksMTcxLDgxLDg5LDE3MSwyLjE0LDgyNSwtMQ0KMTIwNDYsNDMsIkV1Y2FseXB0dXNfc3AyIiwiTXlydGFjZWFlIiwiVHJlZSIsMjAsMS4zMDEwMjk5OTYsIkF1c3RyYWxpYSIsIkFybWlkYWxlIC0gR29vbm9vd2lnYWwiLDI5LjgxNSwxNTEuMTIxLCJBbmdlbGEiLDY4NiwxNS4zLDE0LjUsNC45LDUuMywyOS4zLDAuMSwyOS4yLDIxLjgsOC4yLDIxLjgsOC4yLDc4MCwxMDUsMzcsMzMsMjg3LDEzMywyODcsMTMzLDMuMjYsMTI3MiwtMQ0KMjI3LDEzOCwiQWNhY2lhX2JlcmxhbmRpZXJpIiwiRmFiYWNlYWUgLSBNIiwiU2hydWIvVHJlZSIsNiwwLjc3ODE1MTI1LCJNZXhpY28iLCJMaW5hcmVzIC0gdGhvcm5zY3J1YiIsMjQuNzg2LC05OS41MTUsIkFuZ2VsYSIsMzU0LDIyLjYsMTMuOSw0LjgsNS4xLDM2LjIsNy42LDI4LjYsMjYsMTUuNiwyOC41LDE1LjYsODAzLDE1NCwyMCw2NiwzMzgsNjgsMjg1LDY4LDIuMjYsMTA0NCwxDQoxODE3NCwyMiwiTGV1Y2FkZW5kcm9uX21lcmlkaWFudW0iLCJQcm90ZWFjZWFlIiwiU2hydWIiLDEuNywwLjIzMDQ0ODkyMSwiU291dGggQWZyaWNhIixOQSwzNC41ODMsMTkuOTE3LCJBbmdlbGEiLDcxLDE2LjcsOC41LDUuMSwyLjgsMjUsOC41LDE2LjUsMTMuMiwyMC4xLDIwLjIsMTMuMiw0ODQsNTksMjAsMzQsMTc2LDY3LDc3LDE3NiwyLjE0LDgyNSwtMQ0KNTQ2NCwxOTUsIkNha2lsZV9lZGVudHVsYSIsIkJyYXNzaWNhY2VhZSIsIkhlcmIiLDAuMiwtMC42OTg5NzAwMDQsIkNhbmFkYSIsIk5vdmEgU2NvdGlhIiw0NC42ODMsLTYzLjExNywiQW5nZWxhIiw0LDYuNCw5LjEsMi44LDgsMjIuNSwtOS41LDMyLC0wLjgsMTMuNCwxNi41LC0zLjgsMTM3OSwxNDksOTEsMTYsNDMyLDI5NCwyOTYsNDAwLDMuMjYsNzExLDENCjEyMDg5LDI0LCJFdWNhbHlwdHVzX3NvY2lhbGlzIiwiTXlydGFjZWFlIiwiVHJlZSIsNiwwLjc3ODE1MTI1LCJBdXN0cmFsaWEiLCJBZGVsYWlkZSAtIEJyb29rZmllbGQgTWFsbGVlIiwzNC4zMiwxMzkuNTAzLCJBbmdlbGEiLDk1LDE2LjIsMTMuMyw1LjEsNC42LDMwLjcsNC44LDI1LjksMTMsMjEuOSwyMiwxMC41LDI3MiwzMCwxNSwyMyw4Myw0OSw1MCw3OSwyLjE0LDc3MywtMQ0KMjc4NjAsODgsIlNjbGVyb2xvYml1bV9wYW5pY3VsYXR1bSIsIkZhYmFjZWFlIC0gQyIsTkEsMy44LDAuNTc5NzgzNTk3LCJCcmF6aWwiLE5BLDE1LjkzMywtNDcuODgzLCJBbmdlbGEiLDExMDAsMjAuOCwxMS42LDcuMiwxLjEsMjcuOSwxMS44LDE2LjEsMjEuMywxOS4zLDIxLjcsMTksMTY5OCwzMDEsNyw3OCw4NTMsMzMsNDcyLDQ5LDQuMjYsMTE4MCwtMQ0KNjUyOSwxNDMsIkNhcm5lZ2llYV9naWdhbnRlYSIsIkNhY3RhY2VhZSIsIlNocnViIiw4LDAuOTAzMDg5OTg3LCJVU0EiLCJUdWNzb24gLSBTb25vcmFuIGRlc2VydCIsMzIuMzEsLTExMC43MzksIkFuZ2VsYSIsOTcxLDE4LjksMTUuNyw0LjYsNi45LDM2LjMsMi41LDMzLjgsMjcuMiwyMi4yLDI3LjksMTAuNCwzODAsNzEsNiw2MSwxNzYsMjQsMTQ0LDk4LDEuMDEsNDc3LDENCjUwNzksOTIsIkJyaWRlbGlhX21pY3JhbnRoYSIsIlBoeWxsYW50aGFjZWFlIiwiVHJlZSIsOSwwLjk1NDI0MjUwOSwiWmFtYmlhIiwiWmFtYmlhIC0gTWF0ZXNoaSIsMTMuMjUzLDMwLjA0NywiQW5nZWxhIiwxMzg4LDE5LjEsMTIuNyw1LjUsMi42LDMwLjEsNy4zLDIyLjgsMjAuOSwxNS4xLDIxLjcsMTUuMSwxMDg1LDI2NSwwLDExOCw3NzgsMCwzODMsMCw0LjAzLDY1MiwtMQ0KMjgwNDYsNSwiU2VuZWNpb19maWxhZ2lub2lkZXMiLCJBc3RlcmFjZWFlIiwiSGVyYiIsMC42LC0wLjIyMTg0ODc1LE5BLCJQYXRhZ29uaWEiLDQ1LjQxNywtNzAsIkFuZ2VsYSIsNTAwLDkuNiwxMS4yLDQuNiw0LjgsMjIuNiwtMS4zLDIzLjksMy45LDE1LjYsMTUuNiwzLjMsMTc0LDIzLDcsMzUsNjUsMjUsMjUsNTcsMi40Miw1MDUsLTENCjMyMTIwLDE3MSwiVnVscGlhX21pY3Jvc3RhY2h5cyIsIlBvYWNlYWUiLCJIZXJiIiwwLjIzOSwtMC42MjE2MDIwOTksTkEsTkEsMzguODY3LC0xMjIuNDE3LCJBbmdlbGEiLDY0NiwxMy41LDE1LjMsNC43LDYsMzIuOCwwLjUsMzIuMyw2LjUsMjEuNCwyMS40LDYuNSw4NjcsMTgyLDEsODgsNDY5LDExLDExLDQ2OSwyLjE0LDU5NSwxDQoyOTMzMSw0OCwiU3Bpcm9zdGFjaHlzX2FmcmljYW51cyIsIkV1cGhvcmJpYWNlYWUiLCJTaHJ1YiIsNC41LDAuNjUzMjEyNTE0LCJTb3V0aCBBZnJpY2EiLCJadWx1bGFuZCAtIE1idXphbmUiLDI4LjIyMSwzMS43OTQsIkFuZ2VsYSIsMTYxLDIxLDExLDUuOSwyLjUsMjkuMywxMC43LDE4LjYsMjMuOSwxNy40LDIzLjksMTcuNCw4MzQsMTE2LDI1LDQ3LDMyMSw4NCwzMDksODQsMy4zNSw1MjUsLTENCjI4MjQ0LDY3LCJTZXNiYW5pYV9ncmFuZGlmbG9yYSIsIkZhYmFjZWFlIC0gUCIsIlRyZWUiLDEyLDEuMDc5MTgxMjQ2LCJGaWppIiwiYS1uZ2F1IiwxNy45MTcsMTc4LjY1LCJMYXVyYSIsMTIsMjQuOCw2LjMsNi4zLDEuMywzMC4xLDIwLjEsMTAsMjYuMiwyMy4yLDI2LjQsMjMsMjgzNSw0MDEsMTE2LDM3LDEwMjYsMzg1LDEwMTksMzk4LDQuNTEsMTg2NCwtMQ0KMTI2MDQsMTQ1LCJGZXJvY2FjdHVzX2N5bGluZHJhY2V1cyIsIkNhY3RhY2VhZSIsIlNocnViIiwxLjcsMC4yMzA0NDg5MjEsIlVTQSIsIlR1Y3NvbiIsMzIuNiwtMTExLjIzMywiQW5nZWxhIiw2OTAsMjAuNSwxNy4yLDQuNiw3LjQsMzkuMiwyLjYsMzYuNiwyOS41LDIzLjgsMzAsMTEuNCwzNTQsNTcsOCw1MCwxNDMsMjksMTE3LDk3LDEuMjYsMzQ5LDENCjE2NjE2LDE3MiwiSXBvbW9wc2lzX2FnZ3JlZ2F0YSIsIlBvbGVtb25pYWNlYWUiLE5BLDAuODEsLTAuMDkxNTE0OTgxLCJVU0EiLCJDb2xvcmFkbyIsMzguODY3LC0xMDYuOTY3LCJBbmdlbGEiLDI2OTgsMS4zLDE3LjksNCw5LDIzLjYsLTIwLjksNDQuNSwtMTAuNiw1LjYsMTIuNiwtMTAuNiw1MzksNjAsMjgsMjAsMTY2LDEwMCwxMjMsMTY2LDIuMjQsMzM5LDENCjIyNzMyLDIxMSwiUGljZWFfbWFyaWFuYSIsIlBpbmFjZWFlIiwiVHJlZSIsMTMuNSwxLjEzMDMzMzc2OCwiVVNBIiwiQWxhc2thIC0gQm9uYW56YSIsNjQuNzY5LC0xNDguMjgzLCJBbmdlbGEiLDM4MiwtNC4zLDEwLjcsMi4yLDEzLjksMjEsLTI3LjEsNDguMSwxMy4yLC0xMi4xLDEzLjIsLTIxLjksMjk2LDU3LDcsNjgsMTU3LDI4LDE1Nyw0MSwyLjUxLDM2MywxDQo4ODgwLDE5OCwiQ29yZW1hX2NvbnJhZGkiLCJFcmljYWNlYWUiLCJTaHJ1YiIsMC41LC0wLjMwMTAyOTk5NiwiQ2FuYWRhIiwiUXVlYmVjIiw0Ny41MzMsLTYxLjcsIkFuZ2VsYSIsMSw0LjksNi4yLDIsOC4yLDIwLjQsLTEwLjIsMzAuNiwtMS44LDExLjgsMTUuNiwtNS40LDk3NywxMTAsNjQsMTgsMzA4LDIwMSwyMjIsMjM5LE5BLE5BLDENCjIxMjMyLDE0OSwiT3B1bnRpYV9hY2FudGhvY2FycGEiLCJDYWN0YWNlYWUiLCJTaHJ1YiIsMC43MiwtMC4xNDI2Njc1MDQsIlVTQSIsIkNhbGlmb3JuaWEiLDMzLjYzMywtMTE2LjQsIkFuZ2VsYSIsOTAwLDE2LjcsMTYuNiw0LjcsNi42LDM2LjMsMS41LDM0LjgsOS45LDIyLjYsMjUuNCw4LjksMjkwLDQ2LDIsNTcsMTI5LDIyLDUwLDEyNiwxLjAxLDQ5MiwxDQoxODgzMywxNDcsIkx1ZHdpZ2lhX2xlcHRvY2FycGEiLCJPbmFncmFjZWFlIiwiSGVyYi9TaHJ1YiIsMS41LDAuMTc2MDkxMjU5LCJVU0EiLCJTb3V0aCBDYXJvbGluYSIsMzMuMjE3LC04MS43NSwiQW5nZWxhIiw1NCwxNy41LDE0LDQuMiw2LjksMzMuNCwwLjYsMzIuOCwyNi4xLDEzLDI2LjEsOC4yLDExNjUsMTIzLDYzLDE5LDM1OCwyMjAsMzU4LDI5NywzLjM1LDE0MTUsMQ0KNDMzMSw0MiwiQmFua3NpYV9ob29rZXJpYW5hIiwiUHJvdGVhY2VhZSIsIlNocnViIiwxLjcxLDAuMjMyOTk2MTEsIkF1c3RyYWxpYSIsIldlc3Rlcm4gQXVzdHJhbGlhIiwyOS44NjcsMTE1LjI1LCJBbmdlbGEiLDc5LDIwLjEsMTMuMyw1LjEsNC42LDM1LDksMjYsMTQuNywyNiwyNi40LDE0LjcsNTIwLDExNyw1LDgzLDI5MiwyOSwzMCwyOTIsMS42Nyw3NSwtMQ0KMjgzNCwxMDksIkFuZHJvcG9nb25fZ3JlZW53YXlpIiwiUG9hY2VhZSIsIkhlcmIiLDAuMywtMC41MjI4Nzg3NDUsIlRhbnphbmlhIiwiU2VyZW5nZXRpLCBOYWFiaSBoaWxsIiwzLjIxNywzNS40ODMsIkFuZ2VsYSIsMTU1MCwxMy43LDguOCw2LjUsMS4zLDIwLjQsNi45LDEzLjUsMTQuOCwxMi4yLDE0LjgsMTEuNywxMDE5LDE5Miw5LDczLDQ1MSwzMyw0NTEsNDQsMy40OCwxMjA5LC0xDQoxMDQ2MCwxMiwiRGlja3NvbmlhX2FudGFyY3RpY2EiLCJEaWNrc29uaWFjZWFlIiwiU2hydWIiLDMsMC40NzcxMjEyNTUsIkF1c3RyYWxpYSIsIk10IEZpZWxkLCBUYXNtYW5pYSIsNDIuNjc5LDE0Ni42NjksIkFuZ2VsYSIsNzA0LDcuOSw4LjgsNC44LDMuMiwxOC4yLDAsMTguMiw0LjIsMTIsMTIsMy43LDExNTYsMTE3LDU0LDIwLDM0NywyMDAsMjAwLDMyMiwyLjk2LDY0MywtMQ0KOTU2NSwxMDEsIkN1cGFuaW9wc2lzX2FuYWNhcmRpb2lkZXMiLCJTYXBpbmRhY2VhZSIsIlRyZWUiLDgsMC45MDMwODk5ODcsIkF1c3RyYWxpYSIsIkRhcndpbiAtIEVhc3QgcG9pbnQiLDEyLjQwNiwxMzAuODIsIkFuZ2VsYSIsMTEsMjcuNSw5LjYsNi4yLDEuNSwzMy45LDE4LjUsMTUuNCwyOC4yLDI1LjIsMjkuMSwyNS4yLDE2NjMsNDI4LDEsMTA2LDEwOTEsMTAsNDI4LDEwLDQuMDcsOTU2LC0xDQo0MzMyLDQxLCJCYW5rc2lhX3RyaWN1c3BpcyIsIlByb3RlYWNlYWUiLCJTaHJ1YiIsMi45LDAuNDYyMzk3OTk4LCJBdXN0cmFsaWEiLE5BLDMwLjE2NywxMTUuMjMzLCJBbmdlbGEiLDI3NCwxOC4xLDEyLjUsNS4xLDQuMiwzMS45LDcuNywyNC4yLDEzLjEsMjEuNSwyMy44LDEzLjEsNTk3LDEzMiw2LDgzLDMzMywzNCwzOCwzMzMsMS42Nyw3NSwtMQ0KMTIwOTcsMTYsIkV1Y2FseXB0dXNfc3A1IiwiTXlydGFjZWFlIiwiVHJlZSIsMTMsMS4xMTM5NDMzNTIsIkF1c3RyYWxpYSIsIkJ1bnlpcCAtIE1lbGJvdXJuZSIsMzguMDEsMTQ1LjYyLCJBbmdlbGEiLDE2NCwxMy42LDEwLjUsNC44LDMuNywyNS43LDQuMiwyMS41LDExLjEsMTguNCwxOC40LDguOCwxMDE2LDEwNyw1MiwyMCwzMTMsMTc2LDE3NiwyNzUsMi43MSw3OTMsLTENCjQ5NTQsMTc2LCJCb3V0ZWxvdWFfZ3JhY2lsaXMiLCJQb2FjZWFlIiwiSGVyYiIsMC4yLC0wLjY5ODk3MDAwNCwiVVNBIiwiQ29sb3JhZG8iLDQwLjgxNywtMTA3Ljc4MywiQW5nZWxhIiwyMTc3LDQuMywxNi45LDMuOSw5LDI3LjcsLTE1LjUsNDMuMiwzLjQsLTcuMywxNS45LC03LjMsMzc0LDM3LDIzLDEzLDEwNiw3Nyw5Myw3NywwLjUxLDI2MSwxDQoyNTgyMywxNzQsIlJhdGliaWRhX2NvbHVtbmlmZXJhIiwiQXN0ZXJhY2VhZSIsIkhlcmIiLDEsMCwiVVNBIiwiS2Fuc2FzIiwzOS4wODMsLTk2LjU4MywiQW5nZWxhIiw0MDcsMTIsMTIuNywzLDEwLDMyLjMsLTkuMSw0MS40LDIyLjEsLTEuNCwyNC41LC0xLjQsODcyLDEzNywyMCw1MSwzNTUsNzEsMzI2LDcxLDQuMTQsMTQxNCwxDQoxMTIwNSwxMTIsIkVsYXRlcmlvc3Blcm11bV90YXBvcyIsIkV1cGhvcmJpYWNlYWUiLCJUcmVlIiwzOS42LDEuNTk3Njk1MTg2LCJNYWxheXNpYSIsTkEsMi45ODMsMTAyLjMsIkFuZ2VsYSIsMTE2LDI2LjUsOS41LDguNSwwLjUsMzIuMiwyMS4xLDExLjEsMjYuMSwyNi42LDI3LjEsMjUuOCwxOTc0LDI1NCwxMDMsMzAsNzEwLDMyNCw1MjQsNjMzLDQuNTEsMjI3MCwxDQoyNjUzMiwyMDUsIlJ1YnVzX2NoYW1hZW1vcnVzIiwiUm9zYWNlYWUiLCJTaHJ1YiIsMC4xNTgsLTAuODAxMzQyOTEzLCJGaW5sYW5kIixOQSw2MCwyNywiQW5nZWxhIiw3NSw0LjUsNy4xLDIuMiw4LjcsMjEuNSwtMTAuNSwzMiwxMC4yLC02LDE1LjgsLTYuNiw1OTcsNzgsMjYsMzQsMjE2LDkwLDE4NCwxMDYsMi44Miw1MDIsMQ0KMjE3MzAsNTgsIlBhcmFuZXVyYWNobmVfbXVlbGxlcmkiLCJQb2FjZWFlIiwiSGVyYiIsMC41LC0wLjMwMTAyOTk5NiwiQXVzdHJhbGlhIiwiS3Vub3RoIFBhZGRvY2sgLSBBbGljZSBTcHJpbmdzIiwyMy41MzMsMTMzLjc0OCwiQW5nZWxhIiw3MTMsMjAuNCwxNiw0LjgsNi4xLDM2LjMsMy4xLDMzLjIsMjYuNiwxNC4yLDI3LjUsMTIuMSwzMTAsNDEsMTEsNDIsMTIxLDQwLDEyMSw0NiwxLjAxLDYwNSwtMQ0KMTUwLDU3LCJBY2FjaWFfYW5ldXJhIiwiRmFiYWNlYWUgLSBNIiwiU2hydWIvVHJlZSIsOSwwLjk1NDI0MjUwOSwiQXVzdHJhbGlhIiwiS3Vub3RoIFBhZGRvY2sgLSBBbGljZSBTcHJpbmdzIiwyMy41MzMsMTMzLjc0OCwiQW5nZWxhIiw3MTMsMjAuNCwxNiw0LjgsNi4xLDM2LjMsMy4xLDMzLjIsMjYuNiwxNC4yLDI3LjUsMTIuMSwzMTAsNDEsMTEsNDIsMTIxLDQwLDEyMSw0NiwxLjAxLDYwNSwtMQ0KMTY0MzgsMTc5LCJJbXBhdGllbnNfY2FwZW5zaXMiLCJCYWxzYW1pbmFjZWFlIiwiSGVyYiIsMywwLjQ3NzEyMTI1NSwiUmhvZGUgSXNsYW5kIiwiVVNBIiw0MS42NjcsLTcxLjI1LCJBbmdlbGEiLDQ0LDEwLjEsMTAsMi45LDguNCwyNy40LC02LjUsMzMuOSwxLjgsMTguMywyMC45LC0wLjgsMTE3NiwxMTcsODEsMTEsMzMyLDI1NiwyNjIsMzExLDMuMzksMTA0NCwxDQoyNjk4MywyMDgsIlNhbGl4X2xhcHBvbnVtIiwiU2FsaWNhY2VhZSIsIlNocnViIiwxLjA1LDAuMDIxMTg5Mjk5LCJOb3J3YXkiLE5BLDYxLjYsNy41LCJBbmdlbGEiLDE1MjAsLTIuMSw2LjIsMi44LDUuNCwxMCwtMTEuNywyMS43LC00LjksMC4xLDUuMiwtOC41LDE0MTgsMTU5LDcxLDIzLDQ0NiwyNDQsMzM3LDM5OSwxLjAxLDQ1LDENCjEyNjE5LDcsIkZlc3R1Y2Ffbm92YWUtemVhbGFuZGlhZSIsIlBvYWNlYWUiLCJIZXJiIiwwLjUsLTAuMzAxMDI5OTk2LCJOZXcgWmVhbGFuZCIsTkEsNDMuMDMzLDE3MS43NSwiQW5nZWxhIiw1ODcsOS4xLDksNC42LDMuNiwxOS4xLC0wLjMsMTkuNCw4LjgsMTIuMiwxMy42LDQuMywyNDIxLDI0NywxMzEsMTUsNzA0LDUwMiw1MzcsNTgwLDEuNDYsNDEsLTENCjMzNTgsMTM1LCJBcmRpc2lhX3RlbmVyYSIsIk15cnNpbmFjZWFlIiwiVHJlZSIsMTEsMS4wNDEzOTI2ODUsIkNoaW5hIixOQSwyMS45NiwxMDEuMiwiQW5nZWxhIiw3NDksMjEsMTEuOSw1LjMsMy4zLDMwLjUsOC40LDIyLjEsMjMuOSwxNy41LDI0LjMsMTYuMSwxNDc2LDI3NSwyMCw3NCw3NTMsNjcsNjE2LDczLDQuMDQsMTQzNSwxDQoxMjU0MSwxOTksIkZhZ3VzX3N5bHZhdGljYSIsIkZhZ2FjZWFlIiwiVHJlZSIsMzksMS41OTEwNjQ2MDcsIkdlcm1hbnkiLCJCYXJ2YXJpYSIsNDkuODY3LDEwLjQ1LCJBbmdlbGEiLDQxNSw4LDguOSwzLjIsNi43LDIyLjksLTQuMSwyNywxNi41LDAuNSwxNi41LC0wLjcsNjkyLDgwLDQzLDE4LDIxOCwxNDMsMjE4LDE1NSwzLjU3LDgyNywxDQoxNzc4MywxNTAsIkxhcnJlYV90cmlkZW50YXRhIiwiWnlnb3BoeWxsYWNlYWUiLCJTaHJ1YiIsMS45NCwwLjI4NzgwMTczLE5BLE5BLDM0LjU1LC0xMTYuODgzLCJBbmdlbGEiLDkyMCwxNi42LDE2LjYsNC41LDcuMSwzNi45LDAuNCwzNi41LDkuMywyMy4zLDI1LjksOC4xLDIxMiwzNCwyLDYwLDk3LDE2LDE5LDk1LDEuMjYsMjc5LDENCjEzNDI3LDIwNCwiR2VudGlhbmFfY2FtcGVzdHJpcyIsIkdlbnRpYW5hY2VhZSIsIkhlcmIiLDEyLjQsMS4wOTM0MjE2ODUsIlN3ZWRlbiIsIlNvZGVybWFubGFuZCIsNTkuMzMzLDE2Ljg1LCJBbmdlbGEiLDMzLDYuMiw3LjMsMi41LDcuMywyMS43LC02LjYsMjguMywxNC43LDAuMiwxNS45LC0yLjgsNTY0LDcwLDI3LDI5LDE5Nyw5MCwxODgsMTE2LDMuMDcsNjE1LDENCjc4NjcsNiwiQ2hpb25vY2hsb2FfcGFsbGVucyIsIlBvYWNlYWUiLCJIZXJiIiwxLjUsMC4xNzYwOTEyNTksIk5ldyBaZWFsYW5kIiwiQ2FudGVyYnVyeSIsNDMuNTMzLDE3MS41NSwiQW5nZWxhIiwxMDcwLDcuOCw5LjQsNC41LDMuOSwxOC41LC0yLDIwLjUsNS41LDEyLjUsMTIuNiwyLjYsMTIxMSwxMjAsNzEsMTIsMzM5LDI1OSwyNjYsMzI2LDEuMjYsMzAsLTENCjEyMzAzLDE3NywiRXVwaG9yYmlhX2NoYXJhY2lhcyIsIkV1cGhvcmJpYWNlYWUiLE5BLDEsMCwiU3BhaW4iLE5BLDQxLjQxNywyLjEsIkFuZ2VsYSIsMzE0LDE1LjMsNywzLjEsNS4zLDI3LjIsNS4yLDIyLDE2LjMsMjIuMiwyMi40LDguOSw2NTYsODUsMzAsMjYsMjIxLDEzMiwxNjAsMTM0LDIuMjYsODI2LDENCjE1Mzc3LDExMCwiSGVsaWNvbmlhX2FjdW1pbmF0YSIsIkhlbGljb25pYWNlYWUiLCJIZXJiIiwwLjc1LC0wLjEyNDkzODczNywiQnJhemlsIixOQSwyLjUsLTYwLCJBbmdlbGEiLDExMSwyNyw4LjYsOC4zLDAuNCwzMi41LDIyLjIsMTAuMywyNi42LDI3LjQsMjcuNiwyNi41LDIzMTksMjk5LDEwOCwzMSw4MDMsMzUyLDQxNSw3MTgsNC4yNiwxNjkyLC0xDQoxNzMyOSwxNzAsIkp1bmlwZXJ1c192aXJnaW5pYW5hIiwiQ3VwcmVzc2FjZWFlIiwiU2hydWIiLDQsMC42MDIwNTk5OTEsIlVTQSIsTkEsMzguNzUsLTk2LjU4MywiQW5nZWxhIiw0MDcsMTIuMSwxMi44LDMsOS45LDMyLjQsLTksNDEuNCwyMi4xLC0xLjMsMjQuNSwtMS4zLDg1OSwxMzMsMjAsNDksMzM4LDczLDMxMCw3MywyLjc2LDExMjcsMQ0KMTExODgsNzYsIkVsYWVvY2FycHVzX3B5cmlmb3JtaXMiLCJFbGFlb2NhcnBhY2VhZSIsIlRyZWUiLDE1LDEuMTc2MDkxMjU5LCJGaWppIiwiYWJuZ2F1IiwxNy40NzIsMTc4Ljg0NywiTGF1cmEiLDQxLDI1LDYuMyw2LjQsMS4yLDMwLjEsMjAuNCw5LjcsMjYuNCwyMy4zLDI2LjQsMjMuMywyNjE2LDM3OSwxMDAsNDEsMTAxMiwzMzUsMTAxMiwzMzUsNC41LDE4MDAsLTENCjIzNTcsOTEsIkFsbG90ZXJvcHNpc19zZW1pYWxhdGEiLCJQb2FjZWFlIiwiSGVyYiIsMC41NSwtMC4yNTk2MzczMTEsIkF1c3RyYWxpYSIsIkNhcGUgWW9yayIsMTQuOTY3LDE0My41ODMsIkFuZ2VsYSIsODUsMjYsMTIuNCw2LjIsMi4zLDM1LjEsMTUuMSwyMCwyNy44LDIzLjQsMjguNCwyMi43LDExMTcsMjkwLDIsMTEzLDc2Nyw5LDUwMSwxMyw0LjAzLDgxMSwtMQ0KMzAxNDEsNjgsIlRhcGVpbm9zcGVybWFfZ3JhbmRlIiwiTXlyc2luYWNlYWUiLCJTaHJ1Yi9UcmVlIiw2LDAuNzc4MTUxMjUsIkZpamkiLCJhYmtuZ2F1IiwxNy44NDYsMTc4LjcwNiwiTGF1cmEiLDgsMjQuOSw2LjMsNi40LDEuMywzMC4xLDIwLjMsOS44LDI2LjUsMjMuMywyNi41LDIzLjIsMjczMSwzOTQsMTA5LDM5LDEwMTEsMzY1LDEwMTEsMzcxLDQuNTEsMTg2NCwtMQ0KMjEyMzAsMzIsIk9wdW50aWFfYXVyYW50aWFjYSIsIkNhY3RhY2VhZSIsIlNocnViIiwwLjUsLTAuMzAxMDI5OTk2LE5BLE5BLDMzLjIsMjYuMzY3LCJBbmdlbGEiLDYxNCwxNi43LDEzLjYsNS45LDMuMSwyNy40LDQuNiwyMi44LDIwLjYsMTMuMSwyMC42LDEyLjUsNjMwLDczLDI4LDI3LDE5Nyw5OCwxOTcsMTA0LDEuNzYsOTMzLC0xDQoyOTA3NSwyMTAsIlNvcmJ1c19hdWN1cGFyaWEiLCJSb3NhY2VhZSIsIlRyZWUiLDE1LDEuMTc2MDkxMjU5LCJTd2VlZGVuIiwiVW1lYSIsNjMuODE3LDIwLjI2NywiQW5nZWxhIiwyMSwyLjcsOC41LDIuNCw4LjksMjAuNywtMTMuOCwzNC41LDEzLjEsLTQuMiwxNC41LC04LjYsNTcyLDcwLDMyLDI2LDE4OSw5OSwxNjgsMTI4LDIuNzksNDE0LDENCjEzNDI2LDE5NywiR2VudGlhbmFfY3J1Y2lhdGEiLCJHZW50aWFuYWNlYWUiLCJIZXJiIiwwLjI0NiwtMC42MDkwNjQ4OTMsIlN3aXR6ZXJsYW5kIixOQSw0Ni41LDcsIkFuZ2VsYSIsMTYwOCwzLjUsNy41LDMsNiwxNi41LC03LjksMjQuNCwtNC4xLDQuNiwxMS4xLC00LjEsMTU1NSwxNTUsMTEyLDEwLDQzOCwzNTksMzg1LDQzOCwzLjI2LDY5MCwxDQo=" download="Plant_height.csv">Download Plant_height.csv</a>
<a href="data:text/csv;base64,UmljaG5lc3MsQ29wcGVyLE9yaWVudGF0aW9uDQo2OCxOb25lLHZlcnRpY2FsDQo2NCxOb25lLHZlcnRpY2FsDQo2NCxOb25lLHZlcnRpY2FsDQo2MyxOb25lLHZlcnRpY2FsDQo2OSxOb25lLHZlcnRpY2FsDQo2MyxOb25lLHZlcnRpY2FsDQo3MCxOb25lLHZlcnRpY2FsDQo2OCxOb25lLHZlcnRpY2FsDQo2OCxOb25lLHZlcnRpY2FsDQo2MixOb25lLHZlcnRpY2FsDQo3MCxOb25lLEhvcml6b250YWwNCjcxLE5vbmUsSG9yaXpvbnRhbA0KODEsTm9uZSxIb3Jpem9udGFsDQo2NyxOb25lLEhvcml6b250YWwNCjcxLE5vbmUsSG9yaXpvbnRhbA0KNjUsTm9uZSxIb3Jpem9udGFsDQo2NSxOb25lLEhvcml6b250YWwNCjY3LE5vbmUsSG9yaXpvbnRhbA0KNzQsTm9uZSxIb3Jpem9udGFsDQo2NSxOb25lLEhvcml6b250YWwNCjYwLExvdyx2ZXJ0aWNhbA0KNTgsTG93LHZlcnRpY2FsDQo1NyxMb3csdmVydGljYWwNCjYyLExvdyx2ZXJ0aWNhbA0KNjAsTG93LHZlcnRpY2FsDQo1OSxMb3csdmVydGljYWwNCjU4LExvdyx2ZXJ0aWNhbA0KNTgsTG93LHZlcnRpY2FsDQo1OSxMb3csdmVydGljYWwNCjYxLExvdyx2ZXJ0aWNhbA0KNTcsTG93LEhvcml6b250YWwNCjU0LExvdyxIb3Jpem9udGFsDQo1NCxMb3csSG9yaXpvbnRhbA0KNTcsTG93LEhvcml6b250YWwNCjU0LExvdyxIb3Jpem9udGFsDQo1NyxMb3csSG9yaXpvbnRhbA0KNTYsTG93LEhvcml6b250YWwNCjU2LExvdyxIb3Jpem9udGFsDQo1NyxMb3csSG9yaXpvbnRhbA0KNTYsTG93LEhvcml6b250YWwNCjM5LEhpZ2gsdmVydGljYWwNCjQyLEhpZ2gsdmVydGljYWwNCjQxLEhpZ2gsdmVydGljYWwNCjQ3LEhpZ2gsdmVydGljYWwNCjQ4LEhpZ2gsdmVydGljYWwNCjQ2LEhpZ2gsdmVydGljYWwNCjQ2LEhpZ2gsdmVydGljYWwNCjQ0LEhpZ2gsdmVydGljYWwNCjQ2LEhpZ2gsdmVydGljYWwNCjM4LEhpZ2gsdmVydGljYWwNCjU2LEhpZ2gsSG9yaXpvbnRhbA0KNTMsSGlnaCxIb3Jpem9udGFsDQo1NixIaWdoLEhvcml6b250YWwNCjU2LEhpZ2gsSG9yaXpvbnRhbA0KNTYsSGlnaCxIb3Jpem9udGFsDQo1NixIaWdoLEhvcml6b250YWwNCjU0LEhpZ2gsSG9yaXpvbnRhbA0KNTYsSGlnaCxIb3Jpem9udGFsDQo1NixIaWdoLEhvcml6b250YWwNCjU1LEhpZ2gsSG9yaXpvbnRhbA0K" download="sessile.csv">Download sessile.csv</a>
<a href="data:text/csv;base64,VGVtcGVyYXR1cmUsRGF5cw0KMTUsMzcNCjE1LDQzDQoxNSw0NQ0KMTUsNTQNCjE1LDU2DQoxNSw2NQ0KMTUsNjINCjE1LDczDQoxNSw3NA0KMTUsNzUNCjIwLDMwDQoyMCwzMQ0KMjAsMzQNCjIwLDM1DQoyMCwzNQ0KMjAsNDcNCjIwLDUzDQoyMCw1NA0KMjAsNjMNCjIwLDY0DQoyNSwyMQ0KMjUsMjMNCjI1LDQ4DQoyNSw1Mg0KMjUsNTINCjI1LDU0DQoyNSw1NA0KMjUsNjENCjI1LDYyDQoyNSw2NQ0KMzAsMTMNCjMwLDE2DQozMCwxOQ0KMzAsMTENCjMwLDEyDQozMCwxOA0KMzAsMjENCjMwLDIzDQozMCwyOQ0KMzAsMzkNCg==" download="turtles.csv">Download turtles.csv</a>
<a href="data:text/csv;base64,VHJlYXRtZW50LEFyZWEsVm9sZXMKQ29udHJvbCxhcmVhMSw4CkNvbnRyb2wsYXJlYTEsMTYKQ29udHJvbCxhcmVhMSwxMQpDb250cm9sLGFyZWExLDE1CkNvbnRyb2wsYXJlYTEsOQpDb250cm9sLGFyZWExLDEwCkNvbnRyb2wsYXJlYTEsMTEKQ29udHJvbCxhcmVhMSw5CkNvbnRyb2wsYXJlYTEsOApDb250cm9sLGFyZWExLDE0CkNvbnRyb2wsYXJlYTIsMTYKQ29udHJvbCxhcmVhMiwyMwpDb250cm9sLGFyZWEyLDExCkNvbnRyb2wsYXJlYTIsOApDb250cm9sLGFyZWEyLDExCkNvbnRyb2wsYXJlYTIsOApDb250cm9sLGFyZWEyLDgKQ29udHJvbCxhcmVhMiwxMgpDb250cm9sLGFyZWEyLDkKQ29udHJvbCxhcmVhMiwxNQpSZW1vdmFsLGFyZWEzLDMzClJlbW92YWwsYXJlYTMsMjYKUmVtb3ZhbCxhcmVhMywzNApSZW1vdmFsLGFyZWEzLDM0ClJlbW92YWwsYXJlYTMsMjYKUmVtb3ZhbCxhcmVhMyw0MQpSZW1vdmFsLGFyZWEzLDIwClJlbW92YWwsYXJlYTMsMTcKUmVtb3ZhbCxhcmVhMywyMApSZW1vdmFsLGFyZWEzLDI2ClJlbW92YWwsYXJlYTQsMjkKUmVtb3ZhbCxhcmVhNCwxOApSZW1vdmFsLGFyZWE0LDE2ClJlbW92YWwsYXJlYTQsMTgKUmVtb3ZhbCxhcmVhNCwxMwpSZW1vdmFsLGFyZWE0LDI0ClJlbW92YWwsYXJlYTQsOQpSZW1vdmFsLGFyZWE0LDIxClJlbW92YWwsYXJlYTQsMzMKUmVtb3ZhbCxhcmVhNCwxMgo=" download="mink.csv">Download mink.csv</a>
<a href="data:text/csv;base64,IiIsIkRpc3QiLCJUaW1lIiwiQ3JhYlByZXMiCiIxIiwwLDUsMAoiMiIsMCw1LDEKIjMiLDAsNSwxCiI0IiwwLDUsMAoiNSIsMCw1LDAKIjYiLDIsNSwwCiI3IiwyLDUsMAoiOCIsMiw1LDEKIjkiLDIsNSwwCiIxMCIsMiw1LDAKIjExIiwxMCw1LDEKIjEyIiwxMCw1LDAKIjEzIiwxMCw1LDAKIjE0IiwxMCw1LDEKIjE1IiwxMCw1LDAKIjE2IiwwLDEwLDAKIjE3IiwwLDEwLDAKIjE4IiwwLDEwLDEKIjE5IiwwLDEwLDEKIjIwIiwwLDEwLDEKIjIxIiwyLDEwLDAKIjIyIiwyLDEwLDAKIjIzIiwyLDEwLDEKIjI0IiwyLDEwLDAKIjI1IiwyLDEwLDAKIjI2IiwxMCwxMCwxCiIyNyIsMTAsMTAsMAoiMjgiLDEwLDEwLDEKIjI5IiwxMCwxMCwxCiIzMCIsMTAsMTAsMAoiMzEiLDAsNSwwCiIzMiIsMCw1LDAKIjMzIiwwLDUsMAoiMzQiLDAsNSwwCiIzNSIsMCw1LDAKIjM2IiwyLDUsMAoiMzciLDIsNSwwCiIzOCIsMiw1LDAKIjM5IiwyLDUsMAoiNDAiLDIsNSwwCiI0MSIsMTAsNSwwCiI0MiIsMTAsNSwwCiI0MyIsMTAsNSwwCiI0NCIsMTAsNSwwCiI0NSIsMTAsNSwwCiI0NiIsMCwxMCwwCiI0NyIsMCwxMCwwCiI0OCIsMCwxMCwwCiI0OSIsMCwxMCwwCiI1MCIsMCwxMCwxCiI1MSIsMiwxMCwxCiI1MiIsMiwxMCwxCiI1MyIsMTAsMTAsMAoiNTQiLDEwLDEwLDEKIjU1IiwxMCwxMCwwCiI1NiIsMTAsMTAsMQoiNTciLDEwLDEwLDEK" download="crabs.csv">Download crabs.csv</a>
<a href="data:text/csv;base64,LE1vZGlmaWNhdGlvbixFc3R1YXJ5LFNpdGUsSHlkcm9pZCxUb3RhbCxTY2hpem9wb3JlbGxhLmVycmF0YQoxLE1vZGlmaWVkLEpBSywxLDAsNDQsMTUKMixNb2RpZmllZCxKQUssMSwwLDQyLDgKMyxNb2RpZmllZCxKQUssMiwwLDMyLDkKNCxNb2RpZmllZCxKQUssMiwwLDQ0LDE0CjUsTW9kaWZpZWQsSkFLLDMsMSw0Miw2CjYsTW9kaWZpZWQsSkFLLDMsMSw0OCwxMgo3LE1vZGlmaWVkLEpBSyw0LDAsNDUsMjgKOCxNb2RpZmllZCxKQUssNCwwLDM0LDEKOSxQcmlzdGluZSxKRVIsMSw3LDI5LDAKMTAsUHJpc3RpbmUsSkVSLDEsNSw1MSwwCjExLFByaXN0aW5lLEpFUiwyLDIsMTIsMAoxMixQcmlzdGluZSxKRVIsMiwwLDI5LDAKMTMsUHJpc3RpbmUsSkVSLDMsMCw0NCwwCjE0LFByaXN0aW5lLEpFUiwzLDAsNDEsMAoxNSxQcmlzdGluZSxKRVIsNCwzLDM3LDAKMTYsUHJpc3RpbmUsSkVSLDQsMyw0MiwwCjE3LE1vZGlmaWVkLEJPVCwxLDAsNDksMAoxOCxNb2RpZmllZCxCT1QsMSwwLDQ5LDAKMTksTW9kaWZpZWQsQk9ULDIsMCw0MSwxMgoyMCxNb2RpZmllZCxCT1QsMiwwLDQ1LDcKMjEsTW9kaWZpZWQsQk9ULDMsMCw0OSwwCjIyLE1vZGlmaWVkLEJPVCwzLDAsNDksMAoyMyxNb2RpZmllZCxCT1QsNCwwLDQ5LDAKMjQsTW9kaWZpZWQsQk9ULDQsMCw0OSwwCjI1LFByaXN0aW5lLFdBRywxLDAsOSwwCjI2LFByaXN0aW5lLFdBRywxLDAsMTUsMAoyNyxQcmlzdGluZSxXQUcsMiwxLDMwLDAKMjgsUHJpc3RpbmUsV0FHLDIsMSwyNiwwCjI5LFByaXN0aW5lLFdBRywzLDIsMjAsMAozMCxQcmlzdGluZSxXQUcsMywxLDksMAozMSxQcmlzdGluZSxXQUcsNCwyLDIsMAozMixQcmlzdGluZSxXQUcsNCwyLDQsMAozMyxNb2RpZmllZCxLRU0sMSwwLDI4LDAKMzQsTW9kaWZpZWQsS0VNLDEsMCw0MywwCjM1LE1vZGlmaWVkLEtFTSwyLDAsMjcsMAozNixNb2RpZmllZCxLRU0sMiwwLDIyLDAKMzcsTW9kaWZpZWQsS0VNLDQsMCw0NSwwCjM4LE1vZGlmaWVkLEtFTSw0LDAsMzcsMAozOSxQcmlzdGluZSxIQUssMSwwLDIwLDAKNDAsUHJpc3RpbmUsSEFLLDEsMCwzMiwwCjQxLFByaXN0aW5lLEhBSywyLDAsMzEsNgo0MixQcmlzdGluZSxIQUssMiwwLDM1LDQKNDMsUHJpc3RpbmUsSEFLLDMsMSwzNiw0CjQ0LFByaXN0aW5lLEhBSywzLDAsNDYsMjAKNDUsUHJpc3RpbmUsSEFLLDQsMCw4LDAKNDYsUHJpc3RpbmUsSEFLLDQsMCw5LDAKNDcsUHJpc3RpbmUsQ0xZLDEsMCwyOSw0CjQ4LFByaXN0aW5lLENMWSwxLDMsMzMsNgo0OSxQcmlzdGluZSxDTFksMiwxLDI1LDMKNTAsUHJpc3RpbmUsQ0xZLDIsMCwyOCwxCjUxLFByaXN0aW5lLENMWSwzLDEsNDAsMAo1MixQcmlzdGluZSxDTFksMywyLDI0LDAKNTMsUHJpc3RpbmUsQ0xZLDQsMiwxOSwwCjU0LFByaXN0aW5lLENMWSw0LDIsMzMsMQo=" download="estuaries.csv">Download estuaries.csv</a>
<hr />
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">library</span>(gvlma)</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="fu">library</span>(Hmisc)</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="fu">library</span>(corrplot)</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="fu">library</span>(mvabund)</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="fu">library</span> (lme4)</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="fu">library</span>(mgcv)</span></code></pre></div>
<p>Previously, we saw that correlations look at the association between
two variables. The measure of this association is called the Pearson
coefficient (parametric). It is the covariance of the two variables
divided by the product of their standard deviation. It is scaled between
1 (for a perfect positive correlation) to -1 (for a perfect negative
correlation), 0 would be complete randomness. Using parametric
assumption this coefficient divided by its standard error gives a value
that follow a t-distribution. Squared, we obtain the amount of variation
in <span class="math inline">\(y\)</span> explained by <span
class="math inline">\(x\)</span>. However such results do not allow any
explanation of the effect of <span class="math inline">\(x\)</span> on
<span class="math inline">\(y\)</span>, indeed <span
class="math inline">\(x\)</span> could act on <span
class="math inline">\(y\)</span> in various way that are not always
direct, all we can say from the correlation is that these two variables
are linked somehow, to really explain and measure effects of <span
class="math inline">\(x\)</span> on <span
class="math inline">\(y\)</span> we need to use regression method.
That’s the reason why<code>lm</code> is used in <code>abline()</code> or
<code>geom_smooth</code> in order to represent correlation.</p>
<div id="linear-regression" class="section level1">
<h1>Linear regression</h1>
<div id="one-predictor" class="section level2">
<h2>One predictor</h2>
<p>Regression is somehow different from correlation because it try to
put variables into equation and thus explain relationship between them.
In <strong>Model I regression</strong> (indeed we have Model II when two
variables in the regression equation are random , i.e. no controlled by
the researcher), it is used to predict a quantitative outcome of a
dependent variable <span class="math inline">\(y\)</span> on the basis
of one single independent predictor variable <span
class="math inline">\(x\)</span>. The goal is to build a mathematical
model (or formula) that defines <span class="math inline">\(y\)</span>
as a function of the <span class="math inline">\(x\)</span> variable,
and that’s why linear regression are also called linear modelling
(previously added to our scatter plot using <code>abline</code> or
<code>geom_smooth</code>.</p>
<p>Note that the <code>linear</code> in linear model does not imply a
straight-line relationship but rather that the response is a linear
(additive) combination of the effects of the explanatory variables.
However, because we tend to start by fitting the simplest relationship,
many linear models are represented by straight lines.</p>
<p>Once, we built a statistically significant model, it’s possible to
use it for predicting future outcome on the basis of new <span
class="math inline">\(x\)</span> values.</p>
<div id="formula-and-basics" class="section level3">
<h3>Formula and basics</h3>
<p>The formula of linear regression can be written as follows: <span
class="math display">\[ y = \beta_0 + \beta_1*x + \epsilon \]</span></p>
<p>where:</p>
<ul>
<li><p><span class="math inline">\(\beta_0\)</span> and <span
class="math inline">\(\beta_1\)</span> are known as the regression
<strong>beta coefficients</strong> or <strong>parameters</strong>:</p>
<ul>
<li><span class="math inline">\(\beta_0\)</span> is the
<strong>intercept</strong> of the regression line; that is the predicted
value when <em>x = 0</em>.</li>
<li><span class="math inline">\(\beta1\)</span> is the
<strong>slope</strong> of the regression line.</li>
</ul></li>
<li><p><span class="math inline">\(\epsilon\)</span> is the
<strong>error term</strong> (also known as the <strong>residual
errors</strong>).The error term is drawn from a statistical distribution
that captures the random variability in the response. In standard linear
regression this is assumed to be a normal (Gaussian)
distribution.</p></li>
</ul>
<p>The figure below illustrates the linear regression model, where:</p>
<ul>
<li>the best-fit regression line is in blue</li>
<li>the intercept (<span class="math inline">\(\beta_0\)</span>) and the
slope (<span class="math inline">\(\beta_1\)</span>) are shown in
green</li>
<li>the error terms (<span class="math inline">\(\epsilon\)</span>) are
represented by vertical red lines</li>
</ul>
<p><img src="illustrations/linear-regression.png" width="50%" style="display: block; margin: auto;" /></p>
<p>From the figure above, it can be seen that not all the data points
fall exactly on the fitted regression line. Some of the points are above
the blue curve and some are below it; overall, the residual errors
(<span class="math inline">\(\epsilon\)</span>) have approximately mean
zero.</p>
<p><strong>TERMINOLOGY ALERT</strong></p>
<p>The sum of the squares of the residual errors are called the
<strong>Residual Sum of Squares</strong> or <strong>RSS</strong>.</p>
<p>The average variation of points around the fitted regression line is
called the <strong>Residual Standard Error (RSE)</strong>. This is one
the metrics used to evaluate the overall quality of the fitted
regression model. The lower the RSE, the better it is.</p>
<p>Since the mean error term is zero, the outcome variable y can be
approximately estimated as follow:</p>
<p><span class="math display">\[y= \beta_0+\beta_1*x\]</span></p>
<p>Mathematically, the beta coefficients (<span
class="math inline">\(\beta_0\)</span> and <span
class="math inline">\(\beta_1\)</span>) are determined so that the
<strong>RSS</strong> is as minimal as possible. This method of
determining the beta coefficients is technically called <strong>least
squares</strong> regression or <strong>ordinary least squares</strong>
(OLS) regression.</p>
<p>Once, the beta coefficients are calculated, a <em>t</em>-test is
performed to check whether or not these coefficients are significantly
different from zero. A non-zero beta coefficients means that there is a
significant relationship between the predictors (<span
class="math inline">\(x\)</span>) and the outcome variable (<span
class="math inline">\(y\)</span>).</p>
</div>
<div id="running-the-analysis" class="section level3">
<h3>Running the analysis</h3>
<p>So, the goal in linear regression is obtain the best estimates for
the model coefficients (<span class="math inline">\(\beta_0\)</span> and
<span class="math inline">\(\beta_1\)</span>). In R you can fit linear
models using the function <code>lm</code>.</p>
<p>In this example, we will use a data set on plant heights around the
world <code>Plant_height.csv</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>Plant_height <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="at">file =</span> <span class="st">&quot;Data/Plant_height.csv&quot;</span>, <span class="at">header =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<p>The main argument to <code>lm</code> is the model formula
<code>y ~ x</code>, where the response variable is on the left of the
tilde symbol (<code>~</code>) and the explanatory variable is on the
right. <code>lm</code> also has an optional data argument that lets you
specify a data frame from which the variables will be taken.</p>
<p>To test whether plant height is associated with temperature , we
would model height as the dependent variable (in this case we are using
the log of plant height) and temperature as the predictor variable <span
class="math inline">\(loght = \beta_0 + \beta_1 * temp\)</span>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>mod1_plant<span class="ot">&lt;-</span> <span class="fu">lm</span>(loght <span class="sc">~</span> temp, <span class="at">data =</span> Plant_height)</span></code></pre></div>
<p>We can extracted the beta coefficients of this linear model
using:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>mod1_plant<span class="sc">$</span>coefficients</span></code></pre></div>
<pre><code>## (Intercept)        temp 
## -0.22566451  0.04241362</code></pre>
<p>The estimates for the coefficients give you the slope(<span
class="math inline">\(\beta_0\)</span>) and intercept (<span
class="math inline">\(\beta_1\)</span>) for the <code>temp</code>
variable. In this example, the regression equation for (log) plant
height as a function of temperature is:</p>
<p><span class="math inline">\(log(plantheight) = -0.22566 + 0.04241 *
temp + \epsilon\)</span></p>
<ul>
<li><p>the intercept (<span class="math inline">\(\beta_0\)</span>) is
<span class="math inline">\(-0.22566\)</span>. It can be interpreted as
the predicted (log) plant heigth when temperature is equal to zero.
Regression through the origin is when you force the intercept of a
regression model to equal zero. It’s also known as fitting a model
without an intercept (e.g., the intercept-free linear model <span
class="math inline">\(y = \beta_1*x\)</span> is equivalent to the model
<span class="math inline">\(y = \beta_0 + \beta_1*x\)</span> with <span
class="math inline">\(\beta_0=0\)</span>). Knowing that the <strong>true
relationship</strong> between your predictors and the expected value of
your dependent variable has to pass through the origin would be a good
reason for forcing the estimated relationship through the origin if you
knew for certain what the true relationship was (be careful very rare
cases where it is justified to remove the intercept).</p></li>
<li><p>the regression beta coefficient for the variable
<code>temp</code> (<span class="math inline">\(\beta1\)</span>), also
known as the slope, is <span class="math inline">\(0.04241\)</span>.
This means that, for one unit of <span
class="math inline">\(temp\)</span>, we can expect an increase of <span
class="math inline">\(0.04241\)</span> units in <span
class="math inline">\(log(plantheight)\)</span>.</p></li>
</ul>
<p>Calling <code>summary</code> on a model object produces a lot of
useful information but one of the main things to look out for are the
t-statistics and p-values for each coefficient. These test the null
hypothesis that the true value for the coefficient is 0.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="fu">summary</span>(mod1_plant)</span></code></pre></div>
<pre><code>## 
## Call:
## lm(formula = loght ~ temp, data = Plant_height)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -1.97903 -0.42804 -0.00918  0.43200  1.79893 
## 
## Coefficients:
##              Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept) -0.225665   0.103776  -2.175    0.031 *  
## temp         0.042414   0.005593   7.583 1.87e-12 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 0.6848 on 176 degrees of freedom
## Multiple R-squared:  0.2463, Adjusted R-squared:  0.242 
## F-statistic:  57.5 on 1 and 176 DF,  p-value: 1.868e-12</code></pre>
<p>Looking at only the p-values, this simple model seems to fit the data
very well. For the intercept we usually don’t care if it is zero or not,
but for the other coefficient (the slope), a value significantly
differing from zero indicates that there is an association between that
explanatory variable and the response. In this example, an increase in
temperature is associated with an increase in plant height. But
<code>lm</code> output tells us much more. The summary outputs shows 6
components, including</p>
<ul>
<li><p><strong>Call</strong> shows the function call used to compute the
regression model.</p></li>
<li><p><strong>Residuals</strong> provide a quick view of the
distribution of the residuals, which by definition have a mean zero.
Therefore, the median should not be far from zero, and the minimum and
maximum should be roughly equal in absolute value.</p></li>
<li><p><strong>Coefficients</strong> shows the regression beta
coefficients and their statistical significance. Predictor variables,
that are significantly associated to the outcome variable, are marked by
stars.</p></li>
<li><p><strong>Residual standard error</strong> (RSE),
<strong>R-squared</strong> (R2) and the <strong>F-statistic</strong> are
metrics that are used to check how well the model fits to our
data.</p></li>
</ul>
<div id="coefficients-significance" class="section level4">
<h4>Coefficients significance</h4>
<p>The coefficients table, in the model statistical summary, shows:</p>
<ul>
<li><p>the estimates of the <strong>beta coefficients</strong></p></li>
<li><p>the <strong>standard errors</strong> (SE), which defines the
accuracy of beta coefficients. For a given beta coefficient, the SE
reflects how the coefficient varies under repeated sampling. It can be
used to compute the confidence intervals and the t-statistic.</p></li>
<li><p>the <strong><em>t</em>-statistic</strong> and the associated
<strong><em>p</em>-value</strong>, which defines the statistical
significance of the beta coefficients.</p></li>
</ul>
<p><strong>1 - t-statistic and p-values</strong></p>
<p>For a given predictor, the t-statistic (and its associated
<em>p</em>-value) tests whether or not there is a statistically
significant relationship between a given predictor and the outcome
variable, that is whether or not the beta coefficient of the predictor
is significantly different from zero.</p>
<p>The statistical hypotheses are as follow:</p>
<ul>
<li>Null hypothesis (H<sub>0</sub>): the coefficients are equal to zero
(i.e., no relationship between x and y)</li>
<li>Alternative Hypothesis (H<sub>1</sub>): the coefficients are not
equal to zero (i.e., there is some relationship between <span
class="math inline">\(x\)</span> and <span
class="math inline">\(y\)</span>)</li>
</ul>
<p>Mathematically, for a given beta coefficient (<span
class="math inline">\(\beta\)</span>), the <em>t</em>-test is computed
as <span class="math inline">\(t = (\beta - 0)/SE(\beta)\)</span>, where
<span class="math inline">\(SE(\beta)\)</span> is the SE of the
coefficient <span class="math inline">\(\beta\)</span>. Simply said, the
t-statistic measures the number of standard deviations that <span
class="math inline">\(\beta\)</span> is away from 0. Thus a large
<em>t</em>-statistic will produce a small p-value (=different).</p>
<p>The higher the <em>t</em>-statistic (and the lower the p-value), the
more significant the predictor. The symbols to the right (***) visually
specifies the level of significance. The line below the table shows the
definition of these symbols; one star means p &lt; 0.05, two stars p
&lt; 0.01, three stars p &lt; 0.001. So the more stars beside the
variable’s p-value, the more significant is the variable.</p>
<p>A statistically significant coefficient indicates that there is an
association between the predictor (<span
class="math inline">\(x\)</span>) and the outcome (<span
class="math inline">\(y\)</span>) variable.</p>
<p>The <em>t</em>-statistic is a very useful guide for whether or not to
include a predictor in a model. High t-statistics (which go with low
p-values near 0) indicate that a predictor should be retained in a
model, while very low <em>t</em>-statistics indicate a predictor could
be dropped (Bruce &amp; Bruce 2017).</p>
<p><strong>2 - Standard errors and confidence intervals</strong></p>
<p>The standard error measures the variability/accuracy of the beta
coefficients. It can be used to compute the confidence intervals of the
coefficients.</p>
<p>For example, the 95% confidence interval for the coefficient <span
class="math inline">\(\beta1\)</span> is defined as <span
class="math inline">\(\beta1 +/- 2*SE(\beta1)\)</span>, where:</p>
<p>the lower limits of <span class="math inline">\(\beta_1 = \beta_1 -
2*SE(\beta_1) = 0.042414 - 2*(0.005593) = 0.031228\)</span></p>
<p>the upper limits of <span class="math inline">\(\beta1 = \beta1 +
2*SE(\beta1) = 0.042414 + 2*(0.005593) = 0.053600\)</span></p>
<p>That is, there is approximately a 95% chance that the interval
[0.031, 0.053] will contain the true value of <span
class="math inline">\(\beta1\)</span>. Similarly the 95% confidence
interval for <span class="math inline">\(\beta0\)</span> can be computed
as <span class="math inline">\(\beta1 +/- 2*SE(\beta0)\)</span>.</p>
<p>To get this information, either you calculate by hands or you simply
call:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="fu">confint</span>(mod1_plant)</span></code></pre></div>
<pre><code>##                   2.5 %      97.5 %
## (Intercept) -0.43047074 -0.02085828
## temp         0.03137508  0.05345215</code></pre>
</div>
<div id="model-accuracy" class="section level4">
<h4>Model accuracy</h4>
<p>Once you identified that, at least, one predictor variable is
significantly associated the outcome, you should continue the diagnostic
by checking how well the model fits the data. This process is also
referred to as the <em>goodness-of-fit</em></p>
<p>The overall quality of the linear regression fit can be assessed
using the following three parameters, displayed in the model
summary:</p>
<ol style="list-style-type: decimal">
<li><strong>The Residual Standard Error (RSE)</strong></li>
</ol>
<p>The <strong>RSE</strong> (also known as the model sigma) is the
<strong>residual variation</strong>, representing the average variation
of the observations points around the fitted regression line. This is
the <strong>standard deviation of residual errors</strong>.</p>
<p>RSE provides an absolute measure of patterns in the <strong>data that
can’t be explained by the model</strong>. When comparing two models, the
model with the small RSE is a good indication that this model fits the
best the data.</p>
<p>Dividing the RSE by the average value of the outcome variable will
give you the prediction error rate, which should be as small as
possible.</p>
<p>In our example, RSE = <code>0.6848</code>, meaning that the observed
Petal.width values deviate from the true regression line by
approximately <code>0.6848</code> units in average.</p>
<p>Whether or not an RSE of <code>0.6848</code> units is an acceptable
prediction error is subjective and depends on the problem context.</p>
<p>However, we can calculate the percentage error. In our data set, the
mean value of <code>loght</code> is <span
class="math inline">\(0.458267\)</span>, and so the percentage error is
<span class="math inline">\(0.6848/0.458267\times100=149%\)</span>.
There is indeed a high variation.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="fu">sigma</span>(mod1_plant)<span class="sc">*</span><span class="dv">100</span><span class="sc">/</span><span class="fu">mean</span>(Plant_height<span class="sc">$</span>loght)</span></code></pre></div>
<pre><code>## [1] 149.4371</code></pre>
<ol start="2" style="list-style-type: decimal">
<li><strong>The R-squared (<span
class="math inline">\(R^2\)</span>)</strong></li>
</ol>
<p>The <strong>R-squared</strong> <span
class="math inline">\(R^2\)</span> ranges from 0 to 1 and represents the
proportion of information (i.e. variance) in the response that is
explained by the explanatory variable(s). The <strong>adjusted <span
class="math inline">\(R^2\)</span></strong> adjusts <span
class="math inline">\(R^2\)</span> with the <strong>degrees of
freedom</strong>.</p>
<p>The <span class="math inline">\(R^2\)</span> measures, how well the
model fits the data. For a simple linear regression, <span
class="math inline">\(R^2\)</span> is the square of the <strong>Pearson
correlation coefficient</strong>.</p>
<p>A high value of <span class="math inline">\(R^2\)</span> is a good
indication. However, as the value of <span
class="math inline">\(R^2\)</span> tends to increase when more
predictors are added in the model, such as in <strong>multiple linear
regression mode</strong>l, you should mainly consider the adjusted <span
class="math inline">\(R^2\)</span>, which is a penalized <span
class="math inline">\(R^2\)</span> for a higher number of
predictors.</p>
<ul>
<li><p>An (adjusted) <span class="math inline">\(R^2\)</span> that is
close to 1 indicates that a large proportion of the variability in the
outcome has been explained by the regression model.</p></li>
<li><p>A number near 0 indicates that the regression model did not
explain much of the variability in the outcome.</p></li>
</ul>
<ol start="3" style="list-style-type: decimal">
<li><strong>F-statistic</strong></li>
</ol>
<p>The <strong>F-statistic</strong> gives the overall significance of
the model. It assess whether <strong>at least one predictor variable has
a non-zero coefficient</strong>.</p>
<p>In a simple linear regression, this test is not really interesting
since it just duplicates the information in given by the
<em>t</em>-test, available in the coefficient table. In fact, the
<em>F</em>-test is identical to the square of the t-test: <span
class="math inline">\(57.5 = (7.583)^2\)</span>. That would be true in
any model with 1 degree of freedom.</p>
<p>The F-statistic becomes <strong>more important</strong> once we start
<strong>using multiple predictors</strong> as in multiple linear
regression.</p>
<p>A large F-statistic will corresponds to a statistically significant
<em>p</em>-value (p &lt; 0.05). In our example, the F-statistic equal
<span class="math inline">\(57.5\)</span> producing a p-value of <span
class="math inline">\(1.868e-12\)</span>, which is highly significant
(***).</p>
</div>
<div id="other-useful-functions" class="section level4">
<h4>Other useful functions</h4>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="fu">fitted</span>(mod1_plant) <span class="co"># predicted values</span></span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a><span class="fu">residuals</span>(mod1_plant) <span class="co"># residuals</span></span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a><span class="fu">anova</span>(mod1_plant) <span class="co"># anova table</span></span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a><span class="fu">vcov</span>(mod1_plant) <span class="co"># covariance matrix for model parameters</span></span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a><span class="fu">influence</span>(mod1_plant) <span class="co"># regression diagnostics</span></span></code></pre></div>
</div>
</div>
<div id="model-assumption" class="section level3">
<h3>Model assumption</h3>
<p><strong>Linearity</strong> There is no point trying to fit a staight
line to data that are curved! Curvilinear relationships produce U-shaped
patterns in plots of the residuals vs the fitted values. Using the plot
function on a model object provides a series of four graphical model
diagnostics, the first of which is a plot of residuals versus fitted
values.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="fu">plot</span>(mod1_plant, <span class="at">which =</span> <span class="dv">1</span>)</span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-20-1.png" width="672" /></p>
<p>The absence of strong pattern in the above plot indicates the
assumption of linearity is valid. If there is strong pattern, one
potential solution is to log-transform the response. Note in the above
example plant height had already been log-transformed. Try to run the
same diagnostic on the untransformed data, variable
<code>height</code>.</p>
<p>Click <a href="https://gallery.shinyapps.io/slr_diag/">here</a> to
see a nice interactive app that shows you what patterns of residuals you
would expect with curved relationships</p>
<p><strong>Constant variance</strong> An even spread of data around the
regression line is desirable. If the plot of residuals versus fitted
values is fan-shaped the assumption of constant variance (aka
homogeneity of variance) is violated. A log-transformation of the
response variable may fix this problem, but if it doesn’t the best
solution is to use a different error distribution in a generalised
linear model framework (GLM).</p>
<p><strong>Normality</strong> Checks of whether the data are normally
distributed are usually performed by either plotting a histogram of the
residuals or via a quantile plot where the residuals are plotted against
the values expected from a normal distribution (the second of the
figures obtained by <code>plot(mod_plant)</code>. If the points in the
quantile plot lie mostly on the line, the residuals are normally
distributed. Violations of normality can be fixed via transformations or
by using a different error-distribution in a GLM. Note, however, that
linear regression is reasonably robust against violations of
normality.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>)) <span class="co"># This code put two plots in the same window</span></span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a><span class="fu">hist</span>(mod1_plant<span class="sc">$</span>residuals) <span class="co"># Histogram of residuals</span></span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a><span class="fu">plot</span>(mod1_plant, <span class="at">which =</span> <span class="dv">2</span>) <span class="co"># Quantile plot</span></span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-21-1.png" width="672" /></p>
<p><strong>Independence</strong> The observations of the response should
be independent of each other. Non-independent observations are those
that are in some way associated with each other beyond that which is
explained by the predictor variable(s). For instance, samples collected
from the same site, or repeatedly from the same object, may be more
alike due to some additional factor other than the measured explanatory
variable. Ensuring independence is an issue of experimental and sampling
design and we usually know if the data are independent or not in advance
of our analysis.</p>
<p>There are a variety of measures for dealing with non-independence.
These include ensuring all important predictors are in the model;
averaging across nested observations; or using a mixed-model.</p>
<p>Based on Peña &amp; Slate (2006), the four assumptions in linear
regression are normality, heteroscedasticity, and linearity, and what
the authors refer to as uncorrelatedness. The <code>gvlma( )</code>
function in the <code>gvlma</code> package, performs a global validation
of linear model assumptions as well separate evaluations of skewness,
kurtosis, and heteroscedasticity.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>gvmodel <span class="ot">&lt;-</span> <span class="fu">gvlma</span>(mod1_plant)</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a><span class="fu">summary</span>(gvmodel)</span></code></pre></div>
<pre><code>## 
## Call:
## lm(formula = loght ~ temp, data = Plant_height)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -1.97903 -0.42804 -0.00918  0.43200  1.79893 
## 
## Coefficients:
##              Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept) -0.225665   0.103776  -2.175    0.031 *  
## temp         0.042414   0.005593   7.583 1.87e-12 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 0.6848 on 176 degrees of freedom
## Multiple R-squared:  0.2463, Adjusted R-squared:  0.242 
## F-statistic:  57.5 on 1 and 176 DF,  p-value: 1.868e-12
## 
## 
## ASSESSMENT OF THE LINEAR MODEL ASSUMPTIONS
## USING THE GLOBAL TEST ON 4 DEGREES-OF-FREEDOM:
## Level of Significance =  0.05 
## 
## Call:
##  gvlma(x = mod1_plant) 
## 
##                      Value p-value                Decision
## Global Stat        0.47538  0.9759 Assumptions acceptable.
## Skewness           0.29268  0.5885 Assumptions acceptable.
## Kurtosis           0.11168  0.7382 Assumptions acceptable.
## Link Function      0.02790  0.8673 Assumptions acceptable.
## Heteroscedasticity 0.04311  0.8355 Assumptions acceptable.</code></pre>
</div>
</div>
<div id="two-or-more-predictors" class="section level2">
<h2>Two (or more) predictors</h2>
<p><strong>Multiple linear regression</strong> is just an
<strong>extension of simple linear regression</strong> used to predict
an outcome variable (<span class="math inline">\(y\)</span>) on the
basis of multiple distinct predictor variables (<span
class="math inline">\(x\)</span>).</p>
<p>With three predictor variables (<span
class="math inline">\(x\)</span>), the prediction of <span
class="math inline">\(y\)</span> is expressed by the following
equation:</p>
<p><span class="math display">\[y = \beta_0 + \beta_1*x_1 + \beta_2*x_2
+ \beta_3*x_3\]</span> The <span class="math inline">\(\beta\)</span>
values measure the association between the predictor variable and the
outcome. “<span class="math inline">\(\beta_j\)</span>” can be
interpreted as the average effect on <span
class="math inline">\(y\)</span> of a one unit increase in <span
class="math inline">\(x_j\)</span>, holding all other predictors
fixed.</p>
<p><span class="math inline">\(loght = \beta_0 + \beta_1 * temp +
\beta_2 * alt + \beta_3 * rain\)</span></p>
<p>or</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>mod2_plant<span class="ot">&lt;-</span> <span class="fu">lm</span>(loght <span class="sc">~</span> temp <span class="sc">+</span> alt <span class="sc">+</span> rain, <span class="at">data =</span> Plant_height)</span></code></pre></div>
<p>A common problem that arises in multiple linear regression is the
<strong>multi-collinearity</strong>. This is the situation when two or
more predictors are highly linearly related between them.
Multicollinearitiy has important effects on the fit of the model:</p>
<ul>
<li><p>It reduces the precision of the estimates. As a consequence,
signs of fitted coefficients may be reversed and valuable predictors may
appear as non significant.</p></li>
<li><p>It is difficult to determine how each of the highly related
predictors affects the response, since one masks the other. This may
result in numerical instabilities.</p></li>
</ul>
<p>An approach is to detect multicollinearity is to compute a
correlation matrix between the predictors as we learned earlier</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>plant_predictor<span class="ot">&lt;-</span><span class="fu">data.frame</span>(Plant_height<span class="sc">$</span>temp,Plant_height<span class="sc">$</span>alt,Plant_height<span class="sc">$</span>rain)</span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a>corr<span class="ot">&lt;-</span><span class="fu">cor</span>(plant_predictor)</span>
<span id="cb18-3"><a href="#cb18-3" tabindex="-1"></a>p.val<span class="ot">&lt;-</span><span class="fu">rcorr</span>(<span class="fu">as.matrix</span>(plant_predictor))<span class="sc">$</span>P</span>
<span id="cb18-4"><a href="#cb18-4" tabindex="-1"></a><span class="fu">corrplot</span>(corr,<span class="at">type=</span><span class="st">&#39;upper&#39;</span>,<span class="at">method=</span><span class="st">&#39;color&#39;</span>, <span class="at">addCoef.col =</span> <span class="st">&quot;black&quot;</span>,  <span class="at">p.mat=</span><span class="fu">as.matrix</span>(p.val), <span class="at">sig.level =</span> <span class="fl">0.05</span>,<span class="at">diag=</span>F)</span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-24-1.png" width="672" /></p>
<p>Here we can see there is a significant correlation between the
predictors. A better approach is to compute the <strong>Variance
Inflation Factor</strong> (VIF) of each coefficient <span
class="math inline">\(\beta_j\)</span>. This is measure of how linearly
dependent is <span class="math inline">\(X_j\)</span> with the rest of
predictors:</p>
<p><span
class="math display">\[\text{VIF}(\beta_j)=\frac{1}{1-R^2_{X_j|X_{-j}}}\]</span>
where <span class="math inline">\(R^2_{X_j|X_{-j}}\)</span> is the <span
class="math inline">\(R^2\)</span> from a regression of <span
class="math inline">\(X_j\)</span> into the remaining predictors. The
next rule of thumb gives direct insight into which predictors are
multicollinear:</p>
<ul>
<li><strong>VIF close to 1</strong>: absence of multicollinearity.</li>
<li><strong>VIF larger than 5 or 10</strong>: multicolinearity
<strong>problematic</strong>.</li>
</ul>
<p>Others considered <span
class="math inline">\(\sqrt{VIF}&gt;2\)</span> as critical limit to
consider multicollinearity.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="co"># Evaluate Collinearity</span></span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a>car<span class="sc">::</span><span class="fu">vif</span>(mod2_plant) <span class="co"># variance inflation factors</span></span></code></pre></div>
<pre><code>##     temp      alt     rain 
## 1.590787 1.140424 1.438287</code></pre>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a><span class="fu">sqrt</span>(car<span class="sc">::</span><span class="fu">vif</span>(mod2_plant)) <span class="sc">&gt;</span> <span class="dv">2</span> <span class="co"># problem?</span></span></code></pre></div>
<pre><code>##  temp   alt  rain 
## FALSE FALSE FALSE</code></pre>
<p>None of the predictors seem problematic here.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a><span class="fu">summary</span>(mod2_plant)</span></code></pre></div>
<pre><code>## 
## Call:
## lm(formula = loght ~ temp + alt + rain, data = Plant_height)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -1.83849 -0.49760 -0.00025  0.39435  1.59110 
## 
## Coefficients:
##               Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept) -3.553e-01  1.264e-01  -2.810 0.005514 ** 
## temp         2.906e-02  6.793e-03   4.278  3.1e-05 ***
## alt          3.701e-05  1.045e-04   0.354 0.723519    
## rain         2.457e-04  6.226e-05   3.947 0.000115 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 0.6595 on 174 degrees of freedom
## Multiple R-squared:  0.309,  Adjusted R-squared:  0.2971 
## F-statistic: 25.93 on 3 and 174 DF,  p-value: 6.461e-14</code></pre>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">2</span>))</span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a><span class="fu">plot</span>(mod2_plant)</span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-26-1.png" width="672" /></p>
</div>
<div id="model-selection" class="section level2">
<h2>Model selection</h2>
<p>If you aim is to predict you are looking for the best model. An
information criterion balances the fitness of a model with the number of
predictors employed. Hence, it determines objectively the best model as
the one that minimizes the information criterion. Two common criteria
are the <strong>Bayesian Information Criterion (BIC)</strong> and the
<strong>Akaike Information Criterion (AIC)</strong>.</p>
<p><span class="math inline">\(AIC(model)=-2*logLik(model) + npar(model)
* 2\)</span></p>
<p><span class="math inline">\(BIC(model)=-2*logLik(model) + npar(model)
* log(n)\)</span></p>
<p>where <span class="math inline">\(Lik(model)\)</span> is the
likelihood of the model (how well the model fits the data) and <span
class="math inline">\(npar(model)\)</span> is the number of parameters
of the model, <span class="math inline">\(k+2\)</span> in the case of a
multiple linear regression model with <span
class="math inline">\(k\)</span> predictors.The AIC replaces <span
class="math inline">\(log(n)\)</span> by <span
class="math inline">\(2\)</span>, so it penalizes less complex
models.This is one of the reasons why BIC is preferred by some
practitioners for model comparison. Also, because is consistent in
selecting the true model: if enough data is provided, the BIC is
guaranteed to select the data-generating model among a list of candidate
models.</p>
<p>Both are based on a <strong>balance between the model fitness and its
complexity</strong>.Both BIC and AIC can be computed in <code>R</code>
through the functions <code>BIC</code> and <code>AIC</code>. They take a
model as the input. The lower the better with a rule of thumb = 2.</p>
<p>Note: Do you remember about <code>sigma</code> (the Residual Standard
Error, RSE)? We previously used it to calculate a pecrcentage error.
Well, AIC and BIC used the log likelihood of the model obtain using
<code>logLik (model)</code>. You can recalculate this logLik using:
<code>sum(log(dnorm(x = y, mean = predict(model), sd = sigma(model))))</code>
which illustrate the connection between <code>sigma</code>and
information criterion.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a>mod3_plant<span class="ot">&lt;-</span><span class="fu">lm</span>(<span class="at">formula =</span> loght <span class="sc">~</span> temp <span class="sc">+</span> rain, <span class="at">data =</span> Plant_height)</span>
<span id="cb26-2"><a href="#cb26-2" tabindex="-1"></a><span class="fu">BIC</span>(mod1_plant); <span class="fu">BIC</span>(mod2_plant); <span class="fu">BIC</span>(mod3_plant)</span></code></pre></div>
<pre><code>## [1] 383.8952</code></pre>
<pre><code>## [1] 378.7943</code></pre>
<pre><code>## [1] 373.7409</code></pre>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a><span class="fu">AIC</span>(mod1_plant); <span class="fu">AIC</span>(mod2_plant); <span class="fu">AIC</span>(mod3_plant)</span></code></pre></div>
<pre><code>## [1] 374.3499</code></pre>
<pre><code>## [1] 362.8854</code></pre>
<pre><code>## [1] 361.0138</code></pre>
<p>However, selecting a subset of predictor variables from a larger set
(e.g., stepwise selection) remains a controversial topic. You can
perform stepwise selection (forward, backward, both) using the
<code>stepAIC()</code> and <code>stepBIC()</code> function from the
<code>MASS</code> package. <code>stepAIC()</code> performs stepwise
model selection by exact AIC.</p>
<blockquote>
<p><em>Source: Alistair Poore, Andrew Letten, Gordana Popovic</em></p>
</blockquote>
</div>
</div>
<div id="anova" class="section level1">
<h1>ANOVA</h1>
<p>Analysis of variance (ANOVA) is one of the most frequently used
techniques in the biological and environmental sciences. ANOVA is used
to contrast a continuous dependent variable <span
class="math inline">\(y\)</span> across levels of one or more
categorical independent variables <span
class="math inline">\(x\)</span>. The independent variables are termed
the <strong>factor</strong> or ****treatment, and the various categories
within that treatment are termed the <strong>levels</strong>. We will
start with the simplest design - those ANOVA with a single factor.</p>
<p>Where an independent samples t-test would be used for comparison of
group means across two levels, ANOVA is used for the comparison of &gt;2
group means, or when there are more than two or more predictor
variables. The logic of this test is essentially the same as the t-test
- it compares variation between groups to variation within groups to
determine whether the observed differences are due to chance or not.</p>
<div id="one-way-anova" class="section level2">
<h2>One-way ANOVA</h2>
<p>Also called single factor ANOVA.</p>
<p>For example, to compare the hatching times of turtle eggs incubated
at four different temperatures (15°C, 20°C, 25°C and 30°C); hatching
time is the continuous response variable and temperature is the
categorical predictor variable with with four levels. The null
hypothesis would be that mean hatching time is equal for all
temperatures.</p>
<p><span class="math inline">\(H_0:
\mu_{15}=\mu_{20}=\mu_{25}=\mu_{30}\)</span></p>
<p>Note that an <strong>ANOVA is a linear model</strong>, just like
linear regression except that the predictor variables are categorical
rather than continuous.</p>
<p><span class="math inline">\(y_{ij}=\mu + \beta_i +
\epsilon_{ij}\)</span></p>
<p>where <span class="math inline">\(\mu\)</span> is the overall mean
and <span class="math inline">\(\beta_i\)</span> is the effect of the
<span class="math inline">\(i^{th}\)</span> group.</p>
<p>It is the same as a multiple linear regression with a predictor
variable for each level of the categorical variable (each coded as a
dummy variable). For the question of whether hatching time of turtles
differs between four incubation tempeatures, we must fit four parameters
to describe the mean response of each temperature (rather than just a
single intercept and single slope in a simple linear regression). For
this example, our linear model equation will have this form:</p>
<p><span
class="math inline">\(HatchingTime=\mu+\beta_1.Temp_{15}+\beta_1.Temp_{20}+\beta_1.Temp_{25}+\beta_1.Temp_{30}+\epsilon\)</span></p>
<p>ANOVA partitions the total variance into a component that can be
explained by the predictor variable (among levels of the treatment), and
a component that cannot be explained (within levels, the residual
variance). The test statistic, F, is the ratio of these two sources of
variation.</p>
<p><span
class="math inline">\(F=\frac{MS_{among}}{MS_{within}}\)</span></p>
<p>where MS are the mean squares, a measure of variation. The
probability of obtaining the observed value of F is calculated from the
known probability distribution of F, with two degrees of freedom (one
for the numerator = the number of levels -1) and one for the denominator
(number of replicates per level - 1 x number of levels).</p>
<div id="running-the-analysis-1" class="section level3">
<h3>Running the analysis</h3>
<p>The data should be formatted such that the individual replicates are
rows and the variables are separate in columns. Include a column for the
dependent variable, <span class="math inline">\(y\)</span>, and a
corresponding column for the categorical variable, <span
class="math inline">\(x\)</span>. Download the sample data set for the
turtle hatching example, <code>turtles.csv</code>, import into R and
check that temperature variable is a factor with the <code>str</code>
function.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" tabindex="-1"></a>turtles <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="at">file =</span> <span class="st">&quot;data/turtles.csv&quot;</span>, <span class="at">header =</span> <span class="cn">TRUE</span>)</span>
<span id="cb34-2"><a href="#cb34-2" tabindex="-1"></a><span class="fu">str</span>(turtles)</span></code></pre></div>
<pre><code>## &#39;data.frame&#39;:    40 obs. of  2 variables:
##  $ Temperature: int  15 15 15 15 15 15 15 15 15 15 ...
##  $ Days       : int  37 43 45 54 56 65 62 73 74 75 ...</code></pre>
<p>In this case, because we have numbers for the four levels of the
Temperature treatment, we need to change that variable to become a
factor rather than an integer.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" tabindex="-1"></a>turtles<span class="sc">$</span>Temperature <span class="ot">&lt;-</span> <span class="fu">factor</span>(turtles<span class="sc">$</span>Temperature)</span>
<span id="cb36-2"><a href="#cb36-2" tabindex="-1"></a><span class="fu">boxplot</span>(Days <span class="sc">~</span> Temperature, <span class="at">data =</span> turtles, <span class="at">ylab =</span> <span class="st">&quot;Hatching time (days)&quot;</span>, <span class="at">xlab =</span> <span class="st">&quot;Temperature (C)&quot;</span>)</span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-29-1.png" width="672" /></p>
<p>Now, we can run the analysis of variance contrasting hatching time
(days) across temperatures using the function <code>aov</code>. The
arguments of the function are simply a formula statement,
<code>y~x</code>, with the response variable to the left of the
<code>~</code>, the predictor variable to the right, and some code to
specify which data frame holds those variables.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" tabindex="-1"></a>turtles.aov <span class="ot">&lt;-</span> <span class="fu">aov</span>(Days <span class="sc">~</span> Temperature, <span class="at">data =</span> turtles)</span>
<span id="cb37-2"><a href="#cb37-2" tabindex="-1"></a><span class="fu">summary</span>(turtles.aov)</span></code></pre></div>
<pre><code>##             Df Sum Sq Mean Sq F value   Pr(&gt;F)    
## Temperature  3   8025  2675.2   15.98 9.08e-07 ***
## Residuals   36   6027   167.4                     
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>Check but the same can be produced by passing a <code>lm</code> in
<code>anova()</code>. An ANOVA is simply another way to summarize the
results of a <code>lm</code>, especially useful in case of categorical
variables.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" tabindex="-1"></a>turtles.lm <span class="ot">&lt;-</span> <span class="fu">lm</span>(Days <span class="sc">~</span> Temperature, <span class="at">data =</span> turtles)</span>
<span id="cb39-2"><a href="#cb39-2" tabindex="-1"></a><span class="fu">anova</span>(turtles.lm) </span></code></pre></div>
<pre><code>## Analysis of Variance Table
## 
## Response: Days
##             Df Sum Sq Mean Sq F value    Pr(&gt;F)    
## Temperature  3 8025.5 2675.16  15.978 9.082e-07 ***
## Residuals   36 6027.3  167.42                      
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>The summary output of an ANOVA object is a table with the degrees of
freedom (Df), sums of squares (Sum Sq), mean squares (Mean Sq) for the
predictor variable (i.e., variation among levels of your treatment) and
for the Residuals (i.e., varation within the levels). The test
statistic, <span class="math inline">\(F\)</span> value and its
associated p-value (Pr(&gt;F)) are also presented.</p>
<p>First check the degrees of freedom. The factor Df = the number of
levels of your factor - 1. The residual <span class="math inline">\(Df =
a(n-1)\)</span>, where <span class="math inline">\(a\)</span> = the
number of levels of your factor and <span
class="math inline">\(n\)</span> = sample size (replicates per
level).</p>
<p>The sums of squares and mean squares are measures of variation. The
<span class="math inline">\(F\)</span> statistic is the ratio of <span
class="math inline">\(MS_{among}\)</span> and <span
class="math inline">\(MS_{within}\)</span> and the p-value is the
probability of the observed <span class="math inline">\(F\)</span> value
from the <span class="math inline">\(F\)</span> distribution (with the
given degrees of freedom).</p>
<p>The main thing to look at in the ANOVA table is whether your
predictor variable had a significant effect on your response variable.
In this example, the probability that all four incubation temperatures
are equal is &lt;0.001. This is very unlikely and much less than 0.05.
We would conclude that there is a difference in hatching times between
the temperatures.</p>
<p>In the <code>lm</code> output , you get a bit more information.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" tabindex="-1"></a><span class="fu">summary</span>(turtles.lm)</span></code></pre></div>
<pre><code>## 
## Call:
## lm(formula = Days ~ Temperature, data = turtles)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -28.200  -9.225   1.650   9.025  19.400 
## 
## Coefficients:
##               Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)     58.400      4.092  14.273  &lt; 2e-16 ***
## Temperature20  -13.800      5.787  -2.385   0.0225 *  
## Temperature25   -9.200      5.787  -1.590   0.1206    
## Temperature30  -38.300      5.787  -6.619 1.04e-07 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 12.94 on 36 degrees of freedom
## Multiple R-squared:  0.5711, Adjusted R-squared:  0.5354 
## F-statistic: 15.98 on 3 and 36 DF,  p-value: 9.082e-07</code></pre>
<p>The output for the standard ANOVA table is down the bottom and above
it you get the actual parameter estimates from the linear model (the
<span class="math inline">\(\beta_1\)</span>, <span
class="math inline">\(\beta_2\)</span>, etc. from above). In this
example, turtles at 15°C hatched after 58.4 days, on average (the
intercept in the model). The other parameter estimates are differences
between each level of temperature and the intercept. For example, at
20°C they were 13.8 days faster (i.e., the mean for 20°C = 58.4-13.8 =
44.6 days).</p>
<p>If you detect any significant differences in the ANOVA, we are then
interested in knowing exactly which groups differ from one another, and
which do not. Remember that a significant p value in the test you just
ran would reject the null hypothesis the means of the dependent variable
were the same across all groups, but not identify which were different
from each other. To see a comparison between each mean and each other
mean, we can use a Tukey’s post-hoc test.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" tabindex="-1"></a><span class="fu">TukeyHSD</span>(turtles.aov)</span></code></pre></div>
<pre><code>##   Tukey multiple comparisons of means
##     95% family-wise confidence level
## 
## Fit: aov(formula = Days ~ Temperature, data = turtles)
## 
## $Temperature
##        diff       lwr        upr     p adj
## 20-15 -13.8 -29.38469   1.784689 0.0982694
## 25-15  -9.2 -24.78469   6.384689 0.3969971
## 30-15 -38.3 -53.88469 -22.715311 0.0000006
## 25-20   4.6 -10.98469  20.184689 0.8562615
## 30-20 -24.5 -40.08469  -8.915311 0.0008384
## 30-25 -29.1 -44.68469 -13.515311 0.0000785</code></pre>
</div>
<div id="assumptions" class="section level3">
<h3>Assumptions</h3>
<p>As for any linear models, The important assumptions of ANOVA are
independence, homogeneity of variance and normality. Many advocate a
qualitative evaluation of the normality and homogeneity of variance
assumptions, by examining the patterns of variation in the residuals,
rather than a formal test. Linear models in general are quite ‘robust’
for violating these assumptions (heterogeneity and normality), within
reason of course.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">3</span>)) <span class="co"># This code put two plots in the same window</span></span>
<span id="cb45-2"><a href="#cb45-2" tabindex="-1"></a><span class="fu">hist</span>(turtles.aov<span class="sc">$</span>residuals)</span>
<span id="cb45-3"><a href="#cb45-3" tabindex="-1"></a><span class="fu">plot</span>(turtles.aov, <span class="at">which =</span> <span class="dv">2</span>)</span>
<span id="cb45-4"><a href="#cb45-4" tabindex="-1"></a><span class="fu">plot</span>(turtles.aov, <span class="at">which =</span> <span class="dv">1</span>)</span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-34-1.png" width="672" /></p>
<p>Violations of normality and homogeneity of variance can be fixed via
transformations or by using a different error-distribution in a
generalised linear model (GLM).</p>
</div>
</div>
<div id="factorial-anova" class="section level2">
<h2>Factorial ANOVA</h2>
<p>Consider an example where a researcher is testing the effects of
metal contamination on the number of species found in sessile marine
invertebrates (sponges, bryozoans and sea squirts etc.). They would like
to know whether copper reduces species richness, but also know that the
richness of invertebrates can depend on whether the substrate is
vertical or horizontal. Consequently, they ran an experiment where
species richness was recorded in replicate samples in each of the six
combinations of copper enrichment (“None”,“Low”,“High”) and orientation
(“Vertical”,“Horizontal”). The experimental design in termed
<strong>factorial</strong> because <strong>all levels of one treatment
are represented in all levels of the other treatments (also termed
orthogonal)</strong>.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" tabindex="-1"></a>sessile <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="at">file =</span> <span class="st">&quot;data/sessile.csv&quot;</span>, <span class="at">header =</span> <span class="cn">TRUE</span>)</span>
<span id="cb46-2"><a href="#cb46-2" tabindex="-1"></a><span class="co"># check your predictors with `str`</span></span>
<span id="cb46-3"><a href="#cb46-3" tabindex="-1"></a><span class="fu">boxplot</span>(Richness <span class="sc">~</span> Copper <span class="sc">*</span> Orientation, <span class="at">data =</span> sessile, <span class="at">names =</span> <span class="fu">c</span>(<span class="st">&quot;High.H&quot;</span>, <span class="st">&quot;Low.H&quot;</span>, <span class="st">&quot;None.H&quot;</span>, <span class="st">&quot;High.V&quot;</span>, <span class="st">&quot;Low.V&quot;</span>, <span class="st">&quot;None.V&quot;</span>), <span class="at">ylab =</span> <span class="st">&quot;Species richness&quot;</span>, <span class="at">xlab =</span> <span class="st">&quot;Copper/Orientation&quot;</span>, <span class="at">ylim =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">80</span>))</span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-35-1.png" width="672" /></p>
<p>The factorial ANOVA will test:</p>
<ul>
<li>whether there are any differences in richness among the three levels
of copper enrichment</li>
<li>whether there are any differences in richness among the two levels
of substrate orientation</li>
<li>whether there is any interaction between copper and orientation</li>
</ul>
<p>You have three null hypotheses:</p>
<ul>
<li><p>there is no difference between the means for each level of
copper, Ho: <span
class="math inline">\(\mu_{none}=\mu_{low}=\mu_{high}\)</span></p></li>
<li><p>there is no difference between the means for each level of
orientation, Ho: <span
class="math inline">\(\mu_{vertical}=\mu_{horizontal}\)</span></p></li>
<li><p>there is no interaction between the factors</p></li>
</ul>
<p>This is far better than running two separate single factor ANOVAs
that contrast copper effects for each level of orientation because you
have more statistical power (higher degrees of freedom) for the tests of
interest, and you get a formal test of the interaction between factors
which is often scientifically interesting.</p>
<p><span class="math inline">\(y_{ij}=\mu + \alpha_i + \beta_j +
(\alpha\beta)_{ij} + \epsilon_{ijk}\)</span></p>
<p>where <span class="math inline">\(\mu\)</span> is the overall mean,
<span class="math inline">\(\alpha_i\)</span> is the effect of the
i<sup>th</sup> group of the first factor, <span
class="math inline">\(\beta_j\)</span> is the effect of the
j<sup>th</sup> group of the second factor, and <span
class="math inline">\(\alpha\beta\)</span> the interaction. Athough we
have two factors, and an interaction effect, this requires fitting more
than 3 parameters in our model because we have 3 levels of Factor A
(Copper) and 2 levels of Factor B (Orientation).</p>
<p>With two factors, ANOVA partitions the total variance into a
component that can be explained by the first predictor variable (among
levels of the treatment A), a component that can be explained by the
second predictor variable (among levels of the treatment B), a component
that can be explained by the interaction, and a component that cannot be
explained (within levels, the residual variance). The test statistic,
<span class="math inline">\(F\)</span>, is calculated three times to
test each of the null hypotheses. For two fixed factors, the <span
class="math inline">\(F\)</span> ratios are:</p>
<p><span class="math inline">\(F=\frac{MS_{A}}{MS_{within}}\)</span></p>
<p><span class="math inline">\(F=\frac{MS_{B}}{MS_{within}}\)</span></p>
<p><span
class="math inline">\(F=\frac{MS_{AB}}{MS_{within}}\)</span></p>
<p>where MS are the mean squares, a measure of variation. The
probability of obtaining the observed value of <span
class="math inline">\(F\)</span> is calculated from the known
probability distribution of <span class="math inline">\(F\)</span>, with
two degrees of freedom (one for the numerator = the number of levels -1)
and one for the denominator. Note that these <span
class="math inline">\(F\)</span> ratios will change if any factors are
random (see below for the distinction between fixed and random
factors).</p>
<div id="running-the-analysis-2" class="section level3">
<h3>Running the analysis</h3>
<p>For this two factor design, we use:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" tabindex="-1"></a>sessile.aov <span class="ot">&lt;-</span> <span class="fu">aov</span>(Richness <span class="sc">~</span> Copper <span class="sc">*</span> Orientation, <span class="at">data =</span> sessile)</span>
<span id="cb47-2"><a href="#cb47-2" tabindex="-1"></a><span class="co"># same as:</span></span>
<span id="cb47-3"><a href="#cb47-3" tabindex="-1"></a>sessile.aov <span class="ot">&lt;-</span> <span class="fu">aov</span>(Richness <span class="sc">~</span> Copper <span class="sc">+</span> Orientation <span class="sc">+</span> Copper<span class="sc">:</span>Orientation, <span class="at">data =</span> sessile)</span>
<span id="cb47-4"><a href="#cb47-4" tabindex="-1"></a><span class="fu">summary</span>(sessile.aov)</span></code></pre></div>
<pre><code>##                    Df Sum Sq Mean Sq F value   Pr(&gt;F)    
## Copper              2   3330  1665.0  192.53  &lt; 2e-16 ***
## Orientation         1    240   240.0   27.75 2.46e-06 ***
## Copper:Orientation  2    571   285.4   33.00 4.34e-10 ***
## Residuals          54    467     8.6                     
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" tabindex="-1"></a><span class="co"># same as:</span></span>
<span id="cb49-2"><a href="#cb49-2" tabindex="-1"></a>sessile.lm <span class="ot">&lt;-</span> <span class="fu">lm</span>(Richness <span class="sc">~</span> Copper <span class="sc">*</span> Orientation, <span class="at">data =</span> sessile)</span>
<span id="cb49-3"><a href="#cb49-3" tabindex="-1"></a><span class="fu">anova</span>(sessile.lm)</span></code></pre></div>
<pre><code>## Analysis of Variance Table
## 
## Response: Richness
##                    Df Sum Sq Mean Sq F value    Pr(&gt;F)    
## Copper              2 3330.0 1665.02 192.529 &lt; 2.2e-16 ***
## Orientation         1  240.0  240.00  27.752 2.464e-06 ***
## Copper:Orientation  2  570.7  285.35  32.995 4.341e-10 ***
## Residuals          54  467.0    8.65                      
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>Check that you have the correct degrees of freedom. For a two factor
design with fixed factors they are:</p>
<ul>
<li>Factor A: a - 1 (where a = number of levels of Factor A)</li>
<li>Factor B: b - 1 (where b = number of levels of Factor B)</li>
<li>Interaction (AB): (a-1)(b-1)</li>
<li>Residual: ab(n -1) (where n = sample size)</li>
</ul>
<p>The sums of squares and mean squares are measures of variation. There
are three F statistics, corresponding to a test of each of the main
effects and one for the interaction. The p-values are the probabilities
of the observed F values from the F distribution (with the given degrees
of freedom).</p>
<p>In this example, there is strong evidence to reject all three null
hypotheses:</p>
<ul>
<li>that all levels of the copper treatment are equal (P &lt;
0.001),</li>
<li>that the vertical and horizontal orientations are equal (P &lt;
0.001)</li>
<li>that there is no interaction between copper and orientation (P &lt;
0.001)</li>
</ul>
<p>A significant interaction means that the effect of one factor depends
upon the other. In this example, it would mean that the effect of copper
was not consistent between the vertical and horizontal habitats.
Consequently, the interpretation of the main effects becomes more
complex. A quick way to help you understand an interaction if you get
one is to examine an interactions plot.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" tabindex="-1"></a><span class="fu">interaction.plot</span>(sessile<span class="sc">$</span>Copper, sessile<span class="sc">$</span>Orientation, sessile<span class="sc">$</span>Richness)</span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-37-1.png" width="672" /></p>
<p>Here you can see that the effect of copper (a decline in species
richness) is more pronounced in the habitats with a vertical
orientation, and that the difference between the two habitats changes
with exposure to copper.</p>
<p><strong>Multiple comparisons</strong> If you detect any significant
differences in the ANOVA, we are then interested in knowing exactly
which levels differ from one another, and which do not. Remember that a
significant p value in the test you just ran would reject the null
hypothesis the means were the same across all groups, but not identify
which were different from each other. If there is no interaction, you
can run a post-hoc test on each of the main effects (only needed if
there are more than two levels for an effect). If there is an
interaction, you will need to consider post-hoc tests that contrast the
means from all combinations of both factors.</p>
</div>
<div id="assumptions-1" class="section level3">
<h3>Assumptions</h3>
<p>The assumptions of factorial ANOVA’s are the same as for all linear
models including the simpler one-way ANOVA’s, being
<strong>independence</strong>, <strong>normality</strong> and
<strong>homogeneity of variances</strong>. We also need to consider two
new issues: 1) whether your factors are <strong>fixed</strong> or
<strong>random</strong>, and 2) whether your sampling or experimental
design is <strong>balanced</strong> (i.e., has the same number of
replicates in each combination of treatments).</p>
<p><strong>Fixed and random factors</strong> There is an important
distinction between factors whose levels are the only ones of interest
(termed fixed), and factors whose levels are a sampled from a larger
collection of possible levels (termed random). For example, if we
repeated the experiment above at three different sites in another
harbour, chosen from many possible sites, we would consider site a
random factor. We are not interested in those sites in particular, but
would like to know if our experimental treatments were consistent across
sites. On the other hand, if you were only interested in Keelung Harbour
and Kaoshiung Harbour, then these two could be considered two levels of
a fixed factor. Treating sites as a fixed factor in that case means that
you conclusions should not be extrapolated to other possible sites, but
restricted to those particular sites.</p>
<p>Statistically, there is a big difference between a fixed factors were
you have measured all possible levels of interest (e.g, control vs a
single treatment) and random factors where the levels are sampled from
all possible levels. In analysis of variance, all this matters because
the F-tests that are being used to test your hypotheses are constructed
differently depending on which factors are fixed and random. In the
example above, all factors were fixed and the denominator of all F tests
was <span class="math inline">\(MS_{within}\)</span>. In models with all
factors random, and models with a mix of fixed and random factors
(termed mixed effects models), other components of the variation are
used as the denominators in the <span class="math inline">\(F\)</span>
tests.</p>
<p>If you have random factors, you will need to read more to establish
the correct F ratios for your specific design.</p>
<p><strong>Balanced and unbalanced designs</strong> Ideally, factorial
ANOVA should be conducted with a balanced design - one with the same
number of replicates in each combination of factors. Balanced designs
are less likely to be affected by minor deviations from the assumptions
of normality and homogeneity of variance. Unfortunately, unbalanced
designs where you have unequal numbers of replicates for each level are
common in practice (e.g. bad weather prevented sampling the second site
as intensively, volunteer lost the data sheet etc!).</p>
<p>Unbalanced designs are more susceptible to violating the assumptions
of ANOVA and there is no single way to partitioning the <span
class="math inline">\(SS_{total}\)</span> into the main effect and
interaction components. The <code>aov</code> and <code>lm</code>
functions in R use what are called <strong>Type I sums of
squares</strong> where the terms in the model are fitted sequentially
(i.e., how much variation is explained by factor A, then how much
additional variation is explained by adding factor B). This means that
the order of the terms in model matters: the model formulae
<code>Y ~ A + B + A:B</code> and <code>Y ~ B + A + B:A</code> will give
you different results.</p>
<p>There is a fair bit of debate on this in the statistical literature,
but many advise using what are called Type II or Type III sums of
squares for unbalanced designs. Other software packages like SPSS,
SYSTAT and Minitab will automatically use Type III sums of squares where
the order of terms in the model doesn’t matter. To access these in R, we
can use the <code>Anova</code> function in the <code>car</code> package.
But this debate is also one of reason many researcher prefer to avoid or
does not like ANOVAs.</p>
</div>
</div>
<div id="nested-anova" class="section level2">
<h2>Nested ANOVA</h2>
<p>In the two-way ANOVA design, the two factors are known as factorial
(i.e., there was every combination of every level of each factor). Other
experimental designs feature factors that are termed nested. This is
when each level of one of the factors is unique to only one level of the
other factor. In the nested design, the levels of factor B appear in
only one of the levels in factor A, not both. This often happens with
factors like “site” or “area” - they usually belong to only one level of
your other factor. Factor B is termed nested within factor A, usually
written as B(A). These designs have different sources of variance to the
factorial designs, and do not have an interaction term. The designs are
quite common in ecology and environmental sciences, and are often used
to partition variance in spatially hierarchical sampling (e.g.,
habitats, areas within habitats, plots within areas etc.).</p>
<p>The examples below comes from an experiment investigating the impact
of introduced American mink on small rodents (voles) in Finland. The
hypothesis was that mink prey upon voles thereby reducing vole numbers
and limiting their population size. To test this, minks were removed
from large areas (&gt; 20 km2) in the Baltic Sea. The Ho from the
experiment is that the mean count of voles on islands in removal sites
will be the same as the mean vole count on islands in control areas. The
data represent two treatments (mink removal and control) and two areas
nested within each treatment. Then there are 10 samples in each area.
Each of these samples represents the numbers of individual voles trapped
on an island (all islands were more than 300 m apart ensuring some
independence) over 4 nights.</p>
<p>The design is nested because an area cannot belong to both a removal
treatment and a control. It is useful to think of areas as being the
replicates for the treatment, and the individual samples as being
replicates for each area.</p>
<div id="running-the-analysis-3" class="section level3">
<h3>Running the analysis</h3>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" tabindex="-1"></a><span class="co"># Input data file and check the structure of the data</span></span>
<span id="cb52-2"><a href="#cb52-2" tabindex="-1"></a>mink <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="at">file =</span> <span class="st">&quot;data/mink.csv&quot;</span>, <span class="at">header =</span> <span class="cn">TRUE</span>)</span>
<span id="cb52-3"><a href="#cb52-3" tabindex="-1"></a><span class="co"># grouped boxplot</span></span>
<span id="cb52-4"><a href="#cb52-4" tabindex="-1"></a><span class="fu">ggplot</span>(mink, <span class="fu">aes</span>(<span class="at">x=</span>Treatment, <span class="at">y=</span>Voles, <span class="at">fill=</span>Area)) <span class="sc">+</span> </span>
<span id="cb52-5"><a href="#cb52-5" tabindex="-1"></a>    <span class="fu">geom_boxplot</span>()</span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-38-1.png" width="672" /></p>
<div class="sourceCode" id="cb53"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" tabindex="-1"></a>Mink.nested <span class="ot">&lt;-</span> <span class="fu">aov</span>(Voles <span class="sc">~</span> Treatment <span class="sc">+</span> Area <span class="sc">%in%</span> Treatment, <span class="at">data =</span> mink)</span>
<span id="cb53-2"><a href="#cb53-2" tabindex="-1"></a><span class="fu">summary</span>(Mink.nested)</span></code></pre></div>
<pre><code>##                Df Sum Sq Mean Sq F value   Pr(&gt;F)    
## Treatment       1 1416.1  1416.1   38.39 3.81e-07 ***
## Treatment:Area  2  357.8   178.9    4.85   0.0136 *  
## Residuals      36 1328.0    36.9                     
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>The output is a little different to the factorial ANOVA. The top
section gives a significance test of the fixed effect, Treatment, - this
is what we’re interested in. The residuals for this test are those
associated with the random effect ‘Area’.</p>
<p>A significant F-ratio (P&lt;0.05) for a nested factor indicates high
variance among subgroups within a group. For example, a difference in
mean vole numbers of the two areas within a treatment. This is expected,
however, leads to few degrees of freedom to test main effects.
Additionally, it suggests treatments may not have a uniform effect
across levels of the nested factor. For example, voles in one removal
area showed a stronger response than another area.</p>
<p><strong>F-ratios</strong></p>
<ul>
<li>Among groups = MSamong/MSsubgroup</li>
<li>Factor B = MSsubgroup/MSResidual</li>
</ul>
<p><strong>Degrees of freedom</strong></p>
<ul>
<li>Among groups = (a - 1) (where a = number of levels of Factor A)</li>
<li>Among subgroups = a(b - 1) (where b = number of levels of Factor
B)</li>
<li>Within subgroups = ab(n - 1) (where n = sample size)</li>
</ul>
<p>Where there are greater than 2 levels of the the fixed factor of
interest, <em>post-hoc</em> analysis can be used to determine which
groups differ.</p>
<p><strong>Pooling</strong> Always examine nested factors before the
upper levels. If the variance explained by the nested factor is
negligible, it can be pooled. If the F ratio of MSsubgroup/MSwithin is
non significant then you don’t need subgroups and can perform a one
factor analysis.</p>
<p>Even if MSsubgroup/MSwithin is non-significant at a = 0.05, there may
be subgroup effects (may be high Type II error). To be cautious, only
pool SS when P&gt;&gt;&gt;0.05, so there is very little chance that you
are incorrectly accepting the null hypothesis of no effect.</p>
</div>
<div id="assumptions-2" class="section level3">
<h3>Assumptions</h3>
<p>The same assumptions of linear models apply to nested ANOVA’s;
<strong>independence</strong>, <strong>normality</strong> and
<strong>heterogeneity</strong> of variances. Because tests of the fixed
factor A uses uses the means of the nested Factor B, the assumptions of
homogeneity and normality apply with respect to the means of Factor
B.</p>
<blockquote>
<p><em>Source: James Lavender &amp; Alistair Poore</em></p>
</blockquote>
</div>
</div>
</div>
<div id="glms" class="section level1">
<h1>GLMs</h1>
<p>Generalised linear models (GLMs) are used when the distribution of
data do not conform to the assumptions of linear models, specifically
the assumptions of normally distributed residuals and no relationship
between the variance and the mean (e.g., presence/absence, count or
highly skewed data).</p>
<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>Linear models (e.g., linear regression) are used to model the
relationship between a <strong>continuous</strong> response variable
<span class="math inline">\(y\)</span> and one or more explanatory
variables <span class="math inline">\(x_1,x_2,...\)</span>. When we have
a <strong>discrete</strong> response we use GLMs.</p>
<p><strong>Properties of GLM’s</strong> Discrete response data, like
counts and presence/absence data, generally exhibit a mean-variance
relationship. For example; for counts that are on average 5, we would
expect most samples to be between about 1 and 9, but for counts that are
on average 500, most of the observations will tend to be between 450 and
550, giving us a much larger variance when the mean is large. In
contrast, as we know it already, linear models assume constant variance.
You might transform count data and fit a linear model. This can reduce
the mean variance relationship, but it won’t get rid of it completely,
especially if you have a lot of zeros in your data. To analyse discrete
data accurately we need to use GLM’s.</p>
<p>A GLM makes some important assumptions (we’ll check these later for
our examples):</p>
<ol style="list-style-type: decimal">
<li>The observed <span class="math inline">\(y\)</span> are independent,
conditional on some predictors <span
class="math inline">\(x\)</span></li>
<li>The response <span class="math inline">\(y\)</span> come from a
known distribution with a known mean-variance relationship</li>
<li>There is a straight line relationship between a known function <span
class="math inline">\(g\)</span> of the mean of <span
class="math inline">\(y\)</span> and the predictors <span
class="math inline">\(x\)</span></li>
</ol>
<p><span
class="math inline">\(g(\mu_y)=\alpha+\beta_1x_1+\beta_2x_2+...\)</span></p>
<p>Note: link functions <code>g()</code> are an important part of
fitting GLM’s, but beyond the scope of this introductory tutorial. All
you need to know is that the default link for binomial data is the
<code>logit()</code> and for count data it’s <code>log()</code>. For
more information see <code>?family</code>.</p>
</div>
<div id="binomial-example" class="section level2">
<h2>Binomial example</h2>
<p>If had surveyed a beach and wanted to analyse how the presence of a
crab varied with time and distance from the water line, the response
variable is discrete: the presence or absence of a crab in a given
replicate. The first few rows of the data set would look like this:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" tabindex="-1"></a>Crab_PA <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="st">&quot;data/crabs.csv&quot;</span>, <span class="at">header =</span> T)</span>
<span id="cb55-2"><a href="#cb55-2" tabindex="-1"></a><span class="fu">head</span>(Crab_PA)</span></code></pre></div>
<pre><code>##   X Dist Time CrabPres
## 1 1    0    5        0
## 2 2    0    5        1
## 3 3    0    5        1
## 4 4    0    5        0
## 5 5    0    5        0
## 6 6    2    5        0</code></pre>
<div id="running-the-analysis-4" class="section level3">
<h3>Running the analysis</h3>
<p>The variable <code>CrabPres</code> contains binomial data,
i.e. presence/absence data or data as 0/1.Fitting a GLM uses a very
similar syntax to fitting linear models but we use the <code>glm</code>
function instead of <code>lm</code>. We also need to indicate the
<code>family</code> as an argument to the function. To test whether the
probability of crab presence changes with time (a factor) and distance
(a continuous variable), we fit the following model. The response
variable (presence/absence of crabs) is binomial, so we use
<code>family=binomial</code>.</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" tabindex="-1"></a>ft.crab <span class="ot">&lt;-</span> <span class="fu">glm</span>(CrabPres <span class="sc">~</span> Time <span class="sc">*</span> Dist, <span class="at">family =</span> binomial, <span class="at">data =</span> Crab_PA)</span></code></pre></div>
</div>
<div id="assumptions-3" class="section level3">
<h3>Assumptions</h3>
<p>Before we look at the results of our analysis it’s important to check
that our data met the assumptions of the model we used. Let’s look at
all the assumptions in order.</p>
<p><strong>Assumption 1 : The observed <span
class="math inline">\(y\)</span> are independent, conditional on some
predictors <span class="math inline">\(x\)</span></strong></p>
<p>We can’t check this assumption from the results, but you can ensure
it’s true by taking a random sample for your experimental design. If
your experimental design involves any pseudo-replication, this
assumption will be violated. For certain types of pseudo-replication you
can use mixed models instead.</p>
<p><strong>Assumption 2 : The response <span
class="math inline">\(y\)</span> come from a known distribution with a
known mean-variance relationship</strong></p>
<p>The mean variance relationship is the main reason we use GLM’s
instead of linear models. We need to check that the distribution models
the mean-variance relationship of our data well. For binomial data this
is not a big concern, but later on when we analyse count data it’ll be
very important. To check this assumption we look at a plot of residuals,
and try to see if there is a fan shape.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1" tabindex="-1"></a><span class="fu">plot</span>(ft.crab, <span class="at">which =</span> <span class="dv">1</span>)</span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-42-1.png" width="672" /></p>
<p>Unfortunately the <code>glm</code> plot function gives us a very odd
looking plot due to the discreteness of the data (i.e., many points on
top of each other). For a more useful plot we can instead fit the model
using the <code>manyglm</code> function in the <code>mvabund</code>
package. We need a slight change to the family argument, for
<code>manyglm</code> we write <code>family = "binomial"</code>.</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" tabindex="-1"></a>ft.crab.many <span class="ot">&lt;-</span> <span class="fu">manyglm</span>(CrabPres <span class="sc">~</span> Time <span class="sc">*</span> Dist, <span class="at">family =</span> <span class="st">&quot;binomial&quot;</span>, <span class="at">data =</span> Crab_PA)</span>
<span id="cb59-2"><a href="#cb59-2" tabindex="-1"></a><span class="fu">plot</span>(ft.crab.many)</span></code></pre></div>
<pre><code>## Warning in default.plot.manyglm(x, res.type = res.type, which = which, caption
## = caption, : Only the first 1 colors will be used for plotting.</code></pre>
<p><img src="stat_2_files/figure-html/unnamed-chunk-43-1.png" width="672" /></p>
<p>Now we can look for a fan shape in the residual plot. For these data,
there doesn’t seem to be a fan shape, so we can conclude the
mean-variance assumption the model made was reasonable for our data. The
residuals in this plot have a random component. If you see a pattern
it’s best to repeat the plot a few times to see if the pattern is
real.</p>
<p><strong>Assumption 3 : There is a straight line relationship between
a known function <span class="math inline">\(g\)</span> of the mean
<span class="math inline">\(y\)</span> and he predictor <span
class="math inline">\(x\)</span></strong></p>
<p>To check this assumption, we check the residual plot above for
non-linearity, or a U-shape. In our case there is no evidence of
non-linearity. If the residuals seem to go down then up, or up then
down, we may need to add a polynomial function of the predictors using
the <code>poly</code> function.</p>
</div>
<div id="interpreting" class="section level3">
<h3>Interpreting</h3>
<p>If all the assumption checks are okay, we can have a look at the
results the model gave us. The two main functions for inference are the
same as for linear models: <code>summary</code> and
<code>anova</code>.</p>
<p>The p-values these give you if you use <code>glm</code> for fitting
the model work well in large samples, although they are still
approximate. For binomial models in particular the p-values from the
<code>summary</code> function can be funny, and we prefer to use the
<code>anova</code> function to see if predictors are significant. The
<code>summary()</code> function is still useful to look at the model
equation.</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1" tabindex="-1"></a><span class="fu">anova</span>(ft.crab, <span class="at">test =</span> <span class="st">&quot;Chisq&quot;</span>)</span></code></pre></div>
<pre><code>## Analysis of Deviance Table
## 
## Model: binomial, link: logit
## 
## Response: CrabPres
## 
## Terms added sequentially (first to last)
## 
## 
##           Df Deviance Resid. Df Resid. Dev Pr(&gt;Chi)   
## NULL                         56     71.097            
## Time       1   6.6701        55     64.427 0.009804 **
## Dist       1   0.7955        54     63.631 0.372448   
## Time:Dist  1   0.1647        53     63.466 0.684852   
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>The p-value for <em>Time</em> is small (P&lt;0.01), so we conclude
there is an effect of time on the presence of crabs, but no effect of
distance or an interaction between time and distance. This sample is
reasonably large, so these p-values should be a good approximation. For
a small sample it is often better to use resampling to calculate
p-values. When you use <code>manyglm</code> the summary and anova
functions use resampling by default.</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1" tabindex="-1"></a><span class="fu">anova</span>(ft.crab.many)</span></code></pre></div>
<pre><code>## Time elapsed: 0 hr 0 min 0 sec</code></pre>
<pre><code>## Analysis of Deviance Table
## 
## Model: CrabPres ~ Time * Dist
## 
## Multivariate test:
##             Res.Df Df.diff   Dev Pr(&gt;Dev)  
## (Intercept)     56                         
## Time            55       1 6.670    0.018 *
## Dist            54       1 0.795    0.371  
## Time:Dist       53       1 0.165    0.722  
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## Arguments: P-value calculated using 999 iterations via PIT-trap resampling.</code></pre>
<p>In this case the results are quite similar, but in small samples it
can often make a big difference.</p>
<p>You can also use <code>summary</code> with either the
<code>glm</code> or <code>manyglm</code> function. This is interpreted
in a similar manner as for linear regression, but we need to include the
link function, <code>g</code>.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1" tabindex="-1"></a><span class="fu">summary</span>(ft.crab)</span></code></pre></div>
<pre><code>## 
## Call:
## glm(formula = CrabPres ~ Time * Dist, family = binomial, data = Crab_PA)
## 
## Deviance Residuals: 
##     Min       1Q   Median       3Q      Max  
## -1.3518  -0.6457  -0.5890   1.0125   1.9390  
## 
## Coefficients:
##             Estimate Std. Error z value Pr(&gt;|z|)  
## (Intercept) -3.00604    1.47469  -2.038   0.0415 *
## Time         0.25835    0.17439   1.481   0.1385  
## Dist        -0.03193    0.23923  -0.133   0.8938  
## Time:Dist    0.01143    0.02830   0.404   0.6863  
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## (Dispersion parameter for binomial family taken to be 1)
## 
##     Null deviance: 71.097  on 56  degrees of freedom
## Residual deviance: 63.466  on 53  degrees of freedom
## AIC: 71.466
## 
## Number of Fisher Scoring iterations: 4</code></pre>
<p>If <span class="math inline">\(p\)</span> is the probability of crab
presence, this output tells us:</p>
<p><span class="math inline">\(logit(p) = -3.01 + 0.26 * Time - 0.03 *
Dist + 0.01 * Time * Dist\)</span></p>
<p><strong>Conclusion:</strong> We used a binomial linear model because
of binary data (presence/abscence) of crabs. Inference was carried out
using bootstrap resampling with 1000 resamples (default when using
manyglm). There is strong evidence that the presence of crabs varies
with time (p = 0.01). Note that for multiple predictors it’s best to
display the results in a table.</p>
</div>
</div>
<div id="poisson-example" class="section level2">
<h2>Poisson example</h2>
<p>For this worked example, we have counts of different animal groups at
control sites and sites where bush regeneration has been carried out
(treatment). We want to know if the the bush regeneration activities
have affected the count of slugs.</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb68-1"><a href="#cb68-1" tabindex="-1"></a>Reveg <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="st">&quot;data/revegetation.csv&quot;</span>, <span class="at">header =</span> T)</span>
<span id="cb68-2"><a href="#cb68-2" tabindex="-1"></a><span class="fu">head</span>(Reveg)</span></code></pre></div>
<pre><code>##     Treatment Site Acarina Amphipoda Araneae Blattodea Coleoptera Collembola
## 1 Revegetated    8     147        28       0         0         10       1700
## 2 Revegetated    8      82        27       0         0          7       3200
## 3 Revegetated    8     131        35       0         0          9       4367
## 4 Revegetated    8      25        10       0         0         59        360
## 5 Revegetated    8      20        56       1         0         12        500
## 6 Revegetated   7a      16         3       1         0          3       1850
##   Dermaptera Diotocardia Diplura Diptera Formicidae Haplotaxida Hemiptera
## 1          1           1       0      11        128           4         0
## 2          0           0       0      11        130           7         0
## 3          0           1       0      18        120           0         7
## 4          0           0       0      82          9           7         5
## 5          0           0       0      31         38           0         0
## 6          0           0       0      26         26           2         0
##   Hymenoptera Isopoda Larvae Lepidoptera Polydesmida Pseudoscorpionida
## 1           0       0      3           0           0                 0
## 2           0       6      3           0           0                 1
## 3           1       2     13           0           0                 2
## 4           2       1    229           0           1                 0
## 5          46       0      0           0           1                 0
## 6           2       0      0           0           0                 0
##   Scolopendrida Seolifera Soleolifera Thysanoptera Tricladida
## 1             0         0           3            0          0
## 2             0         0           5            0          0
## 3             0         0          17            0          0
## 4             0         0           1            0          0
## 5             0         5           0            0          0
## 6             0         0           0            0          0</code></pre>
<p>If you view the frequency histogram of the slug counts, you will see
that it is very skewed, with many small values and few large counts (the
variable name, Soleolifera, is the order name of terrestrial slugs).</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb70-1"><a href="#cb70-1" tabindex="-1"></a><span class="fu">hist</span>(Reveg<span class="sc">$</span>Soleolifera)</span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-48-1.png" width="672" /></p>
<p>The default distribution for count data is the Poisson. The Poisson
distribution assumes the variance equals the mean. This is quite a
restrictive assumption which ecological count data often violate. We may
need to use the more flexible negative-binomial distribution
instead.</p>
<div id="running-the-analysis-5" class="section level3">
<h3>Running the analysis</h3>
<p>We can use a GLM to test whether the counts of slugs (from the order
Soleolifera) differ between control and regenerated sites. To fit the
GLM, we will use the <code>manyglm</code> function instead of
<code>glm</code> so we have access to more useful residual plots.</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb71-1"><a href="#cb71-1" tabindex="-1"></a>ft.sol.pois <span class="ot">&lt;-</span> <span class="fu">manyglm</span>(Soleolifera <span class="sc">~</span> Treatment, <span class="at">family =</span> <span class="st">&quot;poisson&quot;</span>, <span class="at">data =</span> Reveg)</span></code></pre></div>
<p>where Soleolifera is the response variable, and Treatment is the
predictor variable (with two levels, control and revegetated).</p>
</div>
<div id="assumptions-4" class="section level3">
<h3>Assumptions</h3>
<p>Before we look at the results, we need to look at the residual plot
to check the assumption</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb72-1"><a href="#cb72-1" tabindex="-1"></a><span class="fu">plot</span>(ft.sol.pois)</span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-50-1.png" width="672" /></p>
<p>It’s hard to say whether there is any non-linearity in this plot,
this is because the predictor is binary (treatment vs revegetated).
Looking at the variance assumption, it does appear as though there is a
fan shape. The residuals are more spread out on the right than the left
- we call this overdispersion.</p>
<p>This tells us the variance assumption of the Poisson may be too
restrictive and we should try a different distribution. We can instead
fit a negative-binomial distribution in <code>manyglm</code> by changing
the family argument to <code>family="negative binomial"</code>.</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb73-1"><a href="#cb73-1" tabindex="-1"></a>ft.sol.nb <span class="ot">&lt;-</span> <span class="fu">manyglm</span>(Soleolifera <span class="sc">~</span> Treatment, <span class="at">family =</span> <span class="st">&quot;negative binomiale&quot;</span>, <span class="at">data =</span> Reveg)</span></code></pre></div>
<p>Look again at the residual plot:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb74-1"><a href="#cb74-1" tabindex="-1"></a><span class="fu">plot</span>(ft.sol.nb)</span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-52-1.png" width="672" /></p>
<p>This seems to have improved the residual plot. There is no longer a
strong fan shape, so we can go ahead and look at the results.</p>
</div>
<div id="interpreting-1" class="section level3">
<h3>Interpreting</h3>
<div class="sourceCode" id="cb75"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb75-1"><a href="#cb75-1" tabindex="-1"></a><span class="fu">anova</span>(ft.sol.nb)</span></code></pre></div>
<pre><code>## Time elapsed: 0 hr 0 min 0 sec</code></pre>
<pre><code>## Analysis of Deviance Table
## 
## Model: Soleolifera ~ Treatment
## 
## Multivariate test:
##             Res.Df Df.diff   Dev Pr(&gt;Dev)   
## (Intercept)     48                          
## Treatment       47       1 10.52    0.004 **
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## Arguments: P-value calculated using 999 iterations via PIT-trap resampling.</code></pre>
<div class="sourceCode" id="cb78"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb78-1"><a href="#cb78-1" tabindex="-1"></a><span class="fu">summary</span>(ft.sol.nb)</span></code></pre></div>
<pre><code>## 
## Test statistics:
##                      wald value Pr(&gt;wald)    
## (Intercept)               1.502     0.020 *  
## TreatmentRevegetated      3.307     0.001 ***
## --- 
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 
## 
## Test statistic:  3.307, p-value: 0.001 
## Arguments: P-value calculated using 999 resampling iterations via pit.trap resampling.</code></pre>
<p>Both indicate strong evidence of a treatment effect (p&lt;0.01). To
extract the model equation we can look at the coefficients from the
fit.</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb80-1"><a href="#cb80-1" tabindex="-1"></a>ft.sol.nb<span class="sc">$</span>coefficients</span></code></pre></div>
<pre><code>##                      Soleolifera
## (Intercept)           -0.9162907
## TreatmentRevegetated   2.1202635</code></pre>
<p>The default link function for Poisson and negative binomial models is
<span class="math inline">\(log\)</span>. If we write the mean count as
<span class="math inline">\(\lambda\)</span></p>
<p><span class="math inline">\(log(\lambda)=-0.92+2.12 \times
Treatment\)</span></p>
<p><strong>Conclusion:</strong> We used a negative-binomial generalised
linear model due to overdispersion evident in the data. Inference was
carried out using bootstrap resampling with 1000 resamples (default when
using manyglm). There is strong evidence of positive effect of bush
regeneration on the abundance of slugs from the order Soleolifera (p
&lt; 0.001).</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb82-1"><a href="#cb82-1" tabindex="-1"></a><span class="fu">boxplot</span>(Soleolifera <span class="sc">~</span> Treatment, <span class="at">ylab =</span> <span class="st">&quot;Count&quot;</span>, <span class="at">xlab =</span> <span class="st">&quot;Treatment&quot;</span>, <span class="at">data =</span> Reveg)</span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-56-1.png" width="672" />
&gt; <em>Source: Gordana Popovic</em></p>
</div>
</div>
</div>
<div id="mixed-models" class="section level1">
<h1>Mixed models</h1>
<p>Mixed models are those with a mixture of fixed and random effects.
Random effects are categorical factors where the levels have been
selected from many possible levels and the investigator would like to
make inferences beyond just the levels chosen. Tricky concept, but
imagine contrasting two habitat types (forest and grassland) by sampling
five sites within each, and five replicate measures within each site.
Habitat type is a fixed factor with the researcher only interested in
those two levels of habitat type. If the five sites were chosen from a
larger collection of possible sites, then site is considered a random
effect with 10 levels.</p>
<p>You will need to use mixed effect models if you have a random factor
in your experimental design. A random factor:</p>
<ul>
<li>is categorical</li>
<li>has a large number of levels</li>
<li>only a random subsample of levels is included in your design</li>
<li>you want to make inference in general, and not only for the levels
you observed</li>
</ul>
<p><strong>Assumptions of mixed models</strong></p>
<ul>
<li>The observed <span class="math inline">\(y\)</span> are independant,
conditional on some predictor <span
class="math inline">\(x\)</span></li>
<li>The response <span class="math inline">\(y\)</span> are normally
distributed, conditional on some predictors <span
class="math inline">\(x\)</span></li>
<li>The response <span class="math inline">\(y\)</span> has constant
variance, conditional on some predictors <span
class="math inline">\(x\)</span></li>
<li>There is a straight line relationship between <span
class="math inline">\(y\)</span> and the predictors <span
class="math inline">\(x\)</span> and random effects <span
class="math inline">\(z\)</span></li>
<li>Random effect <span class="math inline">\(z\)</span> are independant
of <span class="math inline">\(y\)</span></li>
<li>Random effect <span class="math inline">\(z\)</span> are normally
distributed</li>
</ul>
<p>This is a tough concept to get your head around, and is best
explained with an example. The data we will analyse here are counts of
invertebrates at 3-4 sites in each of 7 (randomly chosen) estuaries.
Here the estuaries are the random effect, as there are a large number of
possible estuaries, and we only sample from a random few of them, but we
would like to make inference about estuaries in general. We will use the
package <code>lme4</code> for all our mixed effect modelling. It will
allow us to model both continuous and discrete data with one or more
random effects.</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb83-1"><a href="#cb83-1" tabindex="-1"></a>Estuaries <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="st">&quot;data/estuaries.csv&quot;</span>, <span class="at">header =</span> T)</span></code></pre></div>
<div id="linear-mixed-models-with-one-random-effect"
class="section level2">
<h2>Linear Mixed models with one random effect</h2>
<p>We aim to investigate the effects of water pollution on the abundance
of some subtidal marine invertebrates by comparing samples from altered
and pristine estuaries. Since the total counts are large, we assume the
data are continuous. In this dataset, we focus on the effects of
modification on invertebrates, regardless of the estuaries.</p>
<div id="running-the-analysis-6" class="section level3">
<h3>Running the analysis</h3>
<p>We have a <strong>fixed effect</strong> (Modification; modified vs
pristine) and a <strong>random effect</strong> (Estuary). We can use the
<code>lmer</code> function to fit a model for any dependent variables
with a continuous distribution. To fit a model for the
<code>Total</code> abundance variable, we use:</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb84-1"><a href="#cb84-1" tabindex="-1"></a>ft.estu <span class="ot">&lt;-</span> <span class="fu">lmer</span>(Total <span class="sc">~</span> Modification <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> Estuary), <span class="at">data =</span> Estuaries, <span class="at">REML =</span> T)</span></code></pre></div>
<p>where <code>Total</code> is the <strong>dependent variable</strong>
(left of the <code>~</code>), <code>Modification</code> is the
<strong>fixed effect</strong>, and <code>Estuary</code> is the
<strong>random effect</strong>.</p>
<p>Note the syntax for one random effect is <code>(1|Estuary)</code> -
this is fitting a different intercept (hence <code>1</code>) for each
Estuary.</p>
<p>This model can be fit by maximum likelihood (<code>REML=F</code>) or
restricted maximum likelihood (<code>REML=T</code>). For fitting models
it’s best to use <code>REML</code>, as it is less biased (unbiased for
balanced samples), particularly in small samples. However to use the
<code>anova</code> function and/or comparing models we need to refit
with maximum likelihood.</p>
</div>
<div id="model-assumptions" class="section level3">
<h3>Model assumptions</h3>
<p>Before we look at the results of our analysis, it’s important to
check that our data met the assumptions of the model we used. Let’s look
at all the assumptions in order.</p>
<p><strong>Assumption 1</strong>: The observed <span
class="math inline">\(y\)</span> are independent, conditional on some
fixed effects <span class="math inline">\(x\)</span> and random effects
<span class="math inline">\(z\)</span></p>
<p>We can’t check this assumption, but you can ensure it’s true by
taking a random sample within each level of the random effect in your
experimental design.</p>
<p><strong>Assumption 2</strong>: The response <span
class="math inline">\(y\)</span> are normally distributed, conditional
on some predictors <span class="math inline">\(x\)</span> and random
effects <span class="math inline">\(z\)</span></p>
<p>This assumption is only critical when we have a small sample size or
very skewed data. We can check it with a normal quantile plot of
residuals.</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb85-1"><a href="#cb85-1" tabindex="-1"></a><span class="fu">qqnorm</span>(<span class="fu">residuals</span>(ft.estu))</span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-59-1.png" width="672" />
We are looking for a straight line relationship. Here, the assumption of
normality seems reasonable.</p>
<p><strong>Assumption 3</strong>: The response <span
class="math inline">\(y\)</span> has constant variance, conditional on
some fixed effects <span class="math inline">\(x\)</span> and random
effects <span class="math inline">\(z\)</span></p>
<p>Like a linear model, a mixed model assumes constant variance. We can
check this by looking for a fan shape in the residual plot (residuals vs
fitted values).</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb86-1"><a href="#cb86-1" tabindex="-1"></a><span class="fu">scatter.smooth</span>(<span class="fu">residuals</span>(ft.estu) <span class="sc">~</span> <span class="fu">fitted</span>(ft.estu))</span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-60-1.png" width="672" />
This residual plot seems reasonable, there are differences in
variability between estuaries, but variability does not increase with
the mean. Note, that the function <code>scatter.smooth</code> is just a
scatter plot with a fitted, smoothed curve.</p>
<p><strong>Assumption 4</strong>: There is a straight line relationship
between <span class="math inline">\(y\)</span> and the predictor <span
class="math inline">\(x\)</span> and random effect <span
class="math inline">\(z\)</span></p>
<p>To check this assumption, we check the residual plot again for
non-linearity, or a U-shape. In our case there is no evidence of
non-linearity. If the residuals seem to go down then up, or up then
down, we may need to add a polynomial function of the predictors using
the <code>poly</code> function.</p>
<p><strong>Assumption 5</strong>: Random effects <code>z</code> are
independent of <code>y</code>.</p>
<p>We can’t check this assumption, but you can ensure it’s true by
taking a random sample of estuaries.</p>
<p><strong>Assumption 6</strong>: Random effects <code>z</code> are
normally distributed.</p>
<p>This assumption is not crucial (and difficult) to check.</p>
</div>
<div id="model-interpretation" class="section level3">
<h3>Model interpretation</h3>
<div id="hypothesis-test-for-the-fixed-effect" class="section level4">
<h4>Hypothesis test for the fixed effect</h4>
<p>The package <code>lme4</code> won’t give you p-values for fixed
effects as part of the output in <code>summary</code>. This is because
the p-values from Wald tests (using <code>summary</code>) and likelihood
ratio tests (using <code>anova</code>) are only approximate in mixed
models.</p>
<p>Nevertheless, we will use the <code>anova</code> function to test for
an effect of modification on the total abundance of invertebrates,
taking into account the random effect of estuary.</p>
<p>First, we fit the full model by maximum likelihood, and a second
model that lacks the fixed effect of Modification</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb87-1"><a href="#cb87-1" tabindex="-1"></a>ft.estu <span class="ot">&lt;-</span> <span class="fu">lmer</span>(Total <span class="sc">~</span> Modification <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> Estuary), <span class="at">data =</span> Estuaries, <span class="at">REML =</span> F)</span>
<span id="cb87-2"><a href="#cb87-2" tabindex="-1"></a>ft.estu<span class="fl">.0</span> <span class="ot">&lt;-</span> <span class="fu">lmer</span>(Total <span class="sc">~</span> (<span class="dv">1</span> <span class="sc">|</span> Estuary), <span class="at">data =</span> Estuaries, <span class="at">REML =</span> F)</span></code></pre></div>
<p>Then, we compare these two models with a likelihood ratio test, using
the <code>anova</code> function.</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb88-1"><a href="#cb88-1" tabindex="-1"></a><span class="fu">anova</span>(ft.estu<span class="fl">.0</span>, ft.estu)</span></code></pre></div>
<pre><code>## Data: Estuaries
## Models:
## ft.estu.0: Total ~ (1 | Estuary)
## ft.estu: Total ~ Modification + (1 | Estuary)
##           npar    AIC    BIC  logLik deviance  Chisq Df Pr(&gt;Chisq)  
## ft.estu.0    3 415.02 420.99 -204.51   409.02                       
## ft.estu      4 411.92 419.87 -201.96   403.92 5.1055  1    0.02385 *
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>We find that there is evidence of an effect of Modification (p =
0.02385). The package <code>lmerTest</code>extended output of the
summary of your <code>lmer</code> object. Here, the results will give
you p= 0.067611 for the effect of Modification. As mentioned earlier,
whether p-values provide the right indication for significance is the
object of discussion.</p>
<p>We can also calculate confidence intervals for each model parameter
using the confint function.</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb90-1"><a href="#cb90-1" tabindex="-1"></a><span class="fu">confint</span>(ft.estu)</span></code></pre></div>
<pre><code>## Computing profile confidence intervals ...</code></pre>
<pre><code>##                           2.5 %    97.5 %
## .sig01                 2.718166 12.538348
## .sigma                 7.676352 11.522837
## (Intercept)           31.918235 49.981321
## ModificationPristine -26.360731 -2.538241</code></pre>
<p>This also provides evidence for an effect of Modification as this
parameter (i.e., the difference between the modified and pristine
estuaries) has 95% confidence intervals that do not overlap zero.</p>
</div>
<div id="hypothesis-test-for-random-effects" class="section level4">
<h4>Hypothesis test for random effects</h4>
<p>You can use the <code>anova</code> function to test for random
effects, but the p-values are very approximate and this procedure is not
recommended. Instead we will use a <strong>parametric
bootstrap</strong>. This is a simulation based method which involves a
fair chunk of code, but there’s not much about the code you have to
change for different models, it’s mostly just a matter of
copy-paste.</p>
<p>Parametric bootstrap</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb93-1"><a href="#cb93-1" tabindex="-1"></a>nBoot <span class="ot">&lt;-</span> <span class="dv">1000</span></span>
<span id="cb93-2"><a href="#cb93-2" tabindex="-1"></a>lrStat <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="cn">NA</span>, nBoot)</span>
<span id="cb93-3"><a href="#cb93-3" tabindex="-1"></a>ft.null <span class="ot">&lt;-</span> <span class="fu">lm</span>(Total <span class="sc">~</span> Modification, <span class="at">data =</span> Estuaries) <span class="co"># null model</span></span>
<span id="cb93-4"><a href="#cb93-4" tabindex="-1"></a>ft.alt <span class="ot">&lt;-</span> <span class="fu">lmer</span>(Total <span class="sc">~</span> Modification <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> Estuary), <span class="at">data =</span> Estuaries, <span class="at">REML =</span> F) <span class="co"># alternate model</span></span>
<span id="cb93-5"><a href="#cb93-5" tabindex="-1"></a>lrObs <span class="ot">&lt;-</span> <span class="dv">2</span> <span class="sc">*</span> <span class="fu">logLik</span>(ft.alt) <span class="sc">-</span> <span class="dv">2</span> <span class="sc">*</span> <span class="fu">logLik</span>(ft.null) <span class="co"># observed test stat</span></span>
<span id="cb93-6"><a href="#cb93-6" tabindex="-1"></a><span class="cf">for</span> (iBoot <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nBoot)</span>
<span id="cb93-7"><a href="#cb93-7" tabindex="-1"></a>{</span>
<span id="cb93-8"><a href="#cb93-8" tabindex="-1"></a>  Estuaries<span class="sc">$</span>TotalSim <span class="ot">&lt;-</span> <span class="fu">unlist</span>(<span class="fu">simulate</span>(ft.null)) <span class="co"># resampled data</span></span>
<span id="cb93-9"><a href="#cb93-9" tabindex="-1"></a>  bNull <span class="ot">&lt;-</span> <span class="fu">lm</span>(TotalSim <span class="sc">~</span> Modification, <span class="at">data =</span> Estuaries) <span class="co"># null model</span></span>
<span id="cb93-10"><a href="#cb93-10" tabindex="-1"></a>  bAlt <span class="ot">&lt;-</span> <span class="fu">lmer</span>(TotalSim <span class="sc">~</span> Modification <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> Estuary), <span class="at">data =</span> Estuaries, <span class="at">REML =</span> F) <span class="co"># alternate model</span></span>
<span id="cb93-11"><a href="#cb93-11" tabindex="-1"></a>  lrStat[iBoot] <span class="ot">&lt;-</span> <span class="dv">2</span> <span class="sc">*</span> <span class="fu">logLik</span>(bAlt) <span class="sc">-</span> <span class="dv">2</span> <span class="sc">*</span> <span class="fu">logLik</span>(bNull) <span class="co"># resampled test stat</span></span>
<span id="cb93-12"><a href="#cb93-12" tabindex="-1"></a>}</span>
<span id="cb93-13"><a href="#cb93-13" tabindex="-1"></a><span class="fu">mean</span>(lrStat <span class="sc">&gt;</span> lrObs) <span class="co"># P-value for test of Estuary effect</span></span></code></pre></div>
<pre><code>## [1] 0</code></pre>
<p>There is strong evidence for including estuary in your model (p =
0.001). You could use similar code to test for the effect of
Modification with a parametric bootstrap.</p>
<p>In your results, you should mention that you are using mixed models
with R package <code>lme4</code>. You should also mention how you
carried out inference, i.e. likelihood ratio tests (using the
<code>anova</code> function) or parametric bootstrap. In the results
section for one predictor, it suffices to write one line, e.g. “There is
strong evidence (p&lt;0.001) of negative effect of modification on total
abundance. For multiple predictors it’s best to display the results in a
table.</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb95-1"><a href="#cb95-1" tabindex="-1"></a>ModEst <span class="ot">&lt;-</span> <span class="fu">unique</span>(Estuaries[<span class="fu">c</span>(<span class="st">&quot;Estuary&quot;</span>, <span class="st">&quot;Modification&quot;</span>)]) <span class="co"># find which Estuaries are modified</span></span>
<span id="cb95-2"><a href="#cb95-2" tabindex="-1"></a></span>
<span id="cb95-3"><a href="#cb95-3" tabindex="-1"></a><span class="co"># Prepare a vector of colors with specific color by modification levels</span></span>
<span id="cb95-4"><a href="#cb95-4" tabindex="-1"></a>myColors <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(<span class="fu">unique</span>(ModEst<span class="sc">$</span>Modification) <span class="sc">==</span> <span class="st">&quot;Modified&quot;</span>, <span class="fu">rgb</span>(<span class="fl">0.1</span>, <span class="fl">0.1</span>, <span class="fl">0.7</span>, <span class="fl">0.5</span>),</span>
<span id="cb95-5"><a href="#cb95-5" tabindex="-1"></a>  <span class="fu">ifelse</span>(<span class="fu">unique</span>(ModEst<span class="sc">$</span>Modification) <span class="sc">==</span> <span class="st">&quot;Pristine&quot;</span>, <span class="fu">rgb</span>(<span class="fl">0.8</span>, <span class="fl">0.1</span>, <span class="fl">0.3</span>, <span class="fl">0.6</span>),</span>
<span id="cb95-6"><a href="#cb95-6" tabindex="-1"></a>    <span class="st">&quot;grey90&quot;</span></span>
<span id="cb95-7"><a href="#cb95-7" tabindex="-1"></a>  )</span>
<span id="cb95-8"><a href="#cb95-8" tabindex="-1"></a>)</span>
<span id="cb95-9"><a href="#cb95-9" tabindex="-1"></a></span>
<span id="cb95-10"><a href="#cb95-10" tabindex="-1"></a><span class="fu">boxplot</span>(Total <span class="sc">~</span> Estuary, <span class="at">data =</span> Estuaries, <span class="at">col =</span> myColors, <span class="at">xlab =</span> <span class="st">&quot;Estuary&quot;</span>, <span class="at">ylab =</span> <span class="st">&quot;Total invertebrates&quot;</span>)</span>
<span id="cb95-11"><a href="#cb95-11" tabindex="-1"></a><span class="fu">legend</span>(<span class="st">&quot;bottomleft&quot;</span>,</span>
<span id="cb95-12"><a href="#cb95-12" tabindex="-1"></a>  <span class="at">inset =</span> .<span class="dv">02</span>,</span>
<span id="cb95-13"><a href="#cb95-13" tabindex="-1"></a>  <span class="fu">c</span>(<span class="st">&quot; Modified &quot;</span>, <span class="st">&quot; Pristine &quot;</span>), <span class="at">fill =</span> <span class="fu">unique</span>(myColors), <span class="at">horiz =</span> <span class="cn">TRUE</span>, <span class="at">cex =</span> <span class="fl">0.8</span></span>
<span id="cb95-14"><a href="#cb95-14" tabindex="-1"></a>)</span>
<span id="cb95-15"><a href="#cb95-15" tabindex="-1"></a></span>
<span id="cb95-16"><a href="#cb95-16" tabindex="-1"></a><span class="co"># 0 if Modified, 1 if Pristine</span></span>
<span id="cb95-17"><a href="#cb95-17" tabindex="-1"></a>is.mod <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(<span class="fu">unique</span>(ModEst<span class="sc">$</span>Modification) <span class="sc">==</span> <span class="st">&quot;Modified&quot;</span>, <span class="dv">0</span>,</span>
<span id="cb95-18"><a href="#cb95-18" tabindex="-1"></a>  <span class="fu">ifelse</span>(<span class="fu">unique</span>(ModEst<span class="sc">$</span>Modification) <span class="sc">==</span> <span class="st">&quot;Pristine&quot;</span>, <span class="dv">1</span>, <span class="cn">NA</span>)</span>
<span id="cb95-19"><a href="#cb95-19" tabindex="-1"></a>)</span>
<span id="cb95-20"><a href="#cb95-20" tabindex="-1"></a></span>
<span id="cb95-21"><a href="#cb95-21" tabindex="-1"></a>Est.means <span class="ot">&lt;-</span> <span class="fu">coef</span>(ft.estu)<span class="sc">$</span>Estuary[, <span class="dv">1</span>] <span class="sc">+</span> <span class="fu">coef</span>(ft.estu)<span class="sc">$</span>Estuary[, <span class="dv">2</span>] <span class="sc">*</span> is.mod <span class="co"># Model means</span></span></code></pre></div>
<pre><code>## Warning in coef(ft.estu)$Estuary[, 2] * is.mod: longer object length is not a
## multiple of shorter object length</code></pre>
<div class="sourceCode" id="cb97"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb97-1"><a href="#cb97-1" tabindex="-1"></a><span class="fu">stripchart</span>(Est.means <span class="sc">~</span> <span class="fu">sort</span>(<span class="fu">unique</span>(Estuary)), <span class="at">data =</span> Estuaries, <span class="at">pch =</span> <span class="dv">18</span>, <span class="at">col =</span> <span class="st">&quot;red&quot;</span>, <span class="at">vertical =</span> <span class="cn">TRUE</span>, <span class="at">add =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-65-1.png" width="672" /></p>
</div>
</div>
<div id="faq-mixed-models" class="section level3">
<h3>FAQ mixed models</h3>
<ol style="list-style-type: decimal">
<li>Do I need balanced samples to fit a mixed model?</li>
</ol>
<p>No, unbalanced designs are fine. Balanced designs will generally give
you better power though, so they are good to aim for.</p>
<ol start="2" style="list-style-type: decimal">
<li>Should I sample many levels of the random effect, or lots of
observations within each level?</li>
</ol>
<p>This depends on what you are interested in. In our example, we are
interested in the effect of modification. In the study design, estuaries
fall directly below modification, so we need a lot of estuaries within
each level of Modification to make good inference about the effects of
modification. This is true in general, you need lots of samples in the
level below the level you are primarily interested in.</p>
<ol start="3" style="list-style-type: decimal">
<li>Does my random factor have to be a random effect?</li>
</ol>
<p>Not necessarily. If you have a random factor (i.e., you have a random
sample of categories from a categorical variable) and you want to make
inferences about that variable in general, not just at the categories
you observed, then include it as a random effect. If you are happy
making inference about just the levels you observed, then you can
include it as a fixed effect. In our example we wanted to make inference
about modification in general, i.e. in every modified and unmodified
estuary, so we included estuary as a random effect. If we had treated
Estuary as a fixed factor, we would have been restricted to making
conclusions about only the estuaries we sample.</p>
<ol start="4" style="list-style-type: decimal">
<li>What if the levels of my factor aren’t really random?</li>
</ol>
<p>This might be a problem as assumption 4 may not hold. You should
always sample the random effect randomly to avoid bias and incorrect
conclusions.</p>
</div>
</div>
<div id="crossed-and-nested-factors" class="section level2">
<h2>Crossed and nested Factors</h2>
<p>Many experimental designs in ecology and environmental sciences
require mixed models with several <strong>random effects</strong>
(factors). You might have heard of <strong>nested</strong> and
<strong>crossed</strong> factors.</p>
<p>Two factors are <strong>crossed</strong> when every category (level)
of one factor co-occurs in the design with every category of the other
factor. In other words, there is at least one observation in every
combination of categories for the two factors.</p>
<p>A factor is <strong>nested</strong> within another factor when each
category of the first factor co-occurs with only one category of the
other. In other words, an observation has to be within one category of
Factor 2 in order to have a specific category of Factor 1. All
combinations of categories are not represented.</p>
<p>There are also intermediate designs that are partially crossed, where
some levels of one factor occur in several (but not all) levels of the
second factor. These designs have often been taught as separate problems
with different ways to carry out analyses of variance (ANOVAs) depending
on if you have crossed or nested factors. Using mixed models with the
package lme4, we can think if all of these in one framework, where
nested and crossed designs are modelled in the same way. Thinking about
factors as crossed or nested is simplified to careful labelling of
factor levels - more on this later.</p>
<div id="running-the-analysis-7" class="section level3">
<h3>Running the analysis</h3>
<p>We will do as we did before using <code>Modification</code> as a
fixed facor with two levels <code>modified</code> and
<code>pristine</code>, but this time we will consider <strong>two random
effects</strong> (<code>Estuary</code> and <code>Site</code>).
<code>Site</code> is nested within <code>Estuary</code> as each site can
only belong in one estuary. When entering the data, however, we’ve been
careless and numbered sites within each estuary as 1, 2, 3 etc.</p>
<p>We can see this by looking at the data, and a cross tabulation.</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb98-1"><a href="#cb98-1" tabindex="-1"></a>Estuaries[<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, ]</span></code></pre></div>
<pre><code>##     X Modification Estuary Site Hydroid Total Schizoporella.errata TotalSim
## 1   1     Modified     JAK    1       0    44                   15 43.12720
## 2   2     Modified     JAK    1       0    42                    8 39.56374
## 3   3     Modified     JAK    2       0    32                    9 48.19294
## 4   4     Modified     JAK    2       0    44                   14 34.31714
## 5   5     Modified     JAK    3       1    42                    6 39.75357
## 6   6     Modified     JAK    3       1    48                   12 22.54602
## 7   7     Modified     JAK    4       0    45                   28 27.52905
## 8   8     Modified     JAK    4       0    34                    1 50.60222
## 9   9     Pristine     JER    1       7    29                    0 44.78266
## 10 10     Pristine     JER    1       5    51                    0 30.36883</code></pre>
<div class="sourceCode" id="cb100"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb100-1"><a href="#cb100-1" tabindex="-1"></a><span class="fu">xtabs</span>(<span class="sc">~</span> Estuary <span class="sc">+</span> Site, Estuaries, <span class="at">sparse =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<pre><code>## 7 x 4 sparse Matrix of class &quot;dgCMatrix&quot;
##        Site
## Estuary 1 2 3 4
##     BOT 2 2 2 2
##     CLY 2 2 2 2
##     HAK 2 2 2 2
##     JAK 2 2 2 2
##     JER 2 2 2 2
##     KEM 2 2 . 2
##     WAG 2 2 2 2</code></pre>
<p>Estuary <code>JAK</code> and estuary <code>JER</code> each have sites
numbered <code>1</code>, even though these sites are not connected in
any way. We can also see this in the cross tabulation
<code>xtabs</code>. This site labelling looks crossed, where each site
occurs in each estuary, rather than nested.</p>
<p>We can fix this by simply telling R that <code>Site</code> is nested
in <code>Estuary</code>. It is best practice, however, to do this at the
data entry stage. If things are the same, then they should be labelled
the same, and if they are not they should be labelled differently.</p>
<p>To create a unique label for each site in this data set, we convert
<code>Site</code> to a factor (it was an integer), and create a new
variable (<code>SiteWithin</code>) that is the combination of Estuary
and Site</p>
<div class="sourceCode" id="cb102"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb102-1"><a href="#cb102-1" tabindex="-1"></a>Estuaries<span class="sc">$</span>Site <span class="ot">&lt;-</span> <span class="fu">as.factor</span>(Estuaries<span class="sc">$</span>Site)</span>
<span id="cb102-2"><a href="#cb102-2" tabindex="-1"></a>Estuaries<span class="sc">$</span>SiteWithin <span class="ot">&lt;-</span> <span class="fu">paste0</span>(Estuaries<span class="sc">$</span>Estuary, <span class="st">&quot;_&quot;</span>, Estuaries<span class="sc">$</span>Site)</span></code></pre></div>
<p>Now, check the structure to see that each site is nested in only one
Estuary, consistent with the experimental design.</p>
<div class="sourceCode" id="cb103"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb103-1"><a href="#cb103-1" tabindex="-1"></a><span class="fu">xtabs</span>(<span class="sc">~</span> Estuary <span class="sc">+</span> SiteWithin, Estuaries, <span class="at">sparse =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<pre><code>## 7 x 27 sparse Matrix of class &quot;dgCMatrix&quot;</code></pre>
<pre><code>##   [[ suppressing 27 column names &#39;BOT_1&#39;, &#39;BOT_2&#39;, &#39;BOT_3&#39; ... ]]</code></pre>
<pre><code>##        SiteWithin
## Estuary                                                      
##     BOT 2 2 2 2 . . . . . . . . . . . . . . . . . . . . . . .
##     CLY . . . . 2 2 2 2 . . . . . . . . . . . . . . . . . . .
##     HAK . . . . . . . . 2 2 2 2 . . . . . . . . . . . . . . .
##     JAK . . . . . . . . . . . . 2 2 2 2 . . . . . . . . . . .
##     JER . . . . . . . . . . . . . . . . 2 2 2 2 . . . . . . .
##     KEM . . . . . . . . . . . . . . . . . . . . 2 2 2 . . . .
##     WAG . . . . . . . . . . . . . . . . . . . . . . . 2 2 2 2</code></pre>
<p>To fit a model for total abundance, we would use:</p>
<div class="sourceCode" id="cb107"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb107-1"><a href="#cb107-1" tabindex="-1"></a>fit.mod <span class="ot">&lt;-</span> <span class="fu">lmer</span>(Total <span class="sc">~</span> Modification <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> Estuary) <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> SiteWithin), <span class="at">data =</span> Estuaries)</span>
<span id="cb107-2"><a href="#cb107-2" tabindex="-1"></a><span class="co"># same as: lmer(Total ~ Modification + (1 | Estuary/SiteWithin), data = Estuaries)</span></span>
<span id="cb107-3"><a href="#cb107-3" tabindex="-1"></a><span class="fu">summary</span>(fit.mod)</span></code></pre></div>
<pre><code>## Linear mixed model fit by REML [&#39;lmerMod&#39;]
## Formula: Total ~ Modification + (1 | Estuary) + (1 | SiteWithin)
##    Data: Estuaries
## 
## REML criterion at convergence: 386.6
## 
## Scaled residuals: 
##     Min      1Q  Median      3Q     Max 
## -1.8686 -0.6687  0.1504  0.6505  1.9816 
## 
## Random effects:
##  Groups     Name        Variance Std.Dev.
##  SiteWithin (Intercept) 49.85    7.061   
##  Estuary    (Intercept) 47.59    6.899   
##  Residual               43.65    6.607   
## Number of obs: 54, groups:  SiteWithin, 27; Estuary, 7
## 
## Fixed effects:
##                      Estimate Std. Error t value
## (Intercept)            41.053      4.739   8.662
## ModificationPristine  -14.553      6.232  -2.335
## 
## Correlation of Fixed Effects:
##             (Intr)
## MdfctnPrstn -0.760</code></pre>
<p>where <code>Total</code> is the dependent variable (left of the
<code>~</code>), <code>Modification</code> is the fixed effect, and
<code>Estuary</code> and <code>SiteWithin</code> are the random
effects.</p>
<p>We’ll also fit the <strong>WRONG</strong> model, to see the
difference if we had used the old labels for each site.</p>
<div class="sourceCode" id="cb109"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb109-1"><a href="#cb109-1" tabindex="-1"></a>fit.wrong <span class="ot">&lt;-</span> <span class="fu">lmer</span>(Total <span class="sc">~</span> Modification <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> Estuary) <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> Site), <span class="at">data =</span> Estuaries)</span>
<span id="cb109-2"><a href="#cb109-2" tabindex="-1"></a><span class="fu">summary</span>(fit.wrong)</span></code></pre></div>
<pre><code>## Linear mixed model fit by REML [&#39;lmerMod&#39;]
## Formula: Total ~ Modification + (1 | Estuary) + (1 | Site)
##    Data: Estuaries
## 
## REML criterion at convergence: 393.6
## 
## Scaled residuals: 
##     Min      1Q  Median      3Q     Max 
## -2.3312 -0.7631  0.1040  0.5766  1.8202 
## 
## Random effects:
##  Groups   Name        Variance Std.Dev.
##  Estuary  (Intercept) 53.613   7.322   
##  Site     (Intercept)  7.686   2.772   
##  Residual             80.045   8.947   
## Number of obs: 54, groups:  Estuary, 7; Site, 4
## 
## Fixed effects:
##                      Estimate Std. Error t value
## (Intercept)            41.257      4.849   8.508
## ModificationPristine  -14.757      6.124  -2.410
## 
## Correlation of Fixed Effects:
##             (Intr)
## MdfctnPrstn -0.727</code></pre>
<p>The only place we can see an obvious difference is under the Random
effects table. For the <strong>correct</strong> model we have Number of
obs: 52, groups: SiteWithin, 26; Estuary, 7 while the
<strong>wrong</strong> model tells us we have only 4 sites, which we
know is incorrect.</p>
<p><em>Note</em>: fit.wrong would be correct if we had crossed
factors</p>
</div>
<div id="model-assumption-1" class="section level3">
<h3>Model assumption</h3>
<p>The assumptions are the same as for one random factor. Briefly,
assumptions 1 and 5 cannot be checked, but can be ensured by taking
random samples, and assumption 6 is not crucial and difficult to check.
To check assumption 2 we look for a straight line relationship on the
normal quantile plot. To check assumptions 3, and 4 we look for a fan
shape and U shape on the residual vs. fitted plot.</p>
<div class="sourceCode" id="cb111"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb111-1"><a href="#cb111-1" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>))</span>
<span id="cb111-2"><a href="#cb111-2" tabindex="-1"></a><span class="fu">qqnorm</span>(<span class="fu">residuals</span>(fit.mod))</span>
<span id="cb111-3"><a href="#cb111-3" tabindex="-1"></a><span class="fu">scatter.smooth</span>(<span class="fu">residuals</span>(fit.mod) <span class="sc">~</span> <span class="fu">fitted</span>(fit.mod)) <span class="co"># residual plot</span></span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-71-1.png" width="672" /></p>
<p>The normal quantile plot looks reasonable, however we see here a
definite fan shape in the residual vs. fit plot. Let’s try transforming
the response and see if we do better.</p>
<div class="sourceCode" id="cb112"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb112-1"><a href="#cb112-1" tabindex="-1"></a>fit.mod <span class="ot">&lt;-</span> <span class="fu">lmer</span>(<span class="fu">log</span>(Total) <span class="sc">~</span> Modification <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> Estuary) <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> SiteWithin), <span class="at">data =</span> Estuaries)</span>
<span id="cb112-2"><a href="#cb112-2" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>))</span>
<span id="cb112-3"><a href="#cb112-3" tabindex="-1"></a><span class="fu">qqnorm</span>(<span class="fu">residuals</span>(fit.mod))</span>
<span id="cb112-4"><a href="#cb112-4" tabindex="-1"></a><span class="fu">scatter.smooth</span>(<span class="fu">residuals</span>(fit.mod) <span class="sc">~</span> <span class="fu">fitted</span>(fit.mod)) <span class="co"># residual plot</span></span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-72-1.png" width="672" />
This scatterplot is much better, the fan shape is all but gone. The
smooth line is below zero on the left, but there are relatively few
points there, so it’s not of great concern.</p>
</div>
<div id="interpreting-2" class="section level3">
<h3>Interpreting</h3>
<div id="hypothesis-test-for-the-fixed-effect-1" class="section level4">
<h4>Hypothesis test for the fixed effect</h4>
<p>We can use the <code>anova</code> as before to obtain approximate
p-values for fixed effects (but this also the <code>lmerTest</code>
package).</p>
<div class="sourceCode" id="cb113"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb113-1"><a href="#cb113-1" tabindex="-1"></a>ft.mod <span class="ot">&lt;-</span> <span class="fu">lmer</span>(<span class="fu">log</span>(Total) <span class="sc">~</span> Modification <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> Estuary) <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> SiteWithin), <span class="at">data =</span> Estuaries, <span class="at">REML =</span> F)</span>
<span id="cb113-2"><a href="#cb113-2" tabindex="-1"></a>ft.mod<span class="fl">.0</span> <span class="ot">&lt;-</span> <span class="fu">lmer</span>(<span class="fu">log</span>(Total) <span class="sc">~</span> (<span class="dv">1</span> <span class="sc">|</span> Estuary) <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> SiteWithin), <span class="at">data =</span> Estuaries, <span class="at">REML =</span> F)</span>
<span id="cb113-3"><a href="#cb113-3" tabindex="-1"></a><span class="fu">anova</span>(ft.mod<span class="fl">.0</span>, ft.mod)</span></code></pre></div>
<pre><code>## Data: Estuaries
## Models:
## ft.mod.0: log(Total) ~ (1 | Estuary) + (1 | SiteWithin)
## ft.mod: log(Total) ~ Modification + (1 | Estuary) + (1 | SiteWithin)
##          npar    AIC    BIC  logLik deviance  Chisq Df Pr(&gt;Chisq)  
## ft.mod.0    4 79.223 87.179 -35.611   71.223                       
## ft.mod      5 77.397 87.342 -33.698   67.397 3.8258  1    0.05047 .
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>We find no evidence of an effect of Modification (p=0.05047).</p>
</div>
<div id="hypothesis-test-for-random-effects-1" class="section level4">
<h4>Hypothesis test for random effects</h4>
<p>Similar to before, we can use a parametric bootstrapping to test the
random effects. We will test if we need to have a random effect for Site
given we have a random effect for Estuary in the model.</p>
<div class="sourceCode" id="cb115"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb115-1"><a href="#cb115-1" tabindex="-1"></a>nBoot <span class="ot">&lt;-</span> <span class="dv">1000</span></span>
<span id="cb115-2"><a href="#cb115-2" tabindex="-1"></a>lrStat <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="cn">NA</span>, nBoot)</span>
<span id="cb115-3"><a href="#cb115-3" tabindex="-1"></a>ft.null <span class="ot">&lt;-</span> <span class="fu">lmer</span>(<span class="fu">log</span>(Total) <span class="sc">~</span> Modification <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> Estuary), Estuaries, <span class="at">REML =</span> F) <span class="co"># null model</span></span>
<span id="cb115-4"><a href="#cb115-4" tabindex="-1"></a>ft.alt <span class="ot">&lt;-</span> <span class="fu">lmer</span>(<span class="fu">log</span>(Total) <span class="sc">~</span> Modification <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> Estuary) <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> SiteWithin), Estuaries, <span class="at">REML =</span> F) <span class="co"># alternate model</span></span>
<span id="cb115-5"><a href="#cb115-5" tabindex="-1"></a>lrObs <span class="ot">&lt;-</span> <span class="dv">2</span> <span class="sc">*</span> <span class="fu">logLik</span>(ft.alt) <span class="sc">-</span> <span class="dv">2</span> <span class="sc">*</span> <span class="fu">logLik</span>(ft.null) <span class="co"># observed test stat</span></span>
<span id="cb115-6"><a href="#cb115-6" tabindex="-1"></a><span class="cf">for</span> (iBoot <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nBoot)</span>
<span id="cb115-7"><a href="#cb115-7" tabindex="-1"></a>{</span>
<span id="cb115-8"><a href="#cb115-8" tabindex="-1"></a>  Estuaries<span class="sc">$</span>logTotalSim <span class="ot">&lt;-</span> <span class="fu">unlist</span>(<span class="fu">simulate</span>(ft.null)) <span class="co"># resampled data</span></span>
<span id="cb115-9"><a href="#cb115-9" tabindex="-1"></a>  bNull <span class="ot">&lt;-</span> <span class="fu">lmer</span>(logTotalSim <span class="sc">~</span> Modification <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> Estuary), Estuaries, <span class="at">REML =</span> F) <span class="co"># null model</span></span>
<span id="cb115-10"><a href="#cb115-10" tabindex="-1"></a>  bAlt <span class="ot">&lt;-</span> <span class="fu">lmer</span>(logTotalSim <span class="sc">~</span> Modification <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> Estuary) <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> SiteWithin), Estuaries, <span class="at">REML =</span> F) <span class="co"># alternate model</span></span>
<span id="cb115-11"><a href="#cb115-11" tabindex="-1"></a>  lrStat[iBoot] <span class="ot">&lt;-</span> <span class="dv">2</span> <span class="sc">*</span> <span class="fu">logLik</span>(bAlt) <span class="sc">-</span> <span class="dv">2</span> <span class="sc">*</span> <span class="fu">logLik</span>(bNull) <span class="co"># resampled test stat</span></span>
<span id="cb115-12"><a href="#cb115-12" tabindex="-1"></a>}</span></code></pre></div>
<pre><code>## Warning in checkConv(attr(opt, &quot;derivs&quot;), opt$par, ctrl = control$checkConv, :
## Model failed to converge with max|grad| = 0.00295856 (tol = 0.002, component 1)</code></pre>
<div class="sourceCode" id="cb117"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb117-1"><a href="#cb117-1" tabindex="-1"></a><span class="fu">mean</span>(lrStat <span class="sc">&gt;</span> lrObs) <span class="co"># P-value for test of Estuary effect</span></span></code></pre></div>
<pre><code>## [1] 0</code></pre>
<p>The p-value is 0, so very small. We have strong evidence of an effect
of Site and should keep it in the model.</p>
</div>
</div>
</div>
<div id="generalised-mixed-models" class="section level2">
<h2>Generalised mixed models</h2>
<p>This allows to model discrete data (e.g., presence/absence) with
random effects using generalised linear mixed models (GLMMs).</p>
<div id="assumptions-5" class="section level3">
<h3>Assumptions</h3>
<p>The assumptions of generalised linear mixed models are a combination
of the assumptions of GLMs and mixed models.</p>
<ul>
<li>The observed <span class="math inline">\(y\)</span> are independent,
conditional on some predictors <span
class="math inline">\(x\)</span></li>
<li>The response <span class="math inline">\(y\)</span> comes from a
known distribution from the exponential family, with a known mean
variance relationship</li>
<li>There is a straight line relationship between some known function
(link) of the mean of <span class="math inline">\(y\)</span> and the
predictors <span class="math inline">\(x\)</span> and random effects
<span class="math inline">\(z\)</span></li>
<li>Random effects <span class="math inline">\(z\)</span> are
independent of <span class="math inline">\(y\)</span></li>
<li>Random effects <span class="math inline">\(z\)</span> are normally
distributed</li>
</ul>
</div>
<div id="running-the-analysis-8" class="section level3">
<h3>Running the analysis</h3>
<p>The package <code>lme4</code> allows us to model both continuous and
discrete data with one or more random effects. There are however some
limitations for discrete data.</p>
<p><strong>What lme4 can do</strong> - model binary data (e.g.,
presence/absence) - model counts with Poisson distribution</p>
<p><strong>What lme4 can’t do</strong> - model overdispersed counts
(unfortunately these are really common in ecology) - provide good
residual plots (we need these for assumption checking)</p>
<p>In this example, we have a <strong>fixed effect</strong>
(Modification; modified vs pristine) and a <strong>random
effect</strong> (Estuary). To test whether there is an effect of
modification on individual <strong>species counts</strong> and
<strong>presence/absences</strong>, we need to use generalised linear
mixed models with the with the glmer function.</p>
<p>Consider the counts of hydroids (the variable Hydroid).</p>
<div class="sourceCode" id="cb119"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb119-1"><a href="#cb119-1" tabindex="-1"></a>Estuaries<span class="sc">$</span>Hydroid</span></code></pre></div>
<pre><code>##  [1] 0 0 0 0 1 1 0 0 7 5 2 0 0 0 3 3 0 0 0 0 0 0 0 0 0 0 1 1 2 1 2 2 0 0 0 0 0 0
## [39] 0 0 0 0 1 0 0 0 0 3 1 0 1 2 2 2</code></pre>
<p>Looking at the data, you can see the counts are small, with many
zeros, so we don’t want to treat these as continuous. We will model them
as counts with a Poisson distribution, and also as presence/absence
data.</p>
<div id="binary-data" class="section level4">
<h4>Binary data</h4>
<p>To model presence/absence, we first create a variable HydroidPres
which is 1 (TRUE) when Hydroids are present and 0 (FALSE) otherwise.</p>
<div class="sourceCode" id="cb121"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb121-1"><a href="#cb121-1" tabindex="-1"></a>Estuaries<span class="sc">$</span>HydroidPres <span class="ot">&lt;-</span> Estuaries<span class="sc">$</span>Hydroid <span class="sc">&gt;</span> <span class="dv">0</span></span></code></pre></div>
<p>To fit a model for the presence or absence of hydroids, we would use
<code>glmer</code> with <code>family=binomial</code></p>
<div class="sourceCode" id="cb122"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb122-1"><a href="#cb122-1" tabindex="-1"></a>fit.bin <span class="ot">&lt;-</span> <span class="fu">glmer</span>(HydroidPres <span class="sc">~</span> Modification <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> Estuary), <span class="at">family =</span> binomial, <span class="at">data =</span> Estuaries)</span></code></pre></div>
<p>As usual, we can examine residual plots to check assumptions.</p>
<div class="sourceCode" id="cb123"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb123-1"><a href="#cb123-1" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>))</span>
<span id="cb123-2"><a href="#cb123-2" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">residuals</span>(fit.bin) <span class="sc">~</span> <span class="fu">fitted</span>(fit.bin), <span class="at">main =</span> <span class="st">&quot;residuals v.s. Fitted&quot;</span>)</span>
<span id="cb123-3"><a href="#cb123-3" tabindex="-1"></a><span class="fu">qqnorm</span>(<span class="fu">residuals</span>(fit.bin))</span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-78-1.png" width="672" /></p>
<p>Briefly looking at our assumptions, Assumptions 1 and 4 we can’t
check, but will be true if we sample randomly. Assumption 5 is hard to
check in general and not crucial. Assumption 2 and 3 we should check
with the residual plots. Unfortunately, for binary data residual plots
are quite difficult to interpret. In the residual v.s. fitted plot all
the 0’s are in a line (lower left) and all the ones are in a line (upper
right) due to the discreteness of the data.</p>
<p><strong>Hypothesis testing</strong></p>
<ul>
<li>Fixed effects</li>
</ul>
<p>For generalised linear mixed models (GLMMs), you can use
<code>lmerTest</code> or use the parametric bootstrap for fixed effects
inference. The p-values from the <code>anova</code> function are quite
approximate for GLMMs even for fixed effects. Sometimes the
<code>glmer</code> function will give warnings or errors.</p>
<div class="sourceCode" id="cb124"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb124-1"><a href="#cb124-1" tabindex="-1"></a>nBoot <span class="ot">&lt;-</span> <span class="dv">1000</span></span>
<span id="cb124-2"><a href="#cb124-2" tabindex="-1"></a>lrStat <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="cn">NA</span>, nBoot)</span>
<span id="cb124-3"><a href="#cb124-3" tabindex="-1"></a>ft.null <span class="ot">&lt;-</span> <span class="fu">glmer</span>(HydroidPres <span class="sc">~</span> <span class="dv">1</span> <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> Estuary), <span class="at">family =</span> binomial, <span class="at">data =</span> Estuaries) <span class="co"># null model</span></span>
<span id="cb124-4"><a href="#cb124-4" tabindex="-1"></a>ft.alt <span class="ot">&lt;-</span> <span class="fu">glmer</span>(HydroidPres <span class="sc">~</span> Modification <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> Estuary), <span class="at">family =</span> binomial, <span class="at">data =</span> Estuaries) <span class="co"># alternate model</span></span>
<span id="cb124-5"><a href="#cb124-5" tabindex="-1"></a></span>
<span id="cb124-6"><a href="#cb124-6" tabindex="-1"></a>lrObs <span class="ot">&lt;-</span> <span class="dv">2</span> <span class="sc">*</span> <span class="fu">logLik</span>(ft.alt) <span class="sc">-</span> <span class="dv">2</span> <span class="sc">*</span> <span class="fu">logLik</span>(ft.null) <span class="co"># observed test stat</span></span>
<span id="cb124-7"><a href="#cb124-7" tabindex="-1"></a></span>
<span id="cb124-8"><a href="#cb124-8" tabindex="-1"></a><span class="cf">for</span> (iBoot <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nBoot)</span>
<span id="cb124-9"><a href="#cb124-9" tabindex="-1"></a>{</span>
<span id="cb124-10"><a href="#cb124-10" tabindex="-1"></a>  Estuaries<span class="sc">$</span>HydroidPresSim <span class="ot">&lt;-</span> <span class="fu">unlist</span>(<span class="fu">simulate</span>(ft.null)) <span class="co"># resampled data</span></span>
<span id="cb124-11"><a href="#cb124-11" tabindex="-1"></a>  <span class="fu">tryCatch</span>(</span>
<span id="cb124-12"><a href="#cb124-12" tabindex="-1"></a>    { <span class="co"># sometimes the glmer code doesn&#39;t converge</span></span>
<span id="cb124-13"><a href="#cb124-13" tabindex="-1"></a></span>
<span id="cb124-14"><a href="#cb124-14" tabindex="-1"></a>      bNull <span class="ot">&lt;-</span> <span class="fu">glmer</span>(HydroidPresSim <span class="sc">~</span> <span class="dv">1</span> <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> Estuary), <span class="at">family =</span> binomial, <span class="at">data =</span> Estuaries) <span class="co"># null model</span></span>
<span id="cb124-15"><a href="#cb124-15" tabindex="-1"></a>      bAlt <span class="ot">&lt;-</span> <span class="fu">glmer</span>(HydroidPresSim <span class="sc">~</span> Modification <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> Estuary), <span class="at">family =</span> binomial, <span class="at">data =</span> Estuaries) <span class="co"># alternate model</span></span>
<span id="cb124-16"><a href="#cb124-16" tabindex="-1"></a>      lrStat[iBoot] <span class="ot">&lt;-</span> <span class="dv">2</span> <span class="sc">*</span> <span class="fu">logLik</span>(bAlt) <span class="sc">-</span> <span class="dv">2</span> <span class="sc">*</span> <span class="fu">logLik</span>(bNull) <span class="co"># resampled test stat</span></span>
<span id="cb124-17"><a href="#cb124-17" tabindex="-1"></a>    },</span>
<span id="cb124-18"><a href="#cb124-18" tabindex="-1"></a>    <span class="at">warning =</span> <span class="cf">function</span>(war) {</span>
<span id="cb124-19"><a href="#cb124-19" tabindex="-1"></a>      lrStat[iBoot] <span class="ot">&lt;-</span> <span class="cn">NA</span></span>
<span id="cb124-20"><a href="#cb124-20" tabindex="-1"></a>    },</span>
<span id="cb124-21"><a href="#cb124-21" tabindex="-1"></a>    <span class="at">error =</span> <span class="cf">function</span>(err) {</span>
<span id="cb124-22"><a href="#cb124-22" tabindex="-1"></a>      lrStat[iBoot] <span class="ot">&lt;-</span> <span class="cn">NA</span></span>
<span id="cb124-23"><a href="#cb124-23" tabindex="-1"></a>    }</span>
<span id="cb124-24"><a href="#cb124-24" tabindex="-1"></a>  ) <span class="co"># if code doesn&#39;t converge skip sim</span></span>
<span id="cb124-25"><a href="#cb124-25" tabindex="-1"></a>}</span>
<span id="cb124-26"><a href="#cb124-26" tabindex="-1"></a><span class="fu">mean</span>(lrStat <span class="sc">&gt;</span> lrObs, <span class="at">na.rm =</span> T) <span class="co"># P-value for test of Estuary effect</span></span></code></pre></div>
<pre><code>## [1] 0.04086266</code></pre>
<p>We have evidence of an effect of modification on the presence of
hydroids.</p>
<ul>
<li>Random effects</li>
</ul>
<p>As before you could run hypothesis tests on the random effects using
a parametric bootstrap.</p>
</div>
<div id="count-data" class="section level4">
<h4>Count data</h4>
<p><code>lme4</code> can model count data that has a Poisson
distribution. If the data do not fit the Poisson mean/variance
relationship, then things become much more complicated, and we won’t
cover that situation here.</p>
<p>To model the counts of hydroids, we would use use <code>glmer</code>
with <code>family=poisson</code>.</p>
<div class="sourceCode" id="cb126"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb126-1"><a href="#cb126-1" tabindex="-1"></a>fit.pois <span class="ot">&lt;-</span> <span class="fu">glmer</span>(Hydroid <span class="sc">~</span> Modification <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> Estuary), <span class="at">family =</span> poisson, <span class="at">data =</span> Estuaries)</span></code></pre></div>
<p>To check the assumptions:</p>
<div class="sourceCode" id="cb127"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb127-1"><a href="#cb127-1" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>))</span>
<span id="cb127-2"><a href="#cb127-2" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">residuals</span>(fit.pois) <span class="sc">~</span> <span class="fu">fitted</span>(fit.pois), <span class="at">main =</span> <span class="st">&quot;Residuals vs. Fitted&quot;</span>)</span>
<span id="cb127-3"><a href="#cb127-3" tabindex="-1"></a><span class="fu">qqnorm</span>(<span class="fu">residuals</span>(fit.pois))</span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-81-1.png" width="672" /></p>
<p>Once again, the residual plots aren’t that useful, but we at least
get an idea about whether the variance assumption is reasonable. There
is no obvious fan shape, so a Poisson model seems okay.</p>
<ul>
<li>Fixed effects</li>
</ul>
<div class="sourceCode" id="cb128"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb128-1"><a href="#cb128-1" tabindex="-1"></a>nBoot <span class="ot">&lt;-</span> <span class="dv">1000</span></span>
<span id="cb128-2"><a href="#cb128-2" tabindex="-1"></a>lrStat <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="cn">NA</span>, nBoot)</span>
<span id="cb128-3"><a href="#cb128-3" tabindex="-1"></a>ft.null <span class="ot">&lt;-</span> <span class="fu">glmer</span>(Hydroid <span class="sc">~</span> <span class="dv">1</span> <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> Estuary), <span class="at">family =</span> poisson, <span class="at">data =</span> Estuaries) <span class="co"># null model</span></span>
<span id="cb128-4"><a href="#cb128-4" tabindex="-1"></a>ft.alt <span class="ot">&lt;-</span> <span class="fu">glmer</span>(Hydroid <span class="sc">~</span> Modification <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> Estuary), <span class="at">family =</span> poisson, <span class="at">data =</span> Estuaries) <span class="co"># alternate model</span></span>
<span id="cb128-5"><a href="#cb128-5" tabindex="-1"></a></span>
<span id="cb128-6"><a href="#cb128-6" tabindex="-1"></a>lrObs <span class="ot">&lt;-</span> <span class="dv">2</span> <span class="sc">*</span> <span class="fu">logLik</span>(ft.alt) <span class="sc">-</span> <span class="dv">2</span> <span class="sc">*</span> <span class="fu">logLik</span>(ft.null) <span class="co"># observed test stat</span></span>
<span id="cb128-7"><a href="#cb128-7" tabindex="-1"></a><span class="cf">for</span> (iBoot <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nBoot)</span>
<span id="cb128-8"><a href="#cb128-8" tabindex="-1"></a>{</span>
<span id="cb128-9"><a href="#cb128-9" tabindex="-1"></a>  Estuaries<span class="sc">$</span>HydroidSim <span class="ot">&lt;-</span> <span class="fu">unlist</span>(<span class="fu">simulate</span>(ft.null)) <span class="co"># resampled data</span></span>
<span id="cb128-10"><a href="#cb128-10" tabindex="-1"></a>  <span class="fu">tryCatch</span>(</span>
<span id="cb128-11"><a href="#cb128-11" tabindex="-1"></a>    {</span>
<span id="cb128-12"><a href="#cb128-12" tabindex="-1"></a>      bNull <span class="ot">&lt;-</span> <span class="fu">glmer</span>(HydroidSim <span class="sc">~</span> <span class="dv">1</span> <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> Estuary), <span class="at">family =</span> poisson, <span class="at">data =</span> Estuaries) <span class="co"># null model</span></span>
<span id="cb128-13"><a href="#cb128-13" tabindex="-1"></a>      bAlt <span class="ot">&lt;-</span> <span class="fu">glmer</span>(HydroidSim <span class="sc">~</span> Modification <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> Estuary), <span class="at">family =</span> poisson, <span class="at">data =</span> Estuaries) <span class="co"># alternate model</span></span>
<span id="cb128-14"><a href="#cb128-14" tabindex="-1"></a>      lrStat[iBoot] <span class="ot">&lt;-</span> <span class="dv">2</span> <span class="sc">*</span> <span class="fu">logLik</span>(bAlt) <span class="sc">-</span> <span class="dv">2</span> <span class="sc">*</span> <span class="fu">logLik</span>(bNull) <span class="co"># resampled test stat</span></span>
<span id="cb128-15"><a href="#cb128-15" tabindex="-1"></a>    },</span>
<span id="cb128-16"><a href="#cb128-16" tabindex="-1"></a>    <span class="at">warning =</span> <span class="cf">function</span>(war) {</span>
<span id="cb128-17"><a href="#cb128-17" tabindex="-1"></a>      lrStat[iBoot] <span class="ot">&lt;-</span> <span class="cn">NA</span></span>
<span id="cb128-18"><a href="#cb128-18" tabindex="-1"></a>    },</span>
<span id="cb128-19"><a href="#cb128-19" tabindex="-1"></a>    <span class="at">error =</span> <span class="cf">function</span>(err) {</span>
<span id="cb128-20"><a href="#cb128-20" tabindex="-1"></a>      lrStat[iBoot] <span class="ot">&lt;-</span> <span class="cn">NA</span></span>
<span id="cb128-21"><a href="#cb128-21" tabindex="-1"></a>    }</span>
<span id="cb128-22"><a href="#cb128-22" tabindex="-1"></a>  ) <span class="co"># if code doesn&#39;t converge skip sim#   lrStat[iBoot]</span></span>
<span id="cb128-23"><a href="#cb128-23" tabindex="-1"></a>}</span></code></pre></div>
<ul>
<li>Random effects</li>
</ul>
<p>As before you could run hypothesis tests on the random effects using
a parametric bootstrap.</p>
<p><strong>A non Poisson example</strong></p>
<p>Often, count data will not fit a Poisson distribution. Look at what
happens if you try and model the counts of the bryozoan, Schizoporella
errata, from that same data set.</p>
<div class="sourceCode" id="cb129"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb129-1"><a href="#cb129-1" tabindex="-1"></a>fit.pois2 <span class="ot">&lt;-</span> <span class="fu">glmer</span>(Schizoporella.errata <span class="sc">~</span> Modification <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> Estuary), <span class="at">family =</span> poisson, <span class="at">data =</span> Estuaries)</span>
<span id="cb129-2"><a href="#cb129-2" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>))</span>
<span id="cb129-3"><a href="#cb129-3" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">residuals</span>(fit.pois) <span class="sc">~</span> <span class="fu">fitted</span>(fit.pois), <span class="at">main =</span> <span class="st">&quot;residuals vs. Fitted&quot;</span>)</span>
<span id="cb129-4"><a href="#cb129-4" tabindex="-1"></a><span class="fu">qqnorm</span>(<span class="fu">residuals</span>(fit.pois))</span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-83-1.png" width="672" /></p>
<p>Here we can see a distinct fan shape in the residual vs. fitted plot.
Unfortunately <code>lme4</code> can’t handle this situation
(overdispersion), and there is no easy way to model these data. If this
happens in your data try the <code>glmmADMB</code> package.</p>
<div class="sourceCode" id="cb130"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb130-1"><a href="#cb130-1" tabindex="-1"></a>fit.pois <span class="ot">&lt;-</span> <span class="fu">glmer</span>(Hydroid <span class="sc">~</span> Modification <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> Estuary), <span class="at">family =</span> poisson, <span class="at">data =</span> Estuaries)</span>
<span id="cb130-2"><a href="#cb130-2" tabindex="-1"></a>means <span class="ot">&lt;-</span> <span class="fu">fitted</span>(fit.pois) <span class="co"># this will give the estimate at each data point</span></span>
<span id="cb130-3"><a href="#cb130-3" tabindex="-1"></a>ModEst <span class="ot">&lt;-</span> <span class="fu">unique</span>(Estuaries[<span class="fu">c</span>(<span class="st">&quot;Estuary&quot;</span>, <span class="st">&quot;Modification&quot;</span>)]) <span class="co"># find which Estuaries are modified</span></span>
<span id="cb130-4"><a href="#cb130-4" tabindex="-1"></a>cols <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(ModEst[<span class="fu">order</span>(ModEst[, <span class="dv">1</span>]), <span class="dv">2</span>]) <span class="sc">+</span> <span class="dv">3</span> <span class="co"># Assign colour by modification</span></span>
<span id="cb130-5"><a href="#cb130-5" tabindex="-1"></a><span class="fu">boxplot</span>(Hydroid <span class="sc">~</span> Estuary, <span class="at">data =</span> Estuaries, <span class="at">col =</span> cols, <span class="at">xlab =</span> <span class="st">&quot;Estuary&quot;</span>, <span class="at">ylab =</span> <span class="st">&quot;Count of hydroids&quot;</span>)</span>
<span id="cb130-6"><a href="#cb130-6" tabindex="-1"></a><span class="fu">legend</span>(<span class="st">&quot;topleft&quot;</span>,</span>
<span id="cb130-7"><a href="#cb130-7" tabindex="-1"></a>  <span class="at">inset =</span> .<span class="dv">02</span>,</span>
<span id="cb130-8"><a href="#cb130-8" tabindex="-1"></a>  <span class="fu">c</span>(<span class="st">&quot;Modified&quot;</span>, <span class="st">&quot;Pristine&quot;</span>), <span class="at">fill =</span> <span class="fu">unique</span>(cols), <span class="at">horiz =</span> <span class="cn">TRUE</span>, <span class="at">cex =</span> <span class="fl">0.8</span></span>
<span id="cb130-9"><a href="#cb130-9" tabindex="-1"></a>)</span>
<span id="cb130-10"><a href="#cb130-10" tabindex="-1"></a></span>
<span id="cb130-11"><a href="#cb130-11" tabindex="-1"></a>Est.means <span class="ot">&lt;-</span> <span class="fu">summarize</span>(means, Estuaries<span class="sc">$</span>Estuary, mean)<span class="sc">$</span>means <span class="co"># extract means by Estuary</span></span>
<span id="cb130-12"><a href="#cb130-12" tabindex="-1"></a><span class="fu">stripchart</span>(Est.means <span class="sc">~</span> <span class="fu">sort</span>(<span class="fu">unique</span>(Estuary)), <span class="at">data =</span> Estuaries, <span class="at">pch =</span> <span class="dv">18</span>, <span class="at">col =</span> <span class="st">&quot;red&quot;</span>, <span class="at">vertical =</span> <span class="cn">TRUE</span>, <span class="at">add =</span> <span class="cn">TRUE</span>) <span class="co"># plot means by estuary</span></span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-84-1.png" width="672" />
&gt; <em>Source: Gordana Popovic</em></p>
</div>
</div>
</div>
</div>
<div id="generalised-additive-models-gam" class="section level1">
<h1>Generalised additive models (GAM)</h1>
<p>Many data in the environmental sciences do not fit simple linear
models and are best described by “wiggly models”, also known as
Generalised Additive Models (GAMs). Let’s start by a tweet from famous
Biostatisticians Gavin L. Simpson:</p>
<p><em>1. GAMs are just GLMs</em> <em>2. GAMs fit wiggly terms</em>
<em>3. use <code>+ s(x)</code> not <code>x</code> in your syntax</em>
<em>4. use <code>method = "REML"</code></em> <em>5. always look at
<code>gam.check()</code></em></p>
<p>This is basically all there is too it - an extension of generalised
linear models (GLMs) with a <strong>smoothing function</strong>. Of
course, there may be many sophisticated things going on when you fit a
model with smooth terms, but you only need to understand the rationale
and some basic theory.</p>
<div id="gams-in-a-nutshells-extra" class="section level2">
<h2>GAMs in a nutshells (extra)</h2>
<p>Let’s start with an equation for a Gaussian linear model:</p>
<p><span class="math display">\[y = \beta_0 + \beta_1*x_1 + \epsilon \;,
\epsilon \sim N(0,\sigma^2)\]</span> What changes in a GAM is the
presence of a smoothing term:</p>
<p><span class="math display">\[y = \beta_0 + f(x_1) + \epsilon \;,
\epsilon \sim N(0,\sigma^2)\]</span> This simply means that the
contribution to the linear predictor is now some function <span
class="math inline">\(f\)</span>. This is not that dissimilar
conceptually to using a quadratic (<span
class="math inline">\(x_1^2\)</span>) or cubic term (<span
class="math inline">\(x_1^3\)</span>) as your predictor.</p>
<p>The function <span class="math inline">\(f\)</span> can be something
more funky or kinky - here, we’re going to focus on splines. You can
have combinations of linear and smooth terms in your model, for
example:</p>
<p><span class="math display">\[y = \beta_0 + \beta_1*x_1 +f(x_2) +
\epsilon \;, \epsilon \sim N(0,\sigma^2)\]</span> or we can fit
generalised distributions and random effects, for example:</p>
<p><span class="math display">\[ln(y) = \beta_0 + f(x_1) + \epsilon \;,
\epsilon \sim Poisson(\lambda)\]</span> <span
class="math display">\[ln(y) = \beta_0 + f(x_1) + z_1 \gamma +
\epsilon  \;, \epsilon \sim Poisson(\lambda)\;, \gamma \sim N(0,
\Sigma)\]</span></p>
</div>
<div id="a-simple-example" class="section level2">
<h2>A simple example</h2>
<p>Let’s create a data frame and fill it with some simulated data with
an obvious non-linear trend and compare how well some models fit to that
data.</p>
<div class="sourceCode" id="cb131"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb131-1"><a href="#cb131-1" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="dv">0</span>, pi <span class="sc">*</span> <span class="dv">2</span>, <span class="fl">0.1</span>)</span>
<span id="cb131-2"><a href="#cb131-2" tabindex="-1"></a>sin_x <span class="ot">&lt;-</span> <span class="fu">sin</span>(x)</span>
<span id="cb131-3"><a href="#cb131-3" tabindex="-1"></a>y <span class="ot">&lt;-</span> sin_x <span class="sc">+</span> <span class="fu">rnorm</span>(<span class="at">n =</span> <span class="fu">length</span>(x), <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="fu">sd</span>(sin_x <span class="sc">/</span> <span class="dv">2</span>))</span>
<span id="cb131-4"><a href="#cb131-4" tabindex="-1"></a>Sample_data <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(y, x)</span>
<span id="cb131-5"><a href="#cb131-5" tabindex="-1"></a><span class="fu">ggplot</span>(Sample_data, <span class="fu">aes</span>(x, y)) <span class="sc">+</span></span>
<span id="cb131-6"><a href="#cb131-6" tabindex="-1"></a>  <span class="fu">geom_point</span>()</span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-85-1.png" width="672" />
Let’s fit a normal linear model and check residuals:</p>
<div class="sourceCode" id="cb132"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb132-1"><a href="#cb132-1" tabindex="-1"></a>lm_y <span class="ot">&lt;-</span> <span class="fu">lm</span>(y <span class="sc">~</span> x, <span class="at">data =</span> Sample_data)</span>
<span id="cb132-2"><a href="#cb132-2" tabindex="-1"></a><span class="fu">ggplot</span>(Sample_data, <span class="fu">aes</span>(x, y)) <span class="sc">+</span></span>
<span id="cb132-3"><a href="#cb132-3" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb132-4"><a href="#cb132-4" tabindex="-1"></a>  <span class="fu">geom_smooth</span>(<span class="at">method =</span> lm)</span></code></pre></div>
<pre><code>## `geom_smooth()` using formula = &#39;y ~ x&#39;</code></pre>
<p><img src="stat_2_files/figure-html/unnamed-chunk-86-1.png" width="672" /></p>
<div class="sourceCode" id="cb134"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb134-1"><a href="#cb134-1" tabindex="-1"></a><span class="fu">plot</span>(lm_y, <span class="at">which =</span> <span class="dv">1</span>)</span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-86-2.png" width="672" /></p>
<p>Clearly, the residuals are not evenly spread across values of <span
class="math inline">\(x\)</span>, that’s call a pattern in the
residuals. We need to consider a better model.</p>
<p>The package <code>mgcv</code> is the package of choice for running
GAMs in R. To run a GAM, we use:</p>
<div class="sourceCode" id="cb135"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb135-1"><a href="#cb135-1" tabindex="-1"></a>gam_y <span class="ot">&lt;-</span> <span class="fu">gam</span>(y <span class="sc">~</span> <span class="fu">s</span>(x), <span class="at">method =</span> <span class="st">&quot;REML&quot;</span>)</span></code></pre></div>
<p>To extract the fitted values, we can use <code>predict</code> just
like normal:</p>
<div class="sourceCode" id="cb136"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb136-1"><a href="#cb136-1" tabindex="-1"></a>x_new <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="dv">0</span>, <span class="fu">max</span>(x), <span class="at">length.out =</span> <span class="dv">100</span>)</span>
<span id="cb136-2"><a href="#cb136-2" tabindex="-1"></a>y_pred <span class="ot">&lt;-</span> <span class="fu">predict</span>(gam_y, <span class="fu">data.frame</span>(<span class="at">x =</span> x_new))</span></code></pre></div>
<p>But for simple models, we can also utilise the <code>method =</code>
argument in <code>geom_smooth</code>, specifying the model formula.</p>
<div class="sourceCode" id="cb137"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb137-1"><a href="#cb137-1" tabindex="-1"></a><span class="fu">ggplot</span>(Sample_data, <span class="fu">aes</span>(x, y)) <span class="sc">+</span></span>
<span id="cb137-2"><a href="#cb137-2" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb137-3"><a href="#cb137-3" tabindex="-1"></a>  <span class="fu">geom_smooth</span>(<span class="at">method =</span> <span class="st">&quot;gam&quot;</span>, <span class="at">formula =</span> y <span class="sc">~</span> <span class="fu">s</span>(x))</span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-89-1.png" width="672" /></p>
<p>You can see the model is better fit to the data, but always check the
diagnostics.</p>
<p><code>check.gam</code> is quick and easy to view the residual
plots.</p>
<div class="sourceCode" id="cb138"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb138-1"><a href="#cb138-1" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">2</span>))</span>
<span id="cb138-2"><a href="#cb138-2" tabindex="-1"></a><span class="fu">gam.check</span>(gam_y)</span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-90-1.png" width="672" /></p>
<pre><code>## 
## Method: REML   Optimizer: outer newton
## full convergence after 6 iterations.
## Gradient range [-1.409504e-10,1.258771e-10]
## (score 26.13264 &amp; scale 0.09517106).
## Hessian positive definite, eigenvalue range [2.283034,30.7237].
## Model rank =  10 / 10 
## 
## Basis dimension (k) checking results. Low p-value (k-index&lt;1) may
## indicate that k is too low, especially if edf is close to k&#39;.
## 
##        k&#39;  edf k-index p-value
## s(x) 9.00 6.02    1.17    0.84</code></pre>
<p>Using summary with the model object will give you the significance of
the smooth term (along with any parametric terms, if you’ve included
them), along with the variance explained. In this example, a pretty
decent fit. The ‘edf’ is the estimated degrees of freedom - essentially,
the larger the number, the more wiggly the fitted model. Values of
around 1 tend to be close to a linear term. You can read about
penalisation and shrinkage for more on what the edf reflects.</p>
<p>As mentioned above, we focus on <strong>splines</strong>, as they are
the <strong>smooth functions</strong> that are most commonly implemented
(and are pretty quick and stable). This is where we say we want to fit
<span class="math inline">\(y\)</span> as a linear function of some set
of functions of <span class="math inline">\(x\)</span> . The default in
<code>mgcv</code> is a <strong>thin plate regression spline</strong> -
the two common ones you’ll probably see are these, and <strong>cubic
regression splines</strong>. Cubic regression splines have the
traditional knots that we think of when we talk about splines - they’re
evenly spread across the covariate range in this case.</p>
</div>
<div id="a-real-world-example-extra" class="section level2">
<h2>A real world example (extra)</h2>
<p>We’re going to look at some CO2 data from Manua Loa (Hawaii). We will
fit a couple GAMs to the data to try and pick apart the intra- and
inter-annual trends. We want to look at inter-annual trend first, so
let’s convert the date into a continuous time variable (take a subset
for visualisation).</p>
<div class="sourceCode" id="cb140"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb140-1"><a href="#cb140-1" tabindex="-1"></a>CO2 <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="st">&quot;data/mauna_loa_co2.csv&quot;</span>)</span>
<span id="cb140-2"><a href="#cb140-2" tabindex="-1"></a>CO2<span class="sc">$</span>time <span class="ot">&lt;-</span> <span class="fu">as.integer</span>(<span class="fu">as.Date</span>(CO2<span class="sc">$</span>Date, <span class="at">format =</span> <span class="st">&quot;%d/%m/%Y&quot;</span>))</span>
<span id="cb140-3"><a href="#cb140-3" tabindex="-1"></a>CO2_dat <span class="ot">&lt;-</span> CO2</span>
<span id="cb140-4"><a href="#cb140-4" tabindex="-1"></a>CO2 <span class="ot">&lt;-</span> CO2_dat[CO2_dat<span class="sc">$</span>year <span class="sc">%in%</span> (<span class="dv">2000</span><span class="sc">:</span><span class="dv">2010</span>), ]</span></code></pre></div>
<p>OK, so let’s plot it and look at a smooth term for time.</p>
<div class="sourceCode" id="cb141"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb141-1"><a href="#cb141-1" tabindex="-1"></a><span class="fu">ggplot</span>(CO2_dat, <span class="fu">aes</span>(time, co2)) <span class="sc">+</span></span>
<span id="cb141-2"><a href="#cb141-2" tabindex="-1"></a>  <span class="fu">geom_line</span>()</span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-92-1.png" width="672" /></p>
<p><span class="math display">\[y = \beta_0 + f_{trend}(time) + \epsilon
\;, \epsilon \sim N(0,\sigma^2)\]</span> We can fit a GAM for these data
using:</p>
<div class="sourceCode" id="cb142"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb142-1"><a href="#cb142-1" tabindex="-1"></a>CO2_time <span class="ot">&lt;-</span> <span class="fu">gam</span>(co2 <span class="sc">~</span> <span class="fu">s</span>(time), <span class="at">data =</span> CO2, <span class="at">method =</span> <span class="st">&quot;REML&quot;</span>)</span></code></pre></div>
<p>which fits a model with a single smooth term for time. We can look at
the predicted values for this:</p>
<div class="sourceCode" id="cb143"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb143-1"><a href="#cb143-1" tabindex="-1"></a><span class="fu">plot</span>(CO2_time)</span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-94-1.png" width="672" /></p>
<p>Note how the smooth term actually reduces to a ‘normal’ linear term
here (with an edf of 1) - that’s the nice thing about penalised
regression splines. But if we check the model, then we see something is
amuck.</p>
<div class="sourceCode" id="cb144"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb144-1"><a href="#cb144-1" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">2</span>))</span>
<span id="cb144-2"><a href="#cb144-2" tabindex="-1"></a><span class="fu">gam.check</span>(CO2_time)</span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-95-1.png" width="672" /></p>
<pre><code>## 
## Method: REML   Optimizer: outer newton
## full convergence after 8 iterations.
## Gradient range [-0.0001447502,6.463421e-05]
## (score 291.2359 &amp; scale 4.79491).
## Hessian positive definite, eigenvalue range [0.0001447177,64.99994].
## Model rank =  10 / 10 
## 
## Basis dimension (k) checking results. Low p-value (k-index&lt;1) may
## indicate that k is too low, especially if edf is close to k&#39;.
## 
##         k&#39; edf k-index p-value    
## s(time)  9   1    0.16  &lt;2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>The residual plots have a very odd looking rise-and-fall pattern -
clearly there is some dependance structure (and we can probably guess it
has something to do with intra-annual fluctuations). Let’s try again,
and introduce something called a cyclical smoother.</p>
<p><span class="math display">\[y = \beta_0 +f_{intrannual}(month)+
f_{trend}(time) + \epsilon \;, \epsilon \sim N(0,\sigma^2)\]</span></p>
<p>The cyclical smooth term, <span
class="math inline">\(f_{intrannual}(month)\)</span>, is comprised of
basis functions just the same as we have seen already, except that the
end points of the spline are constrained to be equal - which makes sense
when we’re modelling a variable that is <em>cyclical</em> (across
months/years).</p>
<p>We’ll now see the <code>bs =</code> argument to choose the type of
smoother, and the <code>k =</code> argument to choose the number of
knots, because cubic regression splines have a set number of knots. We
use 12 knots, because there are 12 months.</p>
<div class="sourceCode" id="cb146"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb146-1"><a href="#cb146-1" tabindex="-1"></a>CO2_season_time <span class="ot">&lt;-</span> <span class="fu">gam</span>(co2 <span class="sc">~</span> <span class="fu">s</span>(month, <span class="at">bs =</span> <span class="st">&quot;cc&quot;</span>, <span class="at">k =</span> <span class="dv">12</span>) <span class="sc">+</span> <span class="fu">s</span>(time), <span class="at">data =</span> CO2, <span class="at">method =</span> <span class="st">&quot;REML&quot;</span>)</span></code></pre></div>
<p>Let’s look at the fitted smooth terms:</p>
<div class="sourceCode" id="cb147"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb147-1"><a href="#cb147-1" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>))</span>
<span id="cb147-2"><a href="#cb147-2" tabindex="-1"></a><span class="fu">plot</span>(CO2_season_time)</span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-97-1.png" width="672" /></p>
<p>Looking at both smooth terms, we can see that the monthly smoother is
picking up that monthly rise and fall of CO2 - looking at the relative
magnitudes (i.e. monthly fluctuation vs. long-term trend), we can see
how important it is to disintangle the components of the time series.
Let’s see how the model diagnostics look now:</p>
<div class="sourceCode" id="cb148"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb148-1"><a href="#cb148-1" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">2</span>))</span>
<span id="cb148-2"><a href="#cb148-2" tabindex="-1"></a><span class="fu">gam.check</span>(CO2_season_time)</span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-98-1.png" width="672" /></p>
<pre><code>## 
## Method: REML   Optimizer: outer newton
## full convergence after 6 iterations.
## Gradient range [-2.640054e-06,5.25847e-08]
## (score 87.72571 &amp; scale 0.1441556).
## Hessian positive definite, eigenvalue range [1.026183,65.43149].
## Model rank =  20 / 20 
## 
## Basis dimension (k) checking results. Low p-value (k-index&lt;1) may
## indicate that k is too low, especially if edf is close to k&#39;.
## 
##             k&#39;   edf k-index p-value    
## s(month) 10.00  8.67    0.72  &lt;2e-16 ***
## s(time)   9.00  6.61    0.87    0.04 *  
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>Much better. Let’s look at how the seasonal component stacks up
against the full long term trend.</p>
<div class="sourceCode" id="cb150"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb150-1"><a href="#cb150-1" tabindex="-1"></a>CO2_season_time <span class="ot">&lt;-</span> <span class="fu">gam</span>(co2 <span class="sc">~</span> <span class="fu">s</span>(month, <span class="at">bs =</span> <span class="st">&quot;cc&quot;</span>, <span class="at">k =</span> <span class="dv">12</span>) <span class="sc">+</span> <span class="fu">s</span>(time), <span class="at">data =</span> CO2_dat, <span class="at">method =</span> <span class="st">&quot;REML&quot;</span>)</span>
<span id="cb150-2"><a href="#cb150-2" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>))</span>
<span id="cb150-3"><a href="#cb150-3" tabindex="-1"></a><span class="fu">plot</span>(CO2_season_time)</span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-99-1.png" width="672" /></p>
<p>You can essentially present model results from a GAM as if it were
any other linear model, the main difference being that for the smooth
terms, there is no single coefficient you can make inference from
(i.e. negative, positive, effect size etc.). So you need to rely on
either interpretting the parital effects of the smooth terms visually
(e.g. from a call to <code>plot(gam_model)</code>) or make inference
from the predicted values. You can of course include normal linear terms
in the model (either continuous or categorical, and in an ANOVA type
framework even) and make inference from them like you normally would.
Indeed, GAMs are often useful for accounting for a non-linear phenomonon
that is not directly of interest, but needs to be acocunted for when
making inferece about other variables.</p>
<div class="sourceCode" id="cb151"><pre
class="sourceCode r"><code class="sourceCode r"><span id="cb151-1"><a href="#cb151-1" tabindex="-1"></a>CO2_pred <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb151-2"><a href="#cb151-2" tabindex="-1"></a>  <span class="at">time =</span> CO2_dat<span class="sc">$</span>time,</span>
<span id="cb151-3"><a href="#cb151-3" tabindex="-1"></a>  <span class="at">co2 =</span> CO2_dat<span class="sc">$</span>co2,</span>
<span id="cb151-4"><a href="#cb151-4" tabindex="-1"></a>  <span class="at">predicted_values =</span> <span class="fu">predict</span>(CO2_season_time, <span class="at">newdata =</span> CO2_dat)</span>
<span id="cb151-5"><a href="#cb151-5" tabindex="-1"></a>)</span>
<span id="cb151-6"><a href="#cb151-6" tabindex="-1"></a><span class="fu">ggplot</span>(CO2_pred, <span class="fu">aes</span>(<span class="at">x =</span> time)) <span class="sc">+</span></span>
<span id="cb151-7"><a href="#cb151-7" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="fu">aes</span>(<span class="at">y =</span> co2), <span class="at">size =</span> <span class="dv">1</span>, <span class="at">alpha =</span> <span class="fl">0.5</span>) <span class="sc">+</span></span>
<span id="cb151-8"><a href="#cb151-8" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="fu">aes</span>(<span class="at">y =</span> predicted_values), <span class="at">colour =</span> <span class="st">&quot;red&quot;</span>)</span></code></pre></div>
<p><img src="stat_2_files/figure-html/unnamed-chunk-100-1.png" width="672" /></p>
<p>There’s more to the story - perhaps spatial autocorrelation of some
kind - but we will end it for today. A great blog with lots of stuff on
GAMs: <a href="https://www.fromthebottomoftheheap.net/"
class="uri">https://www.fromthebottomoftheheap.net/</a></p>
<blockquote>
<p><em>Source: Mitchell Lyons</em></p>
</blockquote>
<blockquote>
<p>References:</p>
</blockquote>
<p>Bruce, P., Bruce, A. (2017). Pratical Statistics for Data Scientists.
O’Reilly Media, Inc.</p>
<p>Peña, E. A., &amp; Slate, E. H. (2006). Global validation of linear
model assumptions. Journal of the American Statistical Association,
101(473), 341-354.</p>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
