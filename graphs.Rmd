---
title: "Graphics"
---

```{r eval = TRUE,  message=F, include=F, warning=F, purl=F, results="hide"}
knitr::purl('graphs.Rmd', documentation = F)
```

```{r echo=FALSE, purl=F}
xfun::embed_file('graphs.Rmd')
```

```{r echo=FALSE, purl=F}
xfun::embed_file('graphs.R')
```

```{r echo=FALSE, purl=F}
xfun::embed_file('data/gene_data.txt', sep="\t", h=T, row.names = 1)
```

```{r echo=FALSE}
xaringanExtra::use_clipboard()
```

-----------------------

Simple plots can easily be produced with the plotting functions in `base` R. These are installed by default with R and do not require any additional packages to be installed. They’re quick to type, straightforward to use in simple cases, and run very quickly.


If you want to do anything beyond very simple plots, though, it’s generally better to switch to ggplot2. This is in part because ggplot2 provides a unified interface and set of options, instead of the grab bag of modifiers and special cases required in base graphics. Once you learn how ggplot2 works, you can use that knowledge for everything from scatter plots and histograms to violin plots and maps.


In this section, we will illustrate how to make a graph with base graphics and 
how to make a similar graph with the ggplot() function in ggplot2. Having both of these examples will help you transition to using ggplot2 for when you want to make more sophisticated graphics.

Get inspired by [**THE R GRAPH GALLERY**](https://r-graph-gallery.com/)

# `base` package

## Basic scatter and line charts

First we’ll produce a very simple graph using the values in a numeric vector:

```{r,  eval=T}
treatment <- c(0.02,1.8, 17.5, 55,75.7, 80)
```

Now we plot the treatment vector with default parameters.

```{r,  eval=T, fig.align='center'}
plot(treatment)
```

We produced a simple **scatter** plot. Let make it a **line** plot: 

```{r,  eval=T, fig.align='center'}
plot(treatment, type = 'o')
```

We changed the type of plot to `o` which plot both **points** and **lines**. Check `?plot` to see a complete list and make a **line** plot. By changing the argument `type`, we are **customizing** the plot.

## Plot customization

### Type

See the complete list of plot `type` using `?plot`. 

```{r,  eval=T, fig.align='center'}
plot(treatment, type="l")
```

### Title

We add a title with `main` argument and or a sub-title with the `sub` argument.

```{r,  eval=T, fig.align='center'}
plot(treatment, main="My Plot", sub="a plot")
```

### Axis labels

We can customize our x and y axis label with the `xlab` and `ylab` arguments respectively.

```{r,  eval=T, fig.align='center'}
plot(treatment, xlab="Position", ylab="score")
```

We can control the orientation of labels on axis using `las` argument.

```{r,  eval=T, fig.align='center'}
plot(treatment, las=1)
plot(treatment, las=2)
```

### Point size

We can control the size of points in our plot using the `cex` parameter.

```{r,  eval=T, fig.align='center'}
plot(treatment, cex=2)
plot(treatment, cex=0.5)
```

### Point shape

We can control the type of points in our plot using the `pch` parameter.

```{r,  eval=T, fig.align='center'}
plot(treatment, pch=1)
plot(treatment, pch=20)
```

### Line weight

Similarly when plotting a line we control size with `lwd` parameter.

```{r,  eval=T, fig.align='center'}
plot(treatment, type="l",lwd=10)
plot(treatment, type="l",lwd=0.5)
```

### Line type

We can also control the type of line with `lty` parameter.

```{r,  eval=T, fig.align='center'}
plot(treatment, type="l",lty=1)
plot(treatment, type="l",lty=2)
```

### Color

An important parameter we can control is color. We can control color or lines or points using the `col` argument.

```{r,  eval=T, fig.align='center'}
plot(treatment, type="l", col="red")
plot(treatment, type="l", col="dodgerblue")
```

You can find an extensive list of R colors [here](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf#page=8.00). But you can also use hexadecimal code color [here](https://htmlcolorcodes.com/). You can also specify `rgb` color and use define `alpha` to set transparency.

```{r,  eval=T, fig.align='center'}
myRed <- rgb(1,0,0, alpha=0.5)
plot(treatment, type="p", cex=4, pch=20, col=myRed)
```

`par` set or query graphical parameters. Among other uses (size of plot margins `mar`, spacing between margin elements `mgp`, dimensions of whole plot `fig`, etc.), you modify `par` to plot two graphs next to each others


```{r,  eval=T, fig.align='center'}
par(mfrow = c(1, 2))
plot(treatment, type="p", cex=4, pch=20, col=myRed)
plot(treatment, type="p", cex=4, pch=20, col='#87736f')
```

Using `par(mfrow = c(1, 2))`, you split your graphical window into a grid by specifying the number of row first and the number of column them. Any modification using `par` will be applied to next plots. You can terminated using `dev.off()`.

```{r,  eval=T}
dev.off()
```

A lot of graphical parameters can be modified using `par`. See the full list of set parameters using `par()` or `?par`. Change will apply to all subsequent plots until your reset your graphical parameters using `dev.off()`.

## Multiplot vectors plot

Index plot are generally use explore your data nut of course the `plot` function will accept two vectors to be plotted against each other.

```{r,  eval=T,  fig.align='center'}
control <- c(0, 20, 40, 60, 80,100)
plot(control,treatment)
```

We often want multiple lines in same plot. So if we want to plot scores for control and treatment against position we will need a new method.

We can add an additional line to our existing plot using the `lines()` function.

```{r,  eval=T,  fig.align='center'}
plot(treatment, type="o", col="blue")
lines(control, type="o", pch=22, lty=2, col="red")
```

### Defining your limits 

The new line doesn’t quite fit into our original plot. We can extend our x or y axis by specifying values to `xlim` and `ylim` arguments directly.

```{r,  eval=T,  fig.align='center'}
plot(treatment, type="o", col="blue",ylim=c(0,100))
lines(control, type="o", pch=22, lty=2, col="red")
```

Instead of defining the axis limits explicitly we can compute the y-axis values using the range function. This means any updates to our data will be automatically reflected in our graph. `range()` returns a vector containing the minimum and maximum of all the given arguments.

Calculate range from 0 to max value of data.

```{r,  eval=T}
g_range <- range(0, treatment, control)
g_range
```

Then plot using this range values as your limits

```{r,  eval=T, fig.align='center'}
plot(treatment, type="o", col="blue", ylim=g_range)
```

### Customize axes

To be able to customize axes we need to turn off axes and annotations (axis labels). We will then be able to specify them ourselves. We turn of axis and annotation plotting using `axes=FALSE` and `ann=FALSE`

```{r,  eval=T, fig.align='center'}
plot(treatment, type="o", col="blue", ylim=g_range, axes=FALSE, ann=FALSE)
```

We can create our own X axis by using the `axis()` function. We specify the `side` argument for where to place axis, the `at` argument to specify where to put axis ticks and `lab` argument to specify labels for axis ticks.

```{r,  eval=T, fig.align='center'}
plot(treatment, type="o", col="blue", ylim=g_range, axes=FALSE, ann=FALSE)
axis(side=1, at=1:6, lab=c("Mon","Tue","Wed","Thu","Fri","Sat"))
```

We can make our y axis with horizontal labels that display ticks at every 20 marks in a similar way. We specify our `side` and use `seq()` function to make axis tick postions for `at` argument. We can use our y-axis range again to help define how many ticks we need.

```{r,  eval=T, fig.align='center'}
plot(treatment, type="o", col="blue", ylim=g_range, axes=FALSE, ann=FALSE)
axis(side=1, at=1:6, lab=c("Mon","Tue","Wed","Thu","Fri","Sat"))
axis(2, las=1, at=seq(0,g_range[2],by=20))
```

### Framing plot

We can now add a box around our plot using the `box()` function.

```{r,  eval=T, fig.align='center'}
plot(treatment, type="o", col="blue", ylim=g_range, axes=FALSE, ann=FALSE)
axis(side=1, at=1:6, lab=c("Mon","Tue","Wed","Thu","Fri","Sat"))
axis(2, las=1, at=seq(0,g_range[2],by=20))
box()
```

And add back our control using the `line` argument.

```{r,  eval=T, fig.align='center'}
plot(treatment, type="o", col="blue", ylim=g_range, axes=FALSE, ann=FALSE)
axis(side=1, at=1:6, lab=c("Mon","Tue","Wed","Thu","Fri","Sat"))
axis(2, las=1, at=seq(0,g_range[2],by=20))
lines(control, type="o", pch=22, lty=2, col="red")
box()
```

### Legends

Finally we may wish to add a legend to out plot. We can add a legend to current plot using the `legend()` function. We need to specify where to place legend in plot, the names in legend to `legend` argument and any additional point/line type configuration we used e.g the color and shape.

```{r,  eval=T, fig.align='center'}
plot(treatment, type="o", col="blue", ylim=g_range, axes=FALSE, ann=FALSE)
axis(side=1, at=1:6, lab=c("Mon","Tue","Wed","Thu","Fri","Sat"))
axis(2, las=1, at=seq(0,g_range[2],by=20))
box()

legend("topleft",legend=c("treatment","control"), col=c("blue","red"), pch=21:22, lty=1:2) 
```

### Final

In our line plot we have already done a good job of making it easier to differentiate the lines as we have different line styles and different shape points. Other things we can do is also differentiate thickness. To make that final plot you can see that there are many lines of code we put together.

```{r,  eval=T, fig.align='center'}
plot(treatment, type="o", col="blue", lwd=1, ylim=g_range,axes=FALSE, ann=FALSE)
axis(1, at=1:6, lab=c("Mon","Tue","Wed","Thu","Fri","Sat"))
axis(2, las=1, at=20*0:g_range[2])
box()

lines(control, type="o", pch=22, lty=2, col="red", lwd=2.5)
legend("topleft",legend=c("treatment","control"),col=c("blue","red"), pch=21:22, lty=1:2, lwd=c(1,2.5))
```

### Palettes

~4% of people are color blind. In white males this number raises to ~10%. Considering the demographics in science, there will likely be someone with color blindness in your meeting. Palette packages exist that contain a curated collection colors. These can be themed for anything, from La Croix flavors to Pokemon. A list of palettes can be found [here](https://github.com/EmilHvitfeldt/paletteer). Some of the more useful palettes are designed to be color blind friendly, like `viridis`. To get colors from the package you just have to call the function with the number of colors you want.

```{r,  eval=T, warning=F, message=F}
# install.packages('viridis')
library(viridis)
viridis(5)
```

### Good data visualization

There are often a trade offs in creating good plots.

- Is it easy to digest and accesible to everyone?
- Is it engaging and appealing?
- Does it contain all the information with nothing superfluous?
- Is it the best way to tell the story I want to tell?

[Fundamentals of Data Visualization](https://clauswilke.com/dataviz/) by Claus O. Wilke is a good resource on the theory of making data visualizations the right way.

## Histograms

Base graphics has a useful built-in function for histograms too. This is the `hist()` function, which just needs a numeric vector.

```{r,  eval=T, fig.align='center'}
hist(treatment)
```

Similar customization exists as for other plots.

```{r,  eval=T, fig.align='center'}
hist(treatment, col="lightblue", ylim=c(0,5),cex.main=0.8)
```

We can create more fine grained histogram by specify the number of required bins to the `breaks` argument.

```{r,  eval=T, fig.align='center'}
par(mfrow = c(1, 2))
hist(treatment, col="lightblue", ylim=c(0,5), cex.main=0.8, breaks = 2)
hist(treatment, col="lightblue", ylim=c(0,5), cex.main=0.8, breaks = 10)
dev.off()
```

## Dot charts

Base graphics also has a `dotchart()` function. Dot charts help compare **paired** data. First though we need to modify data to a matrix. As we are comparing in pairs as opposed to all control versus treatment, we use the function `t` to return the transpose of a matrix. This means rows are now columns and the columns are now rows.

```{r,  eval=T}
data<-data.frame(treatment, control)
row.names(data)<-c("Mon","Tue","Wed","Thu","Fri","Sat")
```

The Cleveland plot on the transposed matrix:

```{r,  eval=T, fig.align='center'}
dotchart(as.matrix(t(data)))
```

Some customization: 

```{r,  eval=T, fig.align='center'}
dotchart(as.matrix(t(data)), color=c("red","blue"),main="Dotchart", cex=0.5)
```


## Box plots

The final plot we will look at here is a box and whisker plot. Boxplots allow you to quickly review data distributions, showing the median and 1st/3rd quartile.

```{r, echo=FALSE, fig.align='center', fig.cap="Introduction to boxplot", out.width = '100%'}
knitr::include_graphics("illustrations/boxplot.png")
```


First lets read some gene expression data

```{r,  eval=T}
exprs <- read.delim("data/gene_data.txt",sep="\t",h=T,row.names = 1)
head(exprs)
```

Now we can use the `boxplot()` function on our data.frame to get our boxplot

```{r,  eval=T, fig.align='center'}
boxplot(exprs)
```

This plot would look better on a log scale. We can add addition colors and labels as with other plots.

```{r,  eval=T, fig.align='center'}
boxplot(log2(exprs),ylab="log2 Expression", col=c("red","red","blue","blue"))
```

Check at `?boxplot`. `x` can be a formula of the type `y ~ grp` where `y` is a numeric vector of data values to be split into groups according to the grouping variable `grp` (usually a factor).

```{r,  eval=T, fig.align='center'}
boxplot(len ~ dose, data = ToothGrowth,
        boxwex = 0.25, at = 1:3 - 0.2,
        horizontal=T, las= 1,
        subset = supp == "VC", col = "yellow",
        main = "Guinea Pigs' Tooth Growth",
        xlab = "tooth length",
        ylab = "Vitamin C dose mg",
        xlim = c(0.5, 3.5), ylim = c(0, 35), yaxs='i')
```

Note that by default the specified ranges of a plot are enlarged by 6%, so that the specified values do not lie at the very edges of the plot region. This is
appropriate for most types of plot, but sometimes we want the specified limits to lie at the edges of the plot window. This can be specified separately for each axis using the arguments `xaxs='i'` and `yaxs='i'`.

## Extra elements

### Text

Custom text can be added to you plot using the `text` function. Simply provide the position and the label. You can use the data itself to label data points. The `adj` argument allows you to nudge the annotation a constant amount away from the defined position. Any labels to be added to the margin need to use `mtext` instead.

```{r,  eval=T, fig.align='center'}
plot(control, treatment)
text(20,60, 'THIS AREA OF \n THE PLOT HAS \n NO SAMPLE', col='red')
text(control, treatment, letters[1:6], adj=c(0,-1), col='blue')
```

### Lines 

`abline` allows you to add specific straight lines. This is often useful to help demonstrate known linear relationships or thresholds as reference points for your data. `h` = horizontal line with y-intercept `v` = vertical line with x-intercept  `a`,`b` = intercept and slope.

```{r,  eval=T, fig.align='center'}
plot(control, treatment)
abline(h=10, col='blue')
abline(v=50, col='red', lwd=2)
abline(a=0, b=1, lty=2)
```

### Shapes

`polygon` allows you to draw specific polygons. You just need to give it the coordinates of each vertex. Again this is often to highlight specific parts of the plot. This can be filled, or if you give the denisty argument there will be a hash fill.

```{r,  eval=T, fig.align='center'}
plot(control, treatment)
polygon(c(50,50,100,100),c(50,80,80,50), col='gray', density=5)
```

## Saving

There are many different ways of saving your plots in R. The easiest way is to use the export button in the plot pane in RStudio. This is not good reproducible practice though as the code is not tied to the plot.

To save plots through the console, the argument you would need is name of file in which you want to save the plot. Plotting commands then can be entered as usual. The output would be redirected to the file.

```{r,  eval=F}
bmp(filename, width = 480, height = 480, units = "px", 
    pointsize = 12)
jpeg(filename, width = 480, height = 480, units = "px", 
     pointsize  = 12, quality = 75)
```

When you’re done with your plotting commands, enter the `dev.off()` command.

### Saving in bitmap format

```{r,  eval=T}
bmp(file = "outputs/control.bmp")
plot(control)
dev.off()
```


### Saving in jpeg format

```{r,  eval=T}
jpeg(file = "control.jpg", quality = 20)
plot(control)
dev.off()
```

### Saving in postscript format

```{r,  eval=T}
postscript(file = "control.ps")
plot(control)
dev.off()
```

### Saving in pdf format

PDFs are maybe the most useful format to export into. PDFs are vector-based so each part of the plot is saved as scalable coordinates as opposed to specific pixels.

PDFs can then be opened in imaging software like illustrator or [inkscape](https://inkscape.org/) (this is a open source and free software). When you open a PDF in these programs you can fully customize the plots to your aesthetic with a graphic user interface. Furthermore as they are vector-based, they can be easily assembled into publication quality figures without resolution issues and pixelation.

```{r,  eval=T}
pdf(file = "control.pdf", paper = "A4")
plot(control)
dev.off()
```



<p class="comment">
**Practice 5.1** Using the `iris` dataset, reproduce the plot below. Explore the function `pairs` allowing to generate a matrix of scatter plots.
</p>


```{r, echo=FALSE, fig.align='center', fig.cap="A refined scatter plot using base R graphics", out.width = '50%'}
knitr::include_graphics("illustrations/iris-plot.png")
```

# `ggplot2`

The R language has extensive graphical capabilities. Graphics in R may be created by many different methods including `base` graphics and more advanced plotting packages such as `lattice`.

```{r, echo=FALSE, fig.align='center', fig.cap="A refined scatter plot using base R graphics", out.width = '50%'}
knitr::include_graphics("illustrations/base-lattice.jfif")
```

The `ggplot2` package was created by Hadley Wickham to provide an intuitive plotting system to rapidly generate publication quality graphics. `ggplot2` builds on the concept of the **“Grammar of Graphics”** (Wilkinson 2005, Bertin 1983) which describes a consistent syntax for the construction of a wide range of complex graphics by a concise description of their components. `ggplot2` is a core part of the **Tidyverse**, the group of packages designed to make data science easy and functional in R. To get an introduction to the core concepts of Tidyverse check out previous materials on `tidyr` and `dplyr`.

For an extensive gide on `ggplot2` please refer to **R graphics Cookbook** by Winston Chang available [HERE](https://r-graphics.org/). 

## Why use `ggplot2`?

The structured syntax and high level of abstraction used by ggplot2 should allow for the user to concentrate on the visualizations instead of creating the underlying code. On top of this central philosophy `ggplot2` has:

- Increased flexible over many plotting systems.
- An advanced theme system for professional/publication level graphics.
- Large developer base – Many libraries extending its flexibility.
- Large user base – Great documentation and active mailing list.

## Grammar of graphics

### How `ggplot` builds a plot.

A plot in `ggplot2` consists of different **primary layering components**, with the three primary components being:

+ The **dataset** that houses the data to be plotted. The *data* is what we want to visualize. It consists of variables, which are stored as columns in a data frame.
+ The **aesthetics** which describe how data are to be mapped to the geometric elements (color, shape, size, etc..). Aesthetic attributes, or *aesthetics*, are visual properties of **geoms**, such as x and y position, line color, point shapes, etc. There are *mappings* from data values to aesthetics.
+ The **geometric elements** to use in the plot (i.e. points, lines, rectangles, etc…). *Geoms* are the geometric objects that are drawn to represent the data, such as bars, lines, and points.

**Additional (optional) layering components** include:

+ **Statistical** elements such as smoothing, binning or transforming the variable
+ **Scales** control the mapping from the values in the data space to values in the aesthetic space. 
+ **Guides** show the viewer how to map the visual properties back to the data space. The most commonly used guides are the tick marks and labels on an axis.
+ **Facets** for conditional or trellis plots
+ **Coordinate systems** for defining the plots shape (i.e. Cartesian, polar, spatial map projections, etc…)


```{r, echo=FALSE, fig.align='center', fig.cap="A refined scatter plot using base R graphics", out.width = '50%'}
knitr::include_graphics("illustrations/ggplot-map.jfif")
```

### Overview of a scatter plot


Overview of example code for a `ggplot2` scatter plot.

```{r,  eval=F}
ggplot(data = <default data set>, 
       aes(x = <default x axis variable>,
           y = <default y axis variable>,
           ... <other default aesthetic mappings>),
       ... <other plot defaults>) +

       geom_scatter(aes(size = <size variable for this geom>, 
                      ... <other aesthetic mappings>),
                  data = <data for this point geom>,
                  stat = <statistic string or function>,
                  position = <position string or function>,
                  color = <"fixed color specification">,
                  <other arguments, possibly passed to the _stat_ function) +

  scale_<aesthetic>_<type>(name = <"scale label">,
                     breaks = <where to put tick marks>,
                     labels = <labels for tick marks>,
                     ... <other options for the scale>) +
  
  ggtitle("Graphics/Plot")+
  xlab("Weight")+
  ylab("Height")+

  theme(plot.title = element_text(color = "gray"),
        ... <other theme elements>)
```

Don't panic, you usually specify only a subset of arguments. 

```{r, echo=FALSE, fig.align='center', fig.cap="A refined scatter plot using base R graphics", out.width = '50%'}
knitr::include_graphics("illustrations/ggplot-map-simple.jfif")
```


### Example

As seen above, in order to produce a ggplot2 graph we need a minimum of:

- Data to be used in graph
- Mappings of data to the graph (aesthetic mapping)
- What type of graph we want to use (The geom to use).

In the code below we define the data as our `iris` data frame.

```{r,  eval=T}
ggiris <- ggplot(data=iris)
class(ggiris)
ggiris$data[1:4,]
```

Now we can see that we have gg/ggplot object (`ggiris`). Within this gg/ggplot object the data has been defined, however important information on how to map the data to the visual properties (aesthetics) of the plot as well as what type of plot to use (geom) have however yet to specified.

```{r,  eval=T}
ggiris$mapping
```

```{r,  eval=T}
ggiris$theme
```

```{r,  eval=T}
ggiris$layers
```

The information to map the data to the plot can be added now using the `aes()` function.


```{r,  eval=T}
ggiris <- ggplot(data=iris)
ggiris2 <- ggiris+aes(x=Petal.Length,y=Petal.Width)
ggiris2$mapping
```

```{r,  eval=T}
ggiris2$theme
```

```{r,  eval=T}
ggiris2$layers
```

But we are still missing the final component of our plot, the type of plot to use (geom). Below the `geom_point` function is used to specify a point plot, a scatter plot of *Lenght* values on the x-axis versus *Width* values on the y values.

```{r,  eval=T, fig.align='center'}
ggiris <- ggplot(data=iris)
ggiris2 <- ggiris+aes(x=Petal.Length,y=Petal.Width)
ggiris3 <- ggiris2+geom_point()
```


```{r,  eval=T}
ggiris3$mapping
```

```{r,  eval=T}
ggiris3$theme
```

```{r,  eval=T}
ggiris3$layers
```

Now we have all the components of our plot, we need we can display the results.

```{r,  eval=T, fig.align='center'}
ggiris3
```

### Geoms

More typically, the data and aesthetics are defined within ggplot function and geoms applied afterwards. This makes it easier to switch between plot types to find the best way to visualize your data.

```{r,  eval=T}
ggiris3 <- ggplot(data=iris,
                 mapping=aes(x=Petal.Length,y=Petal.Width))
ggiris3+geom_point()
```

There are many geoms available in ggplot2:

- `geom_point()` - Scatter plots
- `geom_line()` - Line plots
- `geom_smooth()` - Fitted line plots
- `geom_bar()` - Bar plots
- `geom_boxplot()` - Boxplots
- `geom_jitter()` - Jitter to plots
- `geom_histogram()` - Histogram plots
- `geom_density()` - Density plots
- `geom_text()` - Text to plots
- `geom_errorbar()` - Errorbars to plots
- `geom_violin()` - Violin plots


#### Line plots 

```{r,  eval=T, fig.align='center'}
ggiris_line<- ggiris3 + geom_line()
ggiris_line
```

#### Smoothed line plots

```{r,  eval=T, fig.align='center'}
ggiris_smooth<- ggiris3 + geom_smooth()
ggiris_smooth
```

#### Bar plots

```{r,  eval=T, fig.align='center'}
ggiris_bar<- ggplot(data=iris, mapping=aes(x=Species))
ggiris_bar2<- ggiris_bar + geom_bar()
ggiris_bar2
```

#### Histograms

```{r,  eval=T, fig.align='center'}
ggiris_hist <- ggplot(data=iris,
        mapping=aes(x=Petal.Length))
ggiris_hist2 <- ggiris_hist + geom_histogram() 
ggiris_hist2
```


#### Density plots

```{r,  eval=T, fig.align='center'}
ggiris_dens <- ggiris_hist + geom_density() 
ggiris_dens
```

#### Box plots

```{r,  eval=T, fig.align='center'}
ggiris_box <- ggplot(data=iris,
        mapping=aes(x=Species,y=Petal.Length))
ggiris_box2 <- ggiris_box+geom_boxplot() 
ggiris_box2
```

#### Violin plots

```{r,  eval=T, fig.align='center'}
pcPlot_violin <- ggiris_box+geom_violin() 
pcPlot_violin
```

#### Other geoms

An overview of geoms and their arguments can be found in the `ggplot2` documentation or within the `ggplot2` quick reference guides.

- [ggplot2 documentation](https://ggplot2.tidyverse.org/)
- [ggplot2 guide](https://sape.inf.usi.ch/quick-reference/ggplot2/geom)


### Aesthetics

In order to change the property on an aesthetic of a plot into a **constant** value (e.g. set color of all points to red) we can supply the color argument to the `geom_point()` function.

```{r,  eval=T, fig.align='center'}
ggiris_scatter <- ggplot(data=iris,
                 mapping=aes(x=Petal.Length,y=Petal.Width))
ggiris_scatter+geom_point(colour="red")
```

As we discussed earlier however, `ggplot2` makes use of aesthetic mappings to assign variables in the data to the properties/aesthetics of the plot. This allows the properties of the plot to reflect variables in the data dynamically. In these examples we supply additional information to the `aes()` function to define what information to display and how it is represented in the plot.

First we can recreate the plot we saw earlier.


```{r,  eval=T, fig.align='center'}
ggiris_scatter <- ggplot(data=iris,
                 mapping=aes(x=Petal.Length,y=Petal.Width))
ggiris_scatter+geom_point()
```

Now we can adjust the `aes` mapping by supplying an argument to the color parameter in the `aes` function. (Note that `ggplot2` accepts “color” or “colour” as parameter name)

This simple adjustment allows for identification of the separation between species for `Petal.Length` and `Petal.Width`.

```{r,  eval=T, fig.align='center'}
ggiris_scatter2 <- ggplot(data=iris,
                  mapping=aes(x=Petal.Length,y=Petal.Width,color=Species))
ggiris_scatter2 + geom_point()
```

Similarly the shape of points may be adjusted.

```{r,  eval=T, fig.align='center'}
ggiris_scatter3 <- ggplot(data=iris,
                  mapping=aes(x=Petal.Length,y=Petal.Width,shape=Species))
ggiris_scatter3 + geom_point()
```

The aesthetic mappings may be set directly in the `geom_points()` function as previously when specifying red. This can allow the same ggplot object to be used by different aesthetic mappings and varying geoms

```{r,  eval=T, fig.align='center'}
ggiris_scatter4 <- ggplot(data=iris)
ggiris_scatter4 + geom_point(aes(x=Petal.Length,y=Petal.Width,color=Species, shape=Species))
```

Again, for a comprehensive list of parameters and aesthetic mappings used in `geom_type` functions see the `ggplot2` documentation for individual geoms by using `?geom_type`

```{r,  eval=F}
?geom_point
```

or visit the ggplot2 documentations pages and quick reference:

- [ggplot2 documentation](https://ggplot2.tidyverse.org/)
- [ggplot2 guide](https://sape.inf.usi.ch/quick-reference/ggplot2/geom)

## Faceting

One very useful feature of ggplot is faceting. This allows you to produce several plots that subset by variables in your data. To facet our data into multiple plots we can use the `facet_wrap` or `facet_grid` function specifying the variable we split by. The `facet_grid` function is well suited to splitting the data by two factors.

Let's get another dataset for the demo. Here we can plot the data with the `Smokes` variable as rows and `Sex` variable as columns.

```{r,  eval=T, fig.align='center'}
patients_clean<-read.delim('data/patients_clean.txt')
pcPlot <- ggplot(data=patients_clean,aes(x=Height,y=Weight, 
                                         colour=Sex))+geom_point()
pcPlot + facet_grid(Smokes~Sex)
```

To split by one factor we use the the `facet_grid()` function again, but omit the variable before the “~”. This will facet along columns in plot.

```{r,  eval=T, fig.align='center'}
pcPlot <- ggplot(data=patients_clean,aes(x=Height,y=Weight,
                                         colour=Sex))+geom_point()
pcPlot + facet_grid(~Sex)
```

Similarly, to split along rows in plot, the variable is placed before the “~.”.

```{r,  eval=T, fig.align='center'}
pcPlot <- ggplot(data=patients_clean,aes(x=Height,y=Weight,
                                         colour=Sex))+geom_point()
pcPlot + facet_grid(Sex~.)
```

The `facet_wrap()` function offers a less grid-based structure but is well suited to faceting data by one variable. For `facet_wrap()` we follow as similar syntax to facet_grid().

```{r,  eval=T, fig.align='center'}
pcPlot <- ggplot(data=patients_clean,aes(x=Height,y=Weight,
                                         colour=Sex))+geom_point()
pcPlot + facet_wrap(~Smokes)
```

For more complex faceting both `facet_grid` and `facet_wrap` can accept combinations of variables. Here we use `facet_wrap`.

```{r,  eval=T, fig.align='center'}
pcPlot <- ggplot(data=patients_clean,aes(x=Height,y=Weight,
                                         colour=Sex))+geom_point()
pcPlot + facet_wrap(~Pet+Smokes+Sex)
```

Or in a nice grid format using facet_grid() and the Smokes variable against a combination of Gender and Pet.

```{r,  eval=T, fig.align='center'}
pcPlot + facet_grid(Smokes~Sex+Pet)
```

## Plotting order

We will shortly discuss how to change various aspects of the plot layout and appearance. However, a common-asked question is how to change the order in which R plots a categorical variable. Consider the boxplot to compare weights of males and females:

```{r,  eval=T, fig.align='center'}
ggplot(patients_clean, aes(x=Sex, y=Weight)) + geom_boxplot()
```

This is related the question raised before about the order of the factor levels. Here, R decides the order to arrange the boxes according to the levels of the categorical variable. If there are no levels or the levels are not ordered it defaults to the alphabetical order. i.e. Female before Male.

```{r,  eval=T}
levels(patients_clean$Sex)
```

Depending on the message we want the plot to convey, we might want control over the order of boxes. The factor functions allows us to explicitly change the order of the levels.


```{r,  eval=T, fig.align='center'}
patients_clean$Sex <- factor(patients_clean$Sex, 
                             levels=c("Male","Female"))
ggplot(patients_clean,aes(x=Sex, y=Weight)) + geom_boxplot()
```


## Scales


Scales and their legends have so far been handled using ggplot2 defaults. `ggplot2` offers functionality to have finer control over scales and legends using the *scale* methods.

Scale methods are divided into functions by combinations of:

- the aesthetics they control.

- the type of data mapped to scale.

Try typing in `scale_` then tab to autocomplete. This will provide some examples of the scale functions available in `ggplot2`. Although different scale functions accept some variety in their arguments, common arguments to scale functions include:


- name - The axis or legend title

- limits - Minimum and maximum of the scale

- breaks - Label/tick positions along an axis

- labels - Label names at each break

Very common *scale* functions are **scale_(x/y)_(continuous/discrete)**. In the follwoing example we control the continuous scale on the x-axis by providing a name, X-axis limits, the positions of breaks (ticks/labels) and the labels to place at breaks.

```{r,  eval=T, fig.align='center'}
pcPlot + geom_point() + facet_grid(Smokes~Sex)+
  scale_x_continuous(name="height ('cm')",
                     limits = c(100,200),
                     breaks=c(125,150,175),
                     labels=c("small","justright","tall"))
```

Similary control over discrete scales is shown below.

```{r,  eval=T, fig.align='center'}
pcPlot <- ggplot(data=patients_clean,aes(x=Sex,y=Height))
pcPlot +
  geom_violin(aes(x=Sex,y=Height)) +
  scale_x_discrete(labels=c("Women", "Men"))
```

Multiple X/Y scales can be combined to give full control of axis marks.

```{r,  eval=T, fig.align='center'}
pcPlot <- ggplot(data=patients_clean,aes(x=Sex,y=Height,fill=Smokes))
pcPlot +
  geom_violin(aes(x=Sex,y=Height)) +
  scale_x_discrete(labels=c("Women", "Men"))+
  scale_y_continuous(breaks=c(160,180),labels=c("Short", "Tall"))
```

When using fill, color, linetype, shape, size or alpha aesthetic mappings the scales are automatically selected for you and the appropriate legends created.

```{r,  eval=T, fig.align='center'}
pcPlot <- ggplot(data=patients_clean,
                 aes(x=Height,y=Weight,colour=Sex))
pcPlot + geom_point(size=4)
```

In the above example the discrete colours for the Sex variable was selected by default. Manual control of discrete variables can be performed using `scale_colour_manual` with the values parameter. Additionally in this example an updated name for the legend is provided.

```{r,  eval=T, fig.align='center'}
pcPlot <- ggplot(data=patients_clean,
                 aes(x=Height,y=Weight,colour=Sex))
pcPlot + geom_point(size=4) + 
  scale_colour_manual(values = c("Green","Purple"),
                     name="Gender")
```


## Colorbrewer

Here we have specified the colours to be used (hence the manual) but when the number of levels to a variable are high this may be impractical and often we would like ggplot2 to choose colours from a scale of our choice.

The brewer set of scale functions allow the user to make use of a range of palettes available from colorbrewer.

- Diverging

**BrBG, PiYG, PRGn, PuOr, RdBu, RdGy, RdYlBu, RdYlGn, Spectral**

- Qualitative

**Accent, Dark2, Paired, Pastel1, Pastel2, Set1, Set2, Set3**

- Sequential

**Blues, BuGn, BuPu, GnBu, Greens, Greys, Oranges, OrRd, PuBu, PuBuGn, PuRd, Purples, RdPu, Reds, YlGn, YlGnBu, YlOrBr, YlOrRd**


### `scale_color_brewer`

```{r,  eval=T, fig.align='center'}
pcPlot <- ggplot(data=patients_clean,
                 aes(x=Height,y=Weight,colour=Pet))
pcPlot + geom_point(size=4) + 
  scale_colour_brewer(palette = "Set2")
```







pcPlot <- ggplot(data=patients_clean,
        mapping=aes(x=Height,y=Weight))

pcPlot_smooth <- pcPlot+geom_smooth() 

pcPlot_smooth




```{r,  eval=T}
ggplot(data=patients_clean,
       aes(y=Weight,x=Height,colour=Sex,
           size=BMI,shape=Pet)) + 
  geom_point()
```

The aesthetic mappings may be set directly in the `geom_points()` function as previously when specifying red. This can allow the same ggplot object to be used by different aesethetic mappings and varying geoms

```{r,  eval=T}
ggplot(data=patients_clean,
       aes(y=Weight,x=Height,colour=Sex,
           size=BMI,shape=Pet)) + 
  geom_point()
```





